//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.8
//
// <auto-generated>
//
// Generated from file `StageRunMgrIPC.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __StageRunMgrIPC_h__
#define __StageRunMgrIPC_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include "CommonIPC.h"
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 8
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace BGI
{


namespace RPC
{

class StageRunMgrIPC;
class StageRunMgrIPCPrx;
class StageRunMgrIPCCallback;
class StageRunMgrIPCCallbackPrx;

}

}

namespace BGI
{

namespace RPC
{

enum class ScriptStateEnum : unsigned char
{
    Idle,
    SetupRun,
    ReadyToRun,
    ScriptRunning,
    ScriptPausing,
    ScriptPaused,
    ScriptStopping,
    Unknown
};

enum class ScriptMessageSeverityEnum : unsigned char
{
    Header,
    Verbose,
    Info,
    Warning,
    Error
};

enum class MotorTypeEnum : unsigned char
{
    SequenceNeedle,
    WashNeedle,
    FlowcellLoader
};

struct ScriptRunInfo
{
    int ScriptRunId;
    ::std::string ScriptFilename;
    int ParentScriptRunId;
    ::std::string StartDate;
    ::std::string EndDate;
    ::std::string StatusStr;
    bool IsSuccess;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const int&, const ::std::string&, const ::std::string&, const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(ScriptRunId, ScriptFilename, ParentScriptRunId, StartDate, EndDate, StatusStr, IsSuccess);
    }
};

using ScriptRunInfoList = ::std::vector<ScriptRunInfo>;

enum class DeviceCheckTypeEnum : unsigned char
{
    InitCheck,
    BeforeRunningCheck,
    RunningCheck,
    IdleCheck,
    OtherCheck
};

struct ServiceMessageInfo
{
    int MessageId;
    ::std::string InstructmentId;
    ::std::string FlowCellId;
    ::std::string UserName;
    ::std::string SoftwareVersion;
    ::BGI::RPC::ScriptMessageSeverityEnum MessageType;
    ::std::string Errorcode;
    ::std::string Message;
    ::std::string Datetime;
    bool IsPublic;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::BGI::RPC::ScriptMessageSeverityEnum&, const ::std::string&, const ::std::string&, const ::std::string&, const bool&> ice_tuple() const
    {
        return std::tie(MessageId, InstructmentId, FlowCellId, UserName, SoftwareVersion, MessageType, Errorcode, Message, Datetime, IsPublic);
    }
};

struct IpAddr
{
    ::std::string IP;
    int Port;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const int&> ice_tuple() const
    {
        return std::tie(IP, Port);
    }
};

struct ScriptMessageInfo
{
    int MessageId;
    ::BGI::RPC::ScriptMessageSeverityEnum MessageSeverity;
    ::std::string MessageDateTime;
    ::std::string MessageStr;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::BGI::RPC::ScriptMessageSeverityEnum&, const ::std::string&, const ::std::string&> ice_tuple() const
    {
        return std::tie(MessageId, MessageSeverity, MessageDateTime, MessageStr);
    }
};

using MessageArray = ::std::vector<ScriptMessageInfo>;

using AlarmMessageList = ::std::vector<ServiceMessageInfo>;

using LogMessageList = ::std::vector<ServiceMessageInfo>;

using ClearAlarmMessageIds = ::std::vector<int>;

using SequenceTypes = ::std::vector<::std::string>;

using DataList = ::std::vector<::std::string>;

struct QCDataValue
{
    ::std::string QCMetricName;
    int cycleNum;
    float QCValue;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const int&, const float&> ice_tuple() const
    {
        return std::tie(QCMetricName, cycleNum, QCValue);
    }
};

using QCDataValues = ::std::vector<QCDataValue>;

struct LoginedInfo
{
    bool IsSuccess;
    ::std::string UserRole;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const bool&, const ::std::string&> ice_tuple() const
    {
        return std::tie(IsSuccess, UserRole);
    }
};

using ExperimentInfo = ::std::map<::std::string, ::std::string>;

using RunInfo = ::std::map<::std::string, ::std::string>;

using ParaDict = ::std::map<::std::string, ::std::string>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace BGI
{

namespace RPC
{

class StageRunMgrIPC : public virtual ::Ice::Object
{
public:

    using ProxyType = StageRunMgrIPCPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual int GetHeartbeat(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetHeartbeat(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void StartSetup(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_StartSetup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SaveSelectedScriptFileName(::std::string strFileName, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SaveSelectedScriptFileName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void ScanFlowcellBarcode(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ScanFlowcellBarcode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void ScanReagentKitBarcode(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ScanReagentKitBarcode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void OverrideFlowcellBarcode(::std::string barcode, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_OverrideFlowcellBarcode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendReagentKit(::std::string reagentKit, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendReagentKit(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void StartRun(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_StartRun(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void PauseScript(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PauseScript(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void ResumeScript(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ResumeScript(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void StopScript(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_StopScript(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void AbortScript(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_AbortScript(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int RunScriptNow(::std::string strFileName, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_RunScriptNow(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ScriptRunInfo GetScriptRunInfo(int scriptRunId, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetScriptRunInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MessageArray GetScriptMessages(int startMessageId, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetScriptMessages(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SetupScriptFile(::std::string msgType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetupScriptFile(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual QCDataValues GetQCValues(::std::string qcMetricName, int startCycleNum, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetQCValues(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendSampleId(::std::string sampleId, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendSampleId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ExperimentInfo GetExperimentInfo(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetExperimentInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to DownloadScriptFile.
     */
    struct DownloadScriptFileResult
    {
        ::std::string workFlowScript;
        ::std::string imageScript;
        ::std::string biochemistryScript;
    };

    virtual void DownloadScriptFile(::std::string& workFlowScript, ::std::string& imageScript, ::std::string& biochemistryScript, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_DownloadScriptFile(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UIOperation(::std::string message, ::std::string datetime, ::std::string errorcode, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_UIOperation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual AlarmMessageList GetAlarmMessages(int startMessageId, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetAlarmMessages(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LogMessageList GetLogMessages(int startMessageId, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetLogMessages(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void ClearAlarmMessages(ClearAlarmMessageIds ids, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ClearAlarmMessages(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void ReagentNeedle(bool UP, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ReagentNeedle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendExperimentType(::std::string experimentType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendExperimentType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SetBuzzerVolume(int frenquency, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetBuzzerVolume(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SequenceTypes GetSequenceTypes(::std::string sampleId, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetSequenceTypes(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool SetClearData(DataList datas, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetClearData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void StartRunLength(int read1length, int read2length, int bardcodelength, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_StartRunLength(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SetupRunInfo(RunInfo runInfo, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetupRunInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void MotorMove(MotorTypeEnum motor, bool up, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_MotorMove(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LoginedInfo Authenicate(::std::string userName, ::std::string password, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_Authenicate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string GetLanguage(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetLanguage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SetLanguage(::std::string language, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetLanguage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SetBaseCallIpAddr(::std::string ipAddr, int port, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetBaseCallIpAddr(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SetZLIMSIpAddr(::std::string ipAddr, int port, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetZLIMSIpAddr(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual IpAddr GetZLIMSAddr(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetZLIMSAddr(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SetCategoryParas(::std::string category, ParaDict paraDict, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetCategoryParas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string GetParaValue(::std::string category, ::std::string paraName, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetParaValue(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void StartSelfCheck(DeviceCheckTypeEnum checkType, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_StartSelfCheck(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class StageRunMgrIPCCallback : public virtual ::Ice::Object
{
public:

    using ProxyType = StageRunMgrIPCCallbackPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void AddClient(::Ice::Identity ident, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_AddClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendScriptName(::std::string scriptName, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendScriptName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendActionName(::std::string actionName, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendActionName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendFlowcellBarcode(::std::string flowcellBarcode, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendFlowcellBarcode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendPositionNumber(int cycleNum, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendPositionNumber(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendPcntDone(int pctDone, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendPcntDone(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendScriptStatus(ScriptStateEnum curState, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendScriptStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendScriptMessageId(int messageId, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendScriptMessageId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendStageMessage(::std::string msgType, ::std::string message, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendStageMessage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendQCValue(QCDataValue qcValue, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendQCValue(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendQCValues(QCDataValues qcValues, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendQCValues(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendAlarmMessageId(int messageId, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendAlarmMessageId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendLogMessageId(int messageId, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendLogMessageId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendRemainingTime(double remainingTimeMinute, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendRemainingTime(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendDataList(DataList datas, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendDataList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

}

namespace BGI
{

namespace RPC
{

class StageRunMgrIPCPrx : public virtual ::Ice::Proxy<StageRunMgrIPCPrx, ::Ice::ObjectPrx>
{
public:

    int GetHeartbeat(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &StageRunMgrIPCPrx::_iceI_GetHeartbeat, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetHeartbeatAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &StageRunMgrIPCPrx::_iceI_GetHeartbeat, context);
    }

    ::std::function<void()>
    GetHeartbeatAsync(::std::function<void(int)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_GetHeartbeat, context);
    }

    /// \cond INTERNAL
    void _iceI_GetHeartbeat(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::Ice::Context&);
    /// \endcond

    void StartSetup(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_StartSetup, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto StartSetupAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_StartSetup, context);
    }

    ::std::function<void()>
    StartSetupAsync(::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_StartSetup, context);
    }

    /// \cond INTERNAL
    void _iceI_StartSetup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void SaveSelectedScriptFileName(const ::std::string& strFileName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_SaveSelectedScriptFileName, strFileName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SaveSelectedScriptFileNameAsync(const ::std::string& strFileName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_SaveSelectedScriptFileName, strFileName, context);
    }

    ::std::function<void()>
    SaveSelectedScriptFileNameAsync(const ::std::string& strFileName,
                                    ::std::function<void()> response,
                                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                    ::std::function<void(bool)> sent = nullptr,
                                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_SaveSelectedScriptFileName, strFileName, context);
    }

    /// \cond INTERNAL
    void _iceI_SaveSelectedScriptFileName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void ScanFlowcellBarcode(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_ScanFlowcellBarcode, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ScanFlowcellBarcodeAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_ScanFlowcellBarcode, context);
    }

    ::std::function<void()>
    ScanFlowcellBarcodeAsync(::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_ScanFlowcellBarcode, context);
    }

    /// \cond INTERNAL
    void _iceI_ScanFlowcellBarcode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void ScanReagentKitBarcode(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_ScanReagentKitBarcode, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ScanReagentKitBarcodeAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_ScanReagentKitBarcode, context);
    }

    ::std::function<void()>
    ScanReagentKitBarcodeAsync(::std::function<void()> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_ScanReagentKitBarcode, context);
    }

    /// \cond INTERNAL
    void _iceI_ScanReagentKitBarcode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void OverrideFlowcellBarcode(const ::std::string& barcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_OverrideFlowcellBarcode, barcode, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto OverrideFlowcellBarcodeAsync(const ::std::string& barcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_OverrideFlowcellBarcode, barcode, context);
    }

    ::std::function<void()>
    OverrideFlowcellBarcodeAsync(const ::std::string& barcode,
                                 ::std::function<void()> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_OverrideFlowcellBarcode, barcode, context);
    }

    /// \cond INTERNAL
    void _iceI_OverrideFlowcellBarcode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void SendReagentKit(const ::std::string& reagentKit, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_SendReagentKit, reagentKit, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendReagentKitAsync(const ::std::string& reagentKit, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_SendReagentKit, reagentKit, context);
    }

    ::std::function<void()>
    SendReagentKitAsync(const ::std::string& reagentKit,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_SendReagentKit, reagentKit, context);
    }

    /// \cond INTERNAL
    void _iceI_SendReagentKit(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void StartRun(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_StartRun, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto StartRunAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_StartRun, context);
    }

    ::std::function<void()>
    StartRunAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_StartRun, context);
    }

    /// \cond INTERNAL
    void _iceI_StartRun(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void PauseScript(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_PauseScript, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PauseScriptAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_PauseScript, context);
    }

    ::std::function<void()>
    PauseScriptAsync(::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_PauseScript, context);
    }

    /// \cond INTERNAL
    void _iceI_PauseScript(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void ResumeScript(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_ResumeScript, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ResumeScriptAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_ResumeScript, context);
    }

    ::std::function<void()>
    ResumeScriptAsync(::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_ResumeScript, context);
    }

    /// \cond INTERNAL
    void _iceI_ResumeScript(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void StopScript(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_StopScript, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto StopScriptAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_StopScript, context);
    }

    ::std::function<void()>
    StopScriptAsync(::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_StopScript, context);
    }

    /// \cond INTERNAL
    void _iceI_StopScript(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    void AbortScript(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_AbortScript, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto AbortScriptAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_AbortScript, context);
    }

    ::std::function<void()>
    AbortScriptAsync(::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_AbortScript, context);
    }

    /// \cond INTERNAL
    void _iceI_AbortScript(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    int RunScriptNow(const ::std::string& strFileName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &StageRunMgrIPCPrx::_iceI_RunScriptNow, strFileName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto RunScriptNowAsync(const ::std::string& strFileName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &StageRunMgrIPCPrx::_iceI_RunScriptNow, strFileName, context);
    }

    ::std::function<void()>
    RunScriptNowAsync(const ::std::string& strFileName,
                      ::std::function<void(int)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_RunScriptNow, strFileName, context);
    }

    /// \cond INTERNAL
    void _iceI_RunScriptNow(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ScriptRunInfo GetScriptRunInfo(int scriptRunId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::BGI::RPC::ScriptRunInfo>(true, this, &StageRunMgrIPCPrx::_iceI_GetScriptRunInfo, scriptRunId, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetScriptRunInfoAsync(int scriptRunId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::BGI::RPC::ScriptRunInfo>>().get_future())
    {
        return _makePromiseOutgoing<::BGI::RPC::ScriptRunInfo, P>(false, this, &StageRunMgrIPCPrx::_iceI_GetScriptRunInfo, scriptRunId, context);
    }

    ::std::function<void()>
    GetScriptRunInfoAsync(int scriptRunId,
                          ::std::function<void(::BGI::RPC::ScriptRunInfo)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::BGI::RPC::ScriptRunInfo>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_GetScriptRunInfo, scriptRunId, context);
    }

    /// \cond INTERNAL
    void _iceI_GetScriptRunInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::ScriptRunInfo>>&, int, const ::Ice::Context&);
    /// \endcond

    MessageArray GetScriptMessages(int startMessageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::BGI::RPC::MessageArray>(true, this, &StageRunMgrIPCPrx::_iceI_GetScriptMessages, startMessageId, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetScriptMessagesAsync(int startMessageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::BGI::RPC::MessageArray>>().get_future())
    {
        return _makePromiseOutgoing<::BGI::RPC::MessageArray, P>(false, this, &StageRunMgrIPCPrx::_iceI_GetScriptMessages, startMessageId, context);
    }

    ::std::function<void()>
    GetScriptMessagesAsync(int startMessageId,
                           ::std::function<void(::BGI::RPC::MessageArray)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::BGI::RPC::MessageArray>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_GetScriptMessages, startMessageId, context);
    }

    /// \cond INTERNAL
    void _iceI_GetScriptMessages(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::MessageArray>>&, int, const ::Ice::Context&);
    /// \endcond

    void SetupScriptFile(const ::std::string& msgType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_SetupScriptFile, msgType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetupScriptFileAsync(const ::std::string& msgType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_SetupScriptFile, msgType, context);
    }

    ::std::function<void()>
    SetupScriptFileAsync(const ::std::string& msgType,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_SetupScriptFile, msgType, context);
    }

    /// \cond INTERNAL
    void _iceI_SetupScriptFile(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    QCDataValues GetQCValues(const ::std::string& qcMetricName, int startCycleNum, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::BGI::RPC::QCDataValues>(true, this, &StageRunMgrIPCPrx::_iceI_GetQCValues, qcMetricName, startCycleNum, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetQCValuesAsync(const ::std::string& qcMetricName, int startCycleNum, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::BGI::RPC::QCDataValues>>().get_future())
    {
        return _makePromiseOutgoing<::BGI::RPC::QCDataValues, P>(false, this, &StageRunMgrIPCPrx::_iceI_GetQCValues, qcMetricName, startCycleNum, context);
    }

    ::std::function<void()>
    GetQCValuesAsync(const ::std::string& qcMetricName, int startCycleNum,
                     ::std::function<void(::BGI::RPC::QCDataValues)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::BGI::RPC::QCDataValues>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_GetQCValues, qcMetricName, startCycleNum, context);
    }

    /// \cond INTERNAL
    void _iceI_GetQCValues(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::QCDataValues>>&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    void SendSampleId(const ::std::string& sampleId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_SendSampleId, sampleId, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendSampleIdAsync(const ::std::string& sampleId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_SendSampleId, sampleId, context);
    }

    ::std::function<void()>
    SendSampleIdAsync(const ::std::string& sampleId,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_SendSampleId, sampleId, context);
    }

    /// \cond INTERNAL
    void _iceI_SendSampleId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ExperimentInfo GetExperimentInfo(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::BGI::RPC::ExperimentInfo>(true, this, &StageRunMgrIPCPrx::_iceI_GetExperimentInfo, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetExperimentInfoAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::BGI::RPC::ExperimentInfo>>().get_future())
    {
        return _makePromiseOutgoing<::BGI::RPC::ExperimentInfo, P>(false, this, &StageRunMgrIPCPrx::_iceI_GetExperimentInfo, context);
    }

    ::std::function<void()>
    GetExperimentInfoAsync(::std::function<void(::BGI::RPC::ExperimentInfo)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::BGI::RPC::ExperimentInfo>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_GetExperimentInfo, context);
    }

    /// \cond INTERNAL
    void _iceI_GetExperimentInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::ExperimentInfo>>&, const ::Ice::Context&);
    /// \endcond

    void DownloadScriptFile(::std::string& workFlowScript, ::std::string& imageScript, ::std::string& biochemistryScript, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<StageRunMgrIPC::DownloadScriptFileResult>(true, this, &StageRunMgrIPCPrx::_iceI_DownloadScriptFile, context).get();
        workFlowScript = ::std::move(_result.workFlowScript);
        imageScript = ::std::move(_result.imageScript);
        biochemistryScript = ::std::move(_result.biochemistryScript);
    }

    template<template<typename> class P = ::std::promise>
    auto DownloadScriptFileAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<StageRunMgrIPC::DownloadScriptFileResult>>().get_future())
    {
        return _makePromiseOutgoing<StageRunMgrIPC::DownloadScriptFileResult, P>(false, this, &StageRunMgrIPCPrx::_iceI_DownloadScriptFile, context);
    }

    ::std::function<void()>
    DownloadScriptFileAsync(::std::function<void(::std::string, ::std::string, ::std::string)> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](StageRunMgrIPC::DownloadScriptFileResult&& _result)
        {
            response(::std::move(_result.workFlowScript), ::std::move(_result.imageScript), ::std::move(_result.biochemistryScript));
        };
        return _makeLamdaOutgoing<StageRunMgrIPC::DownloadScriptFileResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_DownloadScriptFile, context);
    }

    /// \cond INTERNAL
    void _iceI_DownloadScriptFile(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<StageRunMgrIPC::DownloadScriptFileResult>>&, const ::Ice::Context&);
    /// \endcond

    void UIOperation(const ::std::string& message, const ::std::string& datetime, const ::std::string& errorcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_UIOperation, message, datetime, errorcode, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto UIOperationAsync(const ::std::string& message, const ::std::string& datetime, const ::std::string& errorcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_UIOperation, message, datetime, errorcode, context);
    }

    ::std::function<void()>
    UIOperationAsync(const ::std::string& message, const ::std::string& datetime, const ::std::string& errorcode,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_UIOperation, message, datetime, errorcode, context);
    }

    /// \cond INTERNAL
    void _iceI_UIOperation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    AlarmMessageList GetAlarmMessages(int startMessageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::BGI::RPC::AlarmMessageList>(true, this, &StageRunMgrIPCPrx::_iceI_GetAlarmMessages, startMessageId, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetAlarmMessagesAsync(int startMessageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::BGI::RPC::AlarmMessageList>>().get_future())
    {
        return _makePromiseOutgoing<::BGI::RPC::AlarmMessageList, P>(false, this, &StageRunMgrIPCPrx::_iceI_GetAlarmMessages, startMessageId, context);
    }

    ::std::function<void()>
    GetAlarmMessagesAsync(int startMessageId,
                          ::std::function<void(::BGI::RPC::AlarmMessageList)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::BGI::RPC::AlarmMessageList>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_GetAlarmMessages, startMessageId, context);
    }

    /// \cond INTERNAL
    void _iceI_GetAlarmMessages(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::AlarmMessageList>>&, int, const ::Ice::Context&);
    /// \endcond

    LogMessageList GetLogMessages(int startMessageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::BGI::RPC::LogMessageList>(true, this, &StageRunMgrIPCPrx::_iceI_GetLogMessages, startMessageId, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetLogMessagesAsync(int startMessageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::BGI::RPC::LogMessageList>>().get_future())
    {
        return _makePromiseOutgoing<::BGI::RPC::LogMessageList, P>(false, this, &StageRunMgrIPCPrx::_iceI_GetLogMessages, startMessageId, context);
    }

    ::std::function<void()>
    GetLogMessagesAsync(int startMessageId,
                        ::std::function<void(::BGI::RPC::LogMessageList)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::BGI::RPC::LogMessageList>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_GetLogMessages, startMessageId, context);
    }

    /// \cond INTERNAL
    void _iceI_GetLogMessages(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::LogMessageList>>&, int, const ::Ice::Context&);
    /// \endcond

    void ClearAlarmMessages(const ClearAlarmMessageIds& ids, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_ClearAlarmMessages, ids, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ClearAlarmMessagesAsync(const ClearAlarmMessageIds& ids, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_ClearAlarmMessages, ids, context);
    }

    ::std::function<void()>
    ClearAlarmMessagesAsync(const ClearAlarmMessageIds& ids,
                            ::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_ClearAlarmMessages, ids, context);
    }

    /// \cond INTERNAL
    void _iceI_ClearAlarmMessages(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ClearAlarmMessageIds&, const ::Ice::Context&);
    /// \endcond

    void ReagentNeedle(bool UP, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_ReagentNeedle, UP, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ReagentNeedleAsync(bool UP, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_ReagentNeedle, UP, context);
    }

    ::std::function<void()>
    ReagentNeedleAsync(bool UP,
                       ::std::function<void()> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_ReagentNeedle, UP, context);
    }

    /// \cond INTERNAL
    void _iceI_ReagentNeedle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, bool, const ::Ice::Context&);
    /// \endcond

    void SendExperimentType(const ::std::string& experimentType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_SendExperimentType, experimentType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendExperimentTypeAsync(const ::std::string& experimentType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_SendExperimentType, experimentType, context);
    }

    ::std::function<void()>
    SendExperimentTypeAsync(const ::std::string& experimentType,
                            ::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_SendExperimentType, experimentType, context);
    }

    /// \cond INTERNAL
    void _iceI_SendExperimentType(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void SetBuzzerVolume(int frenquency, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_SetBuzzerVolume, frenquency, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetBuzzerVolumeAsync(int frenquency, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_SetBuzzerVolume, frenquency, context);
    }

    ::std::function<void()>
    SetBuzzerVolumeAsync(int frenquency,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_SetBuzzerVolume, frenquency, context);
    }

    /// \cond INTERNAL
    void _iceI_SetBuzzerVolume(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    SequenceTypes GetSequenceTypes(const ::std::string& sampleId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::BGI::RPC::SequenceTypes>(true, this, &StageRunMgrIPCPrx::_iceI_GetSequenceTypes, sampleId, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetSequenceTypesAsync(const ::std::string& sampleId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::BGI::RPC::SequenceTypes>>().get_future())
    {
        return _makePromiseOutgoing<::BGI::RPC::SequenceTypes, P>(false, this, &StageRunMgrIPCPrx::_iceI_GetSequenceTypes, sampleId, context);
    }

    ::std::function<void()>
    GetSequenceTypesAsync(const ::std::string& sampleId,
                          ::std::function<void(::BGI::RPC::SequenceTypes)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::BGI::RPC::SequenceTypes>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_GetSequenceTypes, sampleId, context);
    }

    /// \cond INTERNAL
    void _iceI_GetSequenceTypes(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::SequenceTypes>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool SetClearData(const DataList& datas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &StageRunMgrIPCPrx::_iceI_SetClearData, datas, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetClearDataAsync(const DataList& datas, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &StageRunMgrIPCPrx::_iceI_SetClearData, datas, context);
    }

    ::std::function<void()>
    SetClearDataAsync(const DataList& datas,
                      ::std::function<void(bool)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_SetClearData, datas, context);
    }

    /// \cond INTERNAL
    void _iceI_SetClearData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const DataList&, const ::Ice::Context&);
    /// \endcond

    void StartRunLength(int read1length, int read2length, int bardcodelength, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_StartRunLength, read1length, read2length, bardcodelength, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto StartRunLengthAsync(int read1length, int read2length, int bardcodelength, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_StartRunLength, read1length, read2length, bardcodelength, context);
    }

    ::std::function<void()>
    StartRunLengthAsync(int read1length, int read2length, int bardcodelength,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_StartRunLength, read1length, read2length, bardcodelength, context);
    }

    /// \cond INTERNAL
    void _iceI_StartRunLength(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, int, int, const ::Ice::Context&);
    /// \endcond

    void SetupRunInfo(const RunInfo& runInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_SetupRunInfo, runInfo, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetupRunInfoAsync(const RunInfo& runInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_SetupRunInfo, runInfo, context);
    }

    ::std::function<void()>
    SetupRunInfoAsync(const RunInfo& runInfo,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_SetupRunInfo, runInfo, context);
    }

    /// \cond INTERNAL
    void _iceI_SetupRunInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const RunInfo&, const ::Ice::Context&);
    /// \endcond

    void MotorMove(MotorTypeEnum motor, bool up, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_MotorMove, motor, up, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto MotorMoveAsync(MotorTypeEnum motor, bool up, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_MotorMove, motor, up, context);
    }

    ::std::function<void()>
    MotorMoveAsync(MotorTypeEnum motor, bool up,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_MotorMove, motor, up, context);
    }

    /// \cond INTERNAL
    void _iceI_MotorMove(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, MotorTypeEnum, bool, const ::Ice::Context&);
    /// \endcond

    LoginedInfo Authenicate(const ::std::string& userName, const ::std::string& password, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::BGI::RPC::LoginedInfo>(true, this, &StageRunMgrIPCPrx::_iceI_Authenicate, userName, password, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto AuthenicateAsync(const ::std::string& userName, const ::std::string& password, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::BGI::RPC::LoginedInfo>>().get_future())
    {
        return _makePromiseOutgoing<::BGI::RPC::LoginedInfo, P>(false, this, &StageRunMgrIPCPrx::_iceI_Authenicate, userName, password, context);
    }

    ::std::function<void()>
    AuthenicateAsync(const ::std::string& userName, const ::std::string& password,
                     ::std::function<void(::BGI::RPC::LoginedInfo)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::BGI::RPC::LoginedInfo>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_Authenicate, userName, password, context);
    }

    /// \cond INTERNAL
    void _iceI_Authenicate(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::LoginedInfo>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    ::std::string GetLanguage(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &StageRunMgrIPCPrx::_iceI_GetLanguage, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetLanguageAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &StageRunMgrIPCPrx::_iceI_GetLanguage, context);
    }

    ::std::function<void()>
    GetLanguageAsync(::std::function<void(::std::string)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_GetLanguage, context);
    }

    /// \cond INTERNAL
    void _iceI_GetLanguage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::Ice::Context&);
    /// \endcond

    void SetLanguage(const ::std::string& language, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_SetLanguage, language, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetLanguageAsync(const ::std::string& language, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_SetLanguage, language, context);
    }

    ::std::function<void()>
    SetLanguageAsync(const ::std::string& language,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_SetLanguage, language, context);
    }

    /// \cond INTERNAL
    void _iceI_SetLanguage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void SetBaseCallIpAddr(const ::std::string& ipAddr, int port, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_SetBaseCallIpAddr, ipAddr, port, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetBaseCallIpAddrAsync(const ::std::string& ipAddr, int port, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_SetBaseCallIpAddr, ipAddr, port, context);
    }

    ::std::function<void()>
    SetBaseCallIpAddrAsync(const ::std::string& ipAddr, int port,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_SetBaseCallIpAddr, ipAddr, port, context);
    }

    /// \cond INTERNAL
    void _iceI_SetBaseCallIpAddr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    void SetZLIMSIpAddr(const ::std::string& ipAddr, int port, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_SetZLIMSIpAddr, ipAddr, port, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetZLIMSIpAddrAsync(const ::std::string& ipAddr, int port, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_SetZLIMSIpAddr, ipAddr, port, context);
    }

    ::std::function<void()>
    SetZLIMSIpAddrAsync(const ::std::string& ipAddr, int port,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_SetZLIMSIpAddr, ipAddr, port, context);
    }

    /// \cond INTERNAL
    void _iceI_SetZLIMSIpAddr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, int, const ::Ice::Context&);
    /// \endcond

    IpAddr GetZLIMSAddr(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::BGI::RPC::IpAddr>(true, this, &StageRunMgrIPCPrx::_iceI_GetZLIMSAddr, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetZLIMSAddrAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::BGI::RPC::IpAddr>>().get_future())
    {
        return _makePromiseOutgoing<::BGI::RPC::IpAddr, P>(false, this, &StageRunMgrIPCPrx::_iceI_GetZLIMSAddr, context);
    }

    ::std::function<void()>
    GetZLIMSAddrAsync(::std::function<void(::BGI::RPC::IpAddr)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::BGI::RPC::IpAddr>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_GetZLIMSAddr, context);
    }

    /// \cond INTERNAL
    void _iceI_GetZLIMSAddr(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::IpAddr>>&, const ::Ice::Context&);
    /// \endcond

    void SetCategoryParas(const ::std::string& category, const ParaDict& paraDict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_SetCategoryParas, category, paraDict, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetCategoryParasAsync(const ::std::string& category, const ParaDict& paraDict, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_SetCategoryParas, category, paraDict, context);
    }

    ::std::function<void()>
    SetCategoryParasAsync(const ::std::string& category, const ParaDict& paraDict,
                          ::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_SetCategoryParas, category, paraDict, context);
    }

    /// \cond INTERNAL
    void _iceI_SetCategoryParas(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ParaDict&, const ::Ice::Context&);
    /// \endcond

    ::std::string GetParaValue(const ::std::string& category, const ::std::string& paraName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::std::string>(true, this, &StageRunMgrIPCPrx::_iceI_GetParaValue, category, paraName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetParaValueAsync(const ::std::string& category, const ::std::string& paraName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::std::string>>().get_future())
    {
        return _makePromiseOutgoing<::std::string, P>(false, this, &StageRunMgrIPCPrx::_iceI_GetParaValue, category, paraName, context);
    }

    ::std::function<void()>
    GetParaValueAsync(const ::std::string& category, const ::std::string& paraName,
                      ::std::function<void(::std::string)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::std::string>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_GetParaValue, category, paraName, context);
    }

    /// \cond INTERNAL
    void _iceI_GetParaValue(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::std::string>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void StartSelfCheck(DeviceCheckTypeEnum checkType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCPrx::_iceI_StartSelfCheck, checkType, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto StartSelfCheckAsync(DeviceCheckTypeEnum checkType, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCPrx::_iceI_StartSelfCheck, checkType, context);
    }

    ::std::function<void()>
    StartSelfCheckAsync(DeviceCheckTypeEnum checkType,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCPrx::_iceI_StartSelfCheck, checkType, context);
    }

    /// \cond INTERNAL
    void _iceI_StartSelfCheck(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, DeviceCheckTypeEnum, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    StageRunMgrIPCPrx() = default;
    friend ::std::shared_ptr<StageRunMgrIPCPrx> IceInternal::createProxy<StageRunMgrIPCPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class StageRunMgrIPCCallbackPrx : public virtual ::Ice::Proxy<StageRunMgrIPCCallbackPrx, ::Ice::ObjectPrx>
{
public:

    void AddClient(const ::Ice::Identity& ident, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_AddClient, ident, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto AddClientAsync(const ::Ice::Identity& ident, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_AddClient, ident, context);
    }

    ::std::function<void()>
    AddClientAsync(const ::Ice::Identity& ident,
                   ::std::function<void()> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_AddClient, ident, context);
    }

    /// \cond INTERNAL
    void _iceI_AddClient(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Identity&, const ::Ice::Context&);
    /// \endcond

    void SendScriptName(const ::std::string& scriptName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_SendScriptName, scriptName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendScriptNameAsync(const ::std::string& scriptName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_SendScriptName, scriptName, context);
    }

    ::std::function<void()>
    SendScriptNameAsync(const ::std::string& scriptName,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_SendScriptName, scriptName, context);
    }

    /// \cond INTERNAL
    void _iceI_SendScriptName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void SendActionName(const ::std::string& actionName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_SendActionName, actionName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendActionNameAsync(const ::std::string& actionName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_SendActionName, actionName, context);
    }

    ::std::function<void()>
    SendActionNameAsync(const ::std::string& actionName,
                        ::std::function<void()> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_SendActionName, actionName, context);
    }

    /// \cond INTERNAL
    void _iceI_SendActionName(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void SendFlowcellBarcode(const ::std::string& flowcellBarcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_SendFlowcellBarcode, flowcellBarcode, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendFlowcellBarcodeAsync(const ::std::string& flowcellBarcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_SendFlowcellBarcode, flowcellBarcode, context);
    }

    ::std::function<void()>
    SendFlowcellBarcodeAsync(const ::std::string& flowcellBarcode,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_SendFlowcellBarcode, flowcellBarcode, context);
    }

    /// \cond INTERNAL
    void _iceI_SendFlowcellBarcode(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void SendPositionNumber(int cycleNum, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_SendPositionNumber, cycleNum, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendPositionNumberAsync(int cycleNum, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_SendPositionNumber, cycleNum, context);
    }

    ::std::function<void()>
    SendPositionNumberAsync(int cycleNum,
                            ::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_SendPositionNumber, cycleNum, context);
    }

    /// \cond INTERNAL
    void _iceI_SendPositionNumber(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void SendPcntDone(int pctDone, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_SendPcntDone, pctDone, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendPcntDoneAsync(int pctDone, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_SendPcntDone, pctDone, context);
    }

    ::std::function<void()>
    SendPcntDoneAsync(int pctDone,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_SendPcntDone, pctDone, context);
    }

    /// \cond INTERNAL
    void _iceI_SendPcntDone(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void SendScriptStatus(ScriptStateEnum curState, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_SendScriptStatus, curState, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendScriptStatusAsync(ScriptStateEnum curState, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_SendScriptStatus, curState, context);
    }

    ::std::function<void()>
    SendScriptStatusAsync(ScriptStateEnum curState,
                          ::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_SendScriptStatus, curState, context);
    }

    /// \cond INTERNAL
    void _iceI_SendScriptStatus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ScriptStateEnum, const ::Ice::Context&);
    /// \endcond

    void SendScriptMessageId(int messageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_SendScriptMessageId, messageId, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendScriptMessageIdAsync(int messageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_SendScriptMessageId, messageId, context);
    }

    ::std::function<void()>
    SendScriptMessageIdAsync(int messageId,
                             ::std::function<void()> response,
                             ::std::function<void(::std::exception_ptr)> ex = nullptr,
                             ::std::function<void(bool)> sent = nullptr,
                             const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_SendScriptMessageId, messageId, context);
    }

    /// \cond INTERNAL
    void _iceI_SendScriptMessageId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void SendStageMessage(const ::std::string& msgType, const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_SendStageMessage, msgType, message, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendStageMessageAsync(const ::std::string& msgType, const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_SendStageMessage, msgType, message, context);
    }

    ::std::function<void()>
    SendStageMessageAsync(const ::std::string& msgType, const ::std::string& message,
                          ::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_SendStageMessage, msgType, message, context);
    }

    /// \cond INTERNAL
    void _iceI_SendStageMessage(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    void SendQCValue(const QCDataValue& qcValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_SendQCValue, qcValue, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendQCValueAsync(const QCDataValue& qcValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_SendQCValue, qcValue, context);
    }

    ::std::function<void()>
    SendQCValueAsync(const QCDataValue& qcValue,
                     ::std::function<void()> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_SendQCValue, qcValue, context);
    }

    /// \cond INTERNAL
    void _iceI_SendQCValue(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const QCDataValue&, const ::Ice::Context&);
    /// \endcond

    void SendQCValues(const QCDataValues& qcValues, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_SendQCValues, qcValues, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendQCValuesAsync(const QCDataValues& qcValues, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_SendQCValues, qcValues, context);
    }

    ::std::function<void()>
    SendQCValuesAsync(const QCDataValues& qcValues,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_SendQCValues, qcValues, context);
    }

    /// \cond INTERNAL
    void _iceI_SendQCValues(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const QCDataValues&, const ::Ice::Context&);
    /// \endcond

    void SendAlarmMessageId(int messageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_SendAlarmMessageId, messageId, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendAlarmMessageIdAsync(int messageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_SendAlarmMessageId, messageId, context);
    }

    ::std::function<void()>
    SendAlarmMessageIdAsync(int messageId,
                            ::std::function<void()> response,
                            ::std::function<void(::std::exception_ptr)> ex = nullptr,
                            ::std::function<void(bool)> sent = nullptr,
                            const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_SendAlarmMessageId, messageId, context);
    }

    /// \cond INTERNAL
    void _iceI_SendAlarmMessageId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void SendLogMessageId(int messageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_SendLogMessageId, messageId, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendLogMessageIdAsync(int messageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_SendLogMessageId, messageId, context);
    }

    ::std::function<void()>
    SendLogMessageIdAsync(int messageId,
                          ::std::function<void()> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_SendLogMessageId, messageId, context);
    }

    /// \cond INTERNAL
    void _iceI_SendLogMessageId(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, int, const ::Ice::Context&);
    /// \endcond

    void SendRemainingTime(double remainingTimeMinute, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_SendRemainingTime, remainingTimeMinute, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendRemainingTimeAsync(double remainingTimeMinute, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_SendRemainingTime, remainingTimeMinute, context);
    }

    ::std::function<void()>
    SendRemainingTimeAsync(double remainingTimeMinute,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_SendRemainingTime, remainingTimeMinute, context);
    }

    /// \cond INTERNAL
    void _iceI_SendRemainingTime(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, double, const ::Ice::Context&);
    /// \endcond

    void SendDataList(const DataList& datas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &StageRunMgrIPCCallbackPrx::_iceI_SendDataList, datas, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendDataListAsync(const DataList& datas, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &StageRunMgrIPCCallbackPrx::_iceI_SendDataList, datas, context);
    }

    ::std::function<void()>
    SendDataListAsync(const DataList& datas,
                      ::std::function<void()> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::StageRunMgrIPCCallbackPrx::_iceI_SendDataList, datas, context);
    }

    /// \cond INTERNAL
    void _iceI_SendDataList(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const DataList&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    StageRunMgrIPCCallbackPrx() = default;
    friend ::std::shared_ptr<StageRunMgrIPCCallbackPrx> IceInternal::createProxy<StageRunMgrIPCCallbackPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::BGI::RPC::ScriptStateEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 7;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::ScriptMessageSeverityEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 4;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::MotorTypeEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::BGI::RPC::ScriptRunInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::BGI::RPC::ScriptRunInfo, S>
{
    static void read(S* istr, ::BGI::RPC::ScriptRunInfo& v)
    {
        istr->readAll(v.ScriptRunId, v.ScriptFilename, v.ParentScriptRunId, v.StartDate, v.EndDate, v.StatusStr, v.IsSuccess);
    }
};

template<>
struct StreamableTraits< ::BGI::RPC::DeviceCheckTypeEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 4;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::BGI::RPC::ServiceMessageInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::BGI::RPC::ServiceMessageInfo, S>
{
    static void read(S* istr, ::BGI::RPC::ServiceMessageInfo& v)
    {
        istr->readAll(v.MessageId, v.InstructmentId, v.FlowCellId, v.UserName, v.SoftwareVersion, v.MessageType, v.Errorcode, v.Message, v.Datetime, v.IsPublic);
    }
};

template<>
struct StreamableTraits<::BGI::RPC::IpAddr>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::BGI::RPC::IpAddr, S>
{
    static void read(S* istr, ::BGI::RPC::IpAddr& v)
    {
        istr->readAll(v.IP, v.Port);
    }
};

template<>
struct StreamableTraits<::BGI::RPC::ScriptMessageInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::BGI::RPC::ScriptMessageInfo, S>
{
    static void read(S* istr, ::BGI::RPC::ScriptMessageInfo& v)
    {
        istr->readAll(v.MessageId, v.MessageSeverity, v.MessageDateTime, v.MessageStr);
    }
};

template<>
struct StreamableTraits<::BGI::RPC::QCDataValue>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::BGI::RPC::QCDataValue, S>
{
    static void read(S* istr, ::BGI::RPC::QCDataValue& v)
    {
        istr->readAll(v.QCMetricName, v.cycleNum, v.QCValue);
    }
};

template<>
struct StreamableTraits<::BGI::RPC::LoginedInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::BGI::RPC::LoginedInfo, S>
{
    static void read(S* istr, ::BGI::RPC::LoginedInfo& v)
    {
        istr->readAll(v.IsSuccess, v.UserRole);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace BGI
{

/// \cond INTERNAL
namespace RPC
{

using StageRunMgrIPCPtr = ::std::shared_ptr<StageRunMgrIPC>;
using StageRunMgrIPCPrxPtr = ::std::shared_ptr<StageRunMgrIPCPrx>;

using StageRunMgrIPCCallbackPtr = ::std::shared_ptr<StageRunMgrIPCCallback>;
using StageRunMgrIPCCallbackPrxPtr = ::std::shared_ptr<StageRunMgrIPCCallbackPrx>;

}
/// \endcond

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace BGI
{

namespace RPC
{

class StageRunMgrIPC;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< StageRunMgrIPC>&);
::IceProxy::Ice::Object* upCast(StageRunMgrIPC*);
/// \endcond

class StageRunMgrIPCCallback;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< StageRunMgrIPCCallback>&);
::IceProxy::Ice::Object* upCast(StageRunMgrIPCCallback*);
/// \endcond

}

}

}

namespace BGI
{

namespace RPC
{

class StageRunMgrIPC;
/// \cond INTERNAL
::Ice::Object* upCast(StageRunMgrIPC*);
/// \endcond
typedef ::IceInternal::Handle< StageRunMgrIPC> StageRunMgrIPCPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::BGI::RPC::StageRunMgrIPC> StageRunMgrIPCPrx;
typedef StageRunMgrIPCPrx StageRunMgrIPCPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(StageRunMgrIPCPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class StageRunMgrIPCCallback;
/// \cond INTERNAL
::Ice::Object* upCast(StageRunMgrIPCCallback*);
/// \endcond
typedef ::IceInternal::Handle< StageRunMgrIPCCallback> StageRunMgrIPCCallbackPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::BGI::RPC::StageRunMgrIPCCallback> StageRunMgrIPCCallbackPrx;
typedef StageRunMgrIPCCallbackPrx StageRunMgrIPCCallbackPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(StageRunMgrIPCCallbackPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

}

namespace BGI
{

namespace RPC
{

enum ScriptStateEnum
{
    Idle,
    SetupRun,
    ReadyToRun,
    ScriptRunning,
    ScriptPausing,
    ScriptPaused,
    ScriptStopping,
    Unknown
};

enum ScriptMessageSeverityEnum
{
    Header,
    Verbose,
    Info,
    Warning,
    Error
};

enum MotorTypeEnum
{
    SequenceNeedle,
    WashNeedle,
    FlowcellLoader
};

struct ScriptRunInfo
{
    ::Ice::Int ScriptRunId;
    ::std::string ScriptFilename;
    ::Ice::Int ParentScriptRunId;
    ::std::string StartDate;
    ::std::string EndDate;
    ::std::string StatusStr;
    bool IsSuccess;

    bool operator==(const ScriptRunInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(ScriptRunId != rhs_.ScriptRunId)
        {
            return false;
        }
        if(ScriptFilename != rhs_.ScriptFilename)
        {
            return false;
        }
        if(ParentScriptRunId != rhs_.ParentScriptRunId)
        {
            return false;
        }
        if(StartDate != rhs_.StartDate)
        {
            return false;
        }
        if(EndDate != rhs_.EndDate)
        {
            return false;
        }
        if(StatusStr != rhs_.StatusStr)
        {
            return false;
        }
        if(IsSuccess != rhs_.IsSuccess)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ScriptRunInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(ScriptRunId < rhs_.ScriptRunId)
        {
            return true;
        }
        else if(rhs_.ScriptRunId < ScriptRunId)
        {
            return false;
        }
        if(ScriptFilename < rhs_.ScriptFilename)
        {
            return true;
        }
        else if(rhs_.ScriptFilename < ScriptFilename)
        {
            return false;
        }
        if(ParentScriptRunId < rhs_.ParentScriptRunId)
        {
            return true;
        }
        else if(rhs_.ParentScriptRunId < ParentScriptRunId)
        {
            return false;
        }
        if(StartDate < rhs_.StartDate)
        {
            return true;
        }
        else if(rhs_.StartDate < StartDate)
        {
            return false;
        }
        if(EndDate < rhs_.EndDate)
        {
            return true;
        }
        else if(rhs_.EndDate < EndDate)
        {
            return false;
        }
        if(StatusStr < rhs_.StatusStr)
        {
            return true;
        }
        else if(rhs_.StatusStr < StatusStr)
        {
            return false;
        }
        if(IsSuccess < rhs_.IsSuccess)
        {
            return true;
        }
        else if(rhs_.IsSuccess < IsSuccess)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ScriptRunInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ScriptRunInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ScriptRunInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ScriptRunInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<ScriptRunInfo> ScriptRunInfoList;

enum DeviceCheckTypeEnum
{
    InitCheck,
    BeforeRunningCheck,
    RunningCheck,
    IdleCheck,
    OtherCheck
};

struct ServiceMessageInfo
{
    ::Ice::Int MessageId;
    ::std::string InstructmentId;
    ::std::string FlowCellId;
    ::std::string UserName;
    ::std::string SoftwareVersion;
    ::BGI::RPC::ScriptMessageSeverityEnum MessageType;
    ::std::string Errorcode;
    ::std::string Message;
    ::std::string Datetime;
    bool IsPublic;

    bool operator==(const ServiceMessageInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(MessageId != rhs_.MessageId)
        {
            return false;
        }
        if(InstructmentId != rhs_.InstructmentId)
        {
            return false;
        }
        if(FlowCellId != rhs_.FlowCellId)
        {
            return false;
        }
        if(UserName != rhs_.UserName)
        {
            return false;
        }
        if(SoftwareVersion != rhs_.SoftwareVersion)
        {
            return false;
        }
        if(MessageType != rhs_.MessageType)
        {
            return false;
        }
        if(Errorcode != rhs_.Errorcode)
        {
            return false;
        }
        if(Message != rhs_.Message)
        {
            return false;
        }
        if(Datetime != rhs_.Datetime)
        {
            return false;
        }
        if(IsPublic != rhs_.IsPublic)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ServiceMessageInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(MessageId < rhs_.MessageId)
        {
            return true;
        }
        else if(rhs_.MessageId < MessageId)
        {
            return false;
        }
        if(InstructmentId < rhs_.InstructmentId)
        {
            return true;
        }
        else if(rhs_.InstructmentId < InstructmentId)
        {
            return false;
        }
        if(FlowCellId < rhs_.FlowCellId)
        {
            return true;
        }
        else if(rhs_.FlowCellId < FlowCellId)
        {
            return false;
        }
        if(UserName < rhs_.UserName)
        {
            return true;
        }
        else if(rhs_.UserName < UserName)
        {
            return false;
        }
        if(SoftwareVersion < rhs_.SoftwareVersion)
        {
            return true;
        }
        else if(rhs_.SoftwareVersion < SoftwareVersion)
        {
            return false;
        }
        if(MessageType < rhs_.MessageType)
        {
            return true;
        }
        else if(rhs_.MessageType < MessageType)
        {
            return false;
        }
        if(Errorcode < rhs_.Errorcode)
        {
            return true;
        }
        else if(rhs_.Errorcode < Errorcode)
        {
            return false;
        }
        if(Message < rhs_.Message)
        {
            return true;
        }
        else if(rhs_.Message < Message)
        {
            return false;
        }
        if(Datetime < rhs_.Datetime)
        {
            return true;
        }
        else if(rhs_.Datetime < Datetime)
        {
            return false;
        }
        if(IsPublic < rhs_.IsPublic)
        {
            return true;
        }
        else if(rhs_.IsPublic < IsPublic)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ServiceMessageInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ServiceMessageInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ServiceMessageInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ServiceMessageInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct IpAddr
{
    ::std::string IP;
    ::Ice::Int Port;

    bool operator==(const IpAddr& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(IP != rhs_.IP)
        {
            return false;
        }
        if(Port != rhs_.Port)
        {
            return false;
        }
        return true;
    }

    bool operator<(const IpAddr& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(IP < rhs_.IP)
        {
            return true;
        }
        else if(rhs_.IP < IP)
        {
            return false;
        }
        if(Port < rhs_.Port)
        {
            return true;
        }
        else if(rhs_.Port < Port)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const IpAddr& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const IpAddr& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const IpAddr& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const IpAddr& rhs_) const
    {
        return !operator<(rhs_);
    }
};

struct ScriptMessageInfo
{
    ::Ice::Int MessageId;
    ::BGI::RPC::ScriptMessageSeverityEnum MessageSeverity;
    ::std::string MessageDateTime;
    ::std::string MessageStr;

    bool operator==(const ScriptMessageInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(MessageId != rhs_.MessageId)
        {
            return false;
        }
        if(MessageSeverity != rhs_.MessageSeverity)
        {
            return false;
        }
        if(MessageDateTime != rhs_.MessageDateTime)
        {
            return false;
        }
        if(MessageStr != rhs_.MessageStr)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ScriptMessageInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(MessageId < rhs_.MessageId)
        {
            return true;
        }
        else if(rhs_.MessageId < MessageId)
        {
            return false;
        }
        if(MessageSeverity < rhs_.MessageSeverity)
        {
            return true;
        }
        else if(rhs_.MessageSeverity < MessageSeverity)
        {
            return false;
        }
        if(MessageDateTime < rhs_.MessageDateTime)
        {
            return true;
        }
        else if(rhs_.MessageDateTime < MessageDateTime)
        {
            return false;
        }
        if(MessageStr < rhs_.MessageStr)
        {
            return true;
        }
        else if(rhs_.MessageStr < MessageStr)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ScriptMessageInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ScriptMessageInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ScriptMessageInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ScriptMessageInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<ScriptMessageInfo> MessageArray;

typedef ::std::vector<ServiceMessageInfo> AlarmMessageList;

typedef ::std::vector<ServiceMessageInfo> LogMessageList;

typedef ::std::vector< ::Ice::Int> ClearAlarmMessageIds;

typedef ::std::vector< ::std::string> SequenceTypes;

typedef ::std::vector< ::std::string> DataList;

struct QCDataValue
{
    ::std::string QCMetricName;
    ::Ice::Int cycleNum;
    ::Ice::Float QCValue;
};

typedef ::std::vector<QCDataValue> QCDataValues;

struct LoginedInfo
{
    bool IsSuccess;
    ::std::string UserRole;

    bool operator==(const LoginedInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(IsSuccess != rhs_.IsSuccess)
        {
            return false;
        }
        if(UserRole != rhs_.UserRole)
        {
            return false;
        }
        return true;
    }

    bool operator<(const LoginedInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(IsSuccess < rhs_.IsSuccess)
        {
            return true;
        }
        else if(rhs_.IsSuccess < IsSuccess)
        {
            return false;
        }
        if(UserRole < rhs_.UserRole)
        {
            return true;
        }
        else if(rhs_.UserRole < UserRole)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const LoginedInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const LoginedInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const LoginedInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const LoginedInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::map< ::std::string, ::std::string> ExperimentInfo;

typedef ::std::map< ::std::string, ::std::string> RunInfo;

typedef ::std::map< ::std::string, ::std::string> ParaDict;

}

}

namespace BGI
{

namespace RPC
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetHeartbeat.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetHeartbeat.
 */
class Callback_StageRunMgrIPC_GetHeartbeat_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_GetHeartbeat_Base> Callback_StageRunMgrIPC_GetHeartbeatPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSetup.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StartSetup.
 */
class Callback_StageRunMgrIPC_StartSetup_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_StartSetup_Base> Callback_StageRunMgrIPC_StartSetupPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SaveSelectedScriptFileName.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SaveSelectedScriptFileName.
 */
class Callback_StageRunMgrIPC_SaveSelectedScriptFileName_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_SaveSelectedScriptFileName_Base> Callback_StageRunMgrIPC_SaveSelectedScriptFileNamePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanFlowcellBarcode.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ScanFlowcellBarcode.
 */
class Callback_StageRunMgrIPC_ScanFlowcellBarcode_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_ScanFlowcellBarcode_Base> Callback_StageRunMgrIPC_ScanFlowcellBarcodePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanReagentKitBarcode.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ScanReagentKitBarcode.
 */
class Callback_StageRunMgrIPC_ScanReagentKitBarcode_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_ScanReagentKitBarcode_Base> Callback_StageRunMgrIPC_ScanReagentKitBarcodePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_OverrideFlowcellBarcode.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_OverrideFlowcellBarcode.
 */
class Callback_StageRunMgrIPC_OverrideFlowcellBarcode_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_OverrideFlowcellBarcode_Base> Callback_StageRunMgrIPC_OverrideFlowcellBarcodePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendReagentKit.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SendReagentKit.
 */
class Callback_StageRunMgrIPC_SendReagentKit_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_SendReagentKit_Base> Callback_StageRunMgrIPC_SendReagentKitPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRun.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StartRun.
 */
class Callback_StageRunMgrIPC_StartRun_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_StartRun_Base> Callback_StageRunMgrIPC_StartRunPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_PauseScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_PauseScript.
 */
class Callback_StageRunMgrIPC_PauseScript_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_PauseScript_Base> Callback_StageRunMgrIPC_PauseScriptPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ResumeScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ResumeScript.
 */
class Callback_StageRunMgrIPC_ResumeScript_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_ResumeScript_Base> Callback_StageRunMgrIPC_ResumeScriptPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StopScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StopScript.
 */
class Callback_StageRunMgrIPC_StopScript_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_StopScript_Base> Callback_StageRunMgrIPC_StopScriptPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_AbortScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_AbortScript.
 */
class Callback_StageRunMgrIPC_AbortScript_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_AbortScript_Base> Callback_StageRunMgrIPC_AbortScriptPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_RunScriptNow.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_RunScriptNow.
 */
class Callback_StageRunMgrIPC_RunScriptNow_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_RunScriptNow_Base> Callback_StageRunMgrIPC_RunScriptNowPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetScriptRunInfo.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetScriptRunInfo.
 */
class Callback_StageRunMgrIPC_GetScriptRunInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_GetScriptRunInfo_Base> Callback_StageRunMgrIPC_GetScriptRunInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetScriptMessages.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetScriptMessages.
 */
class Callback_StageRunMgrIPC_GetScriptMessages_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_GetScriptMessages_Base> Callback_StageRunMgrIPC_GetScriptMessagesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupScriptFile.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetupScriptFile.
 */
class Callback_StageRunMgrIPC_SetupScriptFile_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_SetupScriptFile_Base> Callback_StageRunMgrIPC_SetupScriptFilePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetQCValues.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetQCValues.
 */
class Callback_StageRunMgrIPC_GetQCValues_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_GetQCValues_Base> Callback_StageRunMgrIPC_GetQCValuesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendSampleId.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SendSampleId.
 */
class Callback_StageRunMgrIPC_SendSampleId_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_SendSampleId_Base> Callback_StageRunMgrIPC_SendSampleIdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetExperimentInfo.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetExperimentInfo.
 */
class Callback_StageRunMgrIPC_GetExperimentInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_GetExperimentInfo_Base> Callback_StageRunMgrIPC_GetExperimentInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_DownloadScriptFile.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_DownloadScriptFile.
 */
class Callback_StageRunMgrIPC_DownloadScriptFile_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_DownloadScriptFile_Base> Callback_StageRunMgrIPC_DownloadScriptFilePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_UIOperation.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_UIOperation.
 */
class Callback_StageRunMgrIPC_UIOperation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_UIOperation_Base> Callback_StageRunMgrIPC_UIOperationPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetAlarmMessages.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetAlarmMessages.
 */
class Callback_StageRunMgrIPC_GetAlarmMessages_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_GetAlarmMessages_Base> Callback_StageRunMgrIPC_GetAlarmMessagesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetLogMessages.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetLogMessages.
 */
class Callback_StageRunMgrIPC_GetLogMessages_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_GetLogMessages_Base> Callback_StageRunMgrIPC_GetLogMessagesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ClearAlarmMessages.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ClearAlarmMessages.
 */
class Callback_StageRunMgrIPC_ClearAlarmMessages_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_ClearAlarmMessages_Base> Callback_StageRunMgrIPC_ClearAlarmMessagesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ReagentNeedle.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ReagentNeedle.
 */
class Callback_StageRunMgrIPC_ReagentNeedle_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_ReagentNeedle_Base> Callback_StageRunMgrIPC_ReagentNeedlePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendExperimentType.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SendExperimentType.
 */
class Callback_StageRunMgrIPC_SendExperimentType_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_SendExperimentType_Base> Callback_StageRunMgrIPC_SendExperimentTypePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBuzzerVolume.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetBuzzerVolume.
 */
class Callback_StageRunMgrIPC_SetBuzzerVolume_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_SetBuzzerVolume_Base> Callback_StageRunMgrIPC_SetBuzzerVolumePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetSequenceTypes.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetSequenceTypes.
 */
class Callback_StageRunMgrIPC_GetSequenceTypes_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_GetSequenceTypes_Base> Callback_StageRunMgrIPC_GetSequenceTypesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetClearData.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetClearData.
 */
class Callback_StageRunMgrIPC_SetClearData_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_SetClearData_Base> Callback_StageRunMgrIPC_SetClearDataPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRunLength.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StartRunLength.
 */
class Callback_StageRunMgrIPC_StartRunLength_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_StartRunLength_Base> Callback_StageRunMgrIPC_StartRunLengthPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupRunInfo.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetupRunInfo.
 */
class Callback_StageRunMgrIPC_SetupRunInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_SetupRunInfo_Base> Callback_StageRunMgrIPC_SetupRunInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_MotorMove.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_MotorMove.
 */
class Callback_StageRunMgrIPC_MotorMove_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_MotorMove_Base> Callback_StageRunMgrIPC_MotorMovePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_Authenicate.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_Authenicate.
 */
class Callback_StageRunMgrIPC_Authenicate_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_Authenicate_Base> Callback_StageRunMgrIPC_AuthenicatePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetLanguage.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetLanguage.
 */
class Callback_StageRunMgrIPC_GetLanguage_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_GetLanguage_Base> Callback_StageRunMgrIPC_GetLanguagePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetLanguage.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetLanguage.
 */
class Callback_StageRunMgrIPC_SetLanguage_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_SetLanguage_Base> Callback_StageRunMgrIPC_SetLanguagePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBaseCallIpAddr.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetBaseCallIpAddr.
 */
class Callback_StageRunMgrIPC_SetBaseCallIpAddr_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_SetBaseCallIpAddr_Base> Callback_StageRunMgrIPC_SetBaseCallIpAddrPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetZLIMSIpAddr.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetZLIMSIpAddr.
 */
class Callback_StageRunMgrIPC_SetZLIMSIpAddr_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_SetZLIMSIpAddr_Base> Callback_StageRunMgrIPC_SetZLIMSIpAddrPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetZLIMSAddr.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetZLIMSAddr.
 */
class Callback_StageRunMgrIPC_GetZLIMSAddr_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_GetZLIMSAddr_Base> Callback_StageRunMgrIPC_GetZLIMSAddrPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetCategoryParas.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetCategoryParas.
 */
class Callback_StageRunMgrIPC_SetCategoryParas_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_SetCategoryParas_Base> Callback_StageRunMgrIPC_SetCategoryParasPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetParaValue.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetParaValue.
 */
class Callback_StageRunMgrIPC_GetParaValue_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_GetParaValue_Base> Callback_StageRunMgrIPC_GetParaValuePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSelfCheck.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StartSelfCheck.
 */
class Callback_StageRunMgrIPC_StartSelfCheck_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPC_StartSelfCheck_Base> Callback_StageRunMgrIPC_StartSelfCheckPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_AddClient.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_AddClient.
 */
class Callback_StageRunMgrIPCCallback_AddClient_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_AddClient_Base> Callback_StageRunMgrIPCCallback_AddClientPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptName.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendScriptName.
 */
class Callback_StageRunMgrIPCCallback_SendScriptName_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_SendScriptName_Base> Callback_StageRunMgrIPCCallback_SendScriptNamePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendActionName.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendActionName.
 */
class Callback_StageRunMgrIPCCallback_SendActionName_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_SendActionName_Base> Callback_StageRunMgrIPCCallback_SendActionNamePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendFlowcellBarcode.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendFlowcellBarcode.
 */
class Callback_StageRunMgrIPCCallback_SendFlowcellBarcode_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_SendFlowcellBarcode_Base> Callback_StageRunMgrIPCCallback_SendFlowcellBarcodePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPositionNumber.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendPositionNumber.
 */
class Callback_StageRunMgrIPCCallback_SendPositionNumber_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_SendPositionNumber_Base> Callback_StageRunMgrIPCCallback_SendPositionNumberPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPcntDone.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendPcntDone.
 */
class Callback_StageRunMgrIPCCallback_SendPcntDone_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_SendPcntDone_Base> Callback_StageRunMgrIPCCallback_SendPcntDonePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptStatus.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendScriptStatus.
 */
class Callback_StageRunMgrIPCCallback_SendScriptStatus_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_SendScriptStatus_Base> Callback_StageRunMgrIPCCallback_SendScriptStatusPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptMessageId.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendScriptMessageId.
 */
class Callback_StageRunMgrIPCCallback_SendScriptMessageId_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_SendScriptMessageId_Base> Callback_StageRunMgrIPCCallback_SendScriptMessageIdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendStageMessage.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendStageMessage.
 */
class Callback_StageRunMgrIPCCallback_SendStageMessage_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_SendStageMessage_Base> Callback_StageRunMgrIPCCallback_SendStageMessagePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValue.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendQCValue.
 */
class Callback_StageRunMgrIPCCallback_SendQCValue_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_SendQCValue_Base> Callback_StageRunMgrIPCCallback_SendQCValuePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValues.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendQCValues.
 */
class Callback_StageRunMgrIPCCallback_SendQCValues_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_SendQCValues_Base> Callback_StageRunMgrIPCCallback_SendQCValuesPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendAlarmMessageId.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendAlarmMessageId.
 */
class Callback_StageRunMgrIPCCallback_SendAlarmMessageId_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_SendAlarmMessageId_Base> Callback_StageRunMgrIPCCallback_SendAlarmMessageIdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendLogMessageId.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendLogMessageId.
 */
class Callback_StageRunMgrIPCCallback_SendLogMessageId_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_SendLogMessageId_Base> Callback_StageRunMgrIPCCallback_SendLogMessageIdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendRemainingTime.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendRemainingTime.
 */
class Callback_StageRunMgrIPCCallback_SendRemainingTime_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_SendRemainingTime_Base> Callback_StageRunMgrIPCCallback_SendRemainingTimePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendDataList.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendDataList.
 */
class Callback_StageRunMgrIPCCallback_SendDataList_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_StageRunMgrIPCCallback_SendDataList_Base> Callback_StageRunMgrIPCCallback_SendDataListPtr;

}

}

namespace IceProxy
{

namespace BGI
{

namespace RPC
{

class StageRunMgrIPC : public virtual ::Ice::Proxy<StageRunMgrIPC, ::IceProxy::Ice::Object>
{
public:

    ::Ice::Int GetHeartbeat(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetHeartbeat(_iceI_begin_GetHeartbeat(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetHeartbeat(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetHeartbeat(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetHeartbeat(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetHeartbeat(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetHeartbeat(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetHeartbeat(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetHeartbeat(const ::BGI::RPC::Callback_StageRunMgrIPC_GetHeartbeatPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetHeartbeat(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetHeartbeat(const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_GetHeartbeatPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetHeartbeat(context, cb, cookie);
    }

    ::Ice::Int end_GetHeartbeat(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetHeartbeat(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void StartSetup(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_StartSetup(_iceI_begin_StartSetup(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_StartSetup(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_StartSetup(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StartSetup(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartSetup(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartSetup(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartSetup(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartSetup(const ::BGI::RPC::Callback_StageRunMgrIPC_StartSetupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartSetup(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartSetup(const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_StartSetupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartSetup(context, cb, cookie);
    }

    void end_StartSetup(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_StartSetup(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SaveSelectedScriptFileName(const ::std::string& strFileName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SaveSelectedScriptFileName(_iceI_begin_SaveSelectedScriptFileName(strFileName, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SaveSelectedScriptFileName(const ::std::string& strFileName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SaveSelectedScriptFileName(strFileName, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SaveSelectedScriptFileName(const ::std::string& strFileName, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SaveSelectedScriptFileName(strFileName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SaveSelectedScriptFileName(const ::std::string& strFileName, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SaveSelectedScriptFileName(strFileName, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SaveSelectedScriptFileName(const ::std::string& strFileName, const ::BGI::RPC::Callback_StageRunMgrIPC_SaveSelectedScriptFileNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SaveSelectedScriptFileName(strFileName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SaveSelectedScriptFileName(const ::std::string& strFileName, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_SaveSelectedScriptFileNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SaveSelectedScriptFileName(strFileName, context, cb, cookie);
    }

    void end_SaveSelectedScriptFileName(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SaveSelectedScriptFileName(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void ScanFlowcellBarcode(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_ScanFlowcellBarcode(_iceI_begin_ScanFlowcellBarcode(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ScanFlowcellBarcode(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ScanFlowcellBarcode(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ScanFlowcellBarcode(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ScanFlowcellBarcode(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ScanFlowcellBarcode(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ScanFlowcellBarcode(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ScanFlowcellBarcode(const ::BGI::RPC::Callback_StageRunMgrIPC_ScanFlowcellBarcodePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ScanFlowcellBarcode(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ScanFlowcellBarcode(const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_ScanFlowcellBarcodePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ScanFlowcellBarcode(context, cb, cookie);
    }

    void end_ScanFlowcellBarcode(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ScanFlowcellBarcode(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void ScanReagentKitBarcode(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_ScanReagentKitBarcode(_iceI_begin_ScanReagentKitBarcode(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ScanReagentKitBarcode(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ScanReagentKitBarcode(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ScanReagentKitBarcode(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ScanReagentKitBarcode(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ScanReagentKitBarcode(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ScanReagentKitBarcode(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ScanReagentKitBarcode(const ::BGI::RPC::Callback_StageRunMgrIPC_ScanReagentKitBarcodePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ScanReagentKitBarcode(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ScanReagentKitBarcode(const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_ScanReagentKitBarcodePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ScanReagentKitBarcode(context, cb, cookie);
    }

    void end_ScanReagentKitBarcode(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ScanReagentKitBarcode(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void OverrideFlowcellBarcode(const ::std::string& barcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_OverrideFlowcellBarcode(_iceI_begin_OverrideFlowcellBarcode(barcode, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_OverrideFlowcellBarcode(const ::std::string& barcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_OverrideFlowcellBarcode(barcode, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_OverrideFlowcellBarcode(const ::std::string& barcode, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OverrideFlowcellBarcode(barcode, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OverrideFlowcellBarcode(const ::std::string& barcode, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OverrideFlowcellBarcode(barcode, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OverrideFlowcellBarcode(const ::std::string& barcode, const ::BGI::RPC::Callback_StageRunMgrIPC_OverrideFlowcellBarcodePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OverrideFlowcellBarcode(barcode, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_OverrideFlowcellBarcode(const ::std::string& barcode, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_OverrideFlowcellBarcodePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_OverrideFlowcellBarcode(barcode, context, cb, cookie);
    }

    void end_OverrideFlowcellBarcode(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_OverrideFlowcellBarcode(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendReagentKit(const ::std::string& reagentKit, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendReagentKit(_iceI_begin_SendReagentKit(reagentKit, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendReagentKit(const ::std::string& reagentKit, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendReagentKit(reagentKit, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendReagentKit(const ::std::string& reagentKit, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendReagentKit(reagentKit, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendReagentKit(const ::std::string& reagentKit, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendReagentKit(reagentKit, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendReagentKit(const ::std::string& reagentKit, const ::BGI::RPC::Callback_StageRunMgrIPC_SendReagentKitPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendReagentKit(reagentKit, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendReagentKit(const ::std::string& reagentKit, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_SendReagentKitPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendReagentKit(reagentKit, context, cb, cookie);
    }

    void end_SendReagentKit(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendReagentKit(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void StartRun(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_StartRun(_iceI_begin_StartRun(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_StartRun(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_StartRun(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StartRun(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartRun(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartRun(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartRun(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartRun(const ::BGI::RPC::Callback_StageRunMgrIPC_StartRunPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartRun(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartRun(const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_StartRunPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartRun(context, cb, cookie);
    }

    void end_StartRun(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_StartRun(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void PauseScript(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_PauseScript(_iceI_begin_PauseScript(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_PauseScript(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_PauseScript(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PauseScript(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PauseScript(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PauseScript(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PauseScript(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PauseScript(const ::BGI::RPC::Callback_StageRunMgrIPC_PauseScriptPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PauseScript(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PauseScript(const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_PauseScriptPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PauseScript(context, cb, cookie);
    }

    void end_PauseScript(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_PauseScript(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void ResumeScript(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_ResumeScript(_iceI_begin_ResumeScript(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ResumeScript(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ResumeScript(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ResumeScript(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ResumeScript(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ResumeScript(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ResumeScript(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ResumeScript(const ::BGI::RPC::Callback_StageRunMgrIPC_ResumeScriptPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ResumeScript(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ResumeScript(const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_ResumeScriptPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ResumeScript(context, cb, cookie);
    }

    void end_ResumeScript(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ResumeScript(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void StopScript(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_StopScript(_iceI_begin_StopScript(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_StopScript(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_StopScript(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StopScript(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StopScript(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StopScript(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StopScript(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StopScript(const ::BGI::RPC::Callback_StageRunMgrIPC_StopScriptPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StopScript(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StopScript(const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_StopScriptPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StopScript(context, cb, cookie);
    }

    void end_StopScript(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_StopScript(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void AbortScript(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_AbortScript(_iceI_begin_AbortScript(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_AbortScript(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_AbortScript(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_AbortScript(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AbortScript(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_AbortScript(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AbortScript(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_AbortScript(const ::BGI::RPC::Callback_StageRunMgrIPC_AbortScriptPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AbortScript(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_AbortScript(const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_AbortScriptPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AbortScript(context, cb, cookie);
    }

    void end_AbortScript(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_AbortScript(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int RunScriptNow(const ::std::string& strFileName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_RunScriptNow(_iceI_begin_RunScriptNow(strFileName, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_RunScriptNow(const ::std::string& strFileName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_RunScriptNow(strFileName, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_RunScriptNow(const ::std::string& strFileName, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RunScriptNow(strFileName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RunScriptNow(const ::std::string& strFileName, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RunScriptNow(strFileName, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RunScriptNow(const ::std::string& strFileName, const ::BGI::RPC::Callback_StageRunMgrIPC_RunScriptNowPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RunScriptNow(strFileName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_RunScriptNow(const ::std::string& strFileName, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_RunScriptNowPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_RunScriptNow(strFileName, context, cb, cookie);
    }

    ::Ice::Int end_RunScriptNow(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_RunScriptNow(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::BGI::RPC::ScriptRunInfo GetScriptRunInfo(::Ice::Int scriptRunId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetScriptRunInfo(_iceI_begin_GetScriptRunInfo(scriptRunId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetScriptRunInfo(::Ice::Int scriptRunId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetScriptRunInfo(scriptRunId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetScriptRunInfo(::Ice::Int scriptRunId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetScriptRunInfo(scriptRunId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetScriptRunInfo(::Ice::Int scriptRunId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetScriptRunInfo(scriptRunId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetScriptRunInfo(::Ice::Int scriptRunId, const ::BGI::RPC::Callback_StageRunMgrIPC_GetScriptRunInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetScriptRunInfo(scriptRunId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetScriptRunInfo(::Ice::Int scriptRunId, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_GetScriptRunInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetScriptRunInfo(scriptRunId, context, cb, cookie);
    }

    ::BGI::RPC::ScriptRunInfo end_GetScriptRunInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetScriptRunInfo(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::BGI::RPC::MessageArray GetScriptMessages(::Ice::Int startMessageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetScriptMessages(_iceI_begin_GetScriptMessages(startMessageId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetScriptMessages(::Ice::Int startMessageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetScriptMessages(startMessageId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetScriptMessages(::Ice::Int startMessageId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetScriptMessages(startMessageId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetScriptMessages(::Ice::Int startMessageId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetScriptMessages(startMessageId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetScriptMessages(::Ice::Int startMessageId, const ::BGI::RPC::Callback_StageRunMgrIPC_GetScriptMessagesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetScriptMessages(startMessageId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetScriptMessages(::Ice::Int startMessageId, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_GetScriptMessagesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetScriptMessages(startMessageId, context, cb, cookie);
    }

    ::BGI::RPC::MessageArray end_GetScriptMessages(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetScriptMessages(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SetupScriptFile(const ::std::string& msgType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SetupScriptFile(_iceI_begin_SetupScriptFile(msgType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetupScriptFile(const ::std::string& msgType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetupScriptFile(msgType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetupScriptFile(const ::std::string& msgType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetupScriptFile(msgType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetupScriptFile(const ::std::string& msgType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetupScriptFile(msgType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetupScriptFile(const ::std::string& msgType, const ::BGI::RPC::Callback_StageRunMgrIPC_SetupScriptFilePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetupScriptFile(msgType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetupScriptFile(const ::std::string& msgType, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_SetupScriptFilePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetupScriptFile(msgType, context, cb, cookie);
    }

    void end_SetupScriptFile(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetupScriptFile(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::BGI::RPC::QCDataValues GetQCValues(const ::std::string& qcMetricName, ::Ice::Int startCycleNum, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetQCValues(_iceI_begin_GetQCValues(qcMetricName, startCycleNum, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetQCValues(const ::std::string& qcMetricName, ::Ice::Int startCycleNum, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetQCValues(qcMetricName, startCycleNum, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetQCValues(const ::std::string& qcMetricName, ::Ice::Int startCycleNum, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetQCValues(qcMetricName, startCycleNum, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetQCValues(const ::std::string& qcMetricName, ::Ice::Int startCycleNum, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetQCValues(qcMetricName, startCycleNum, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetQCValues(const ::std::string& qcMetricName, ::Ice::Int startCycleNum, const ::BGI::RPC::Callback_StageRunMgrIPC_GetQCValuesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetQCValues(qcMetricName, startCycleNum, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetQCValues(const ::std::string& qcMetricName, ::Ice::Int startCycleNum, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_GetQCValuesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetQCValues(qcMetricName, startCycleNum, context, cb, cookie);
    }

    ::BGI::RPC::QCDataValues end_GetQCValues(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetQCValues(const ::std::string&, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendSampleId(const ::std::string& sampleId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendSampleId(_iceI_begin_SendSampleId(sampleId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendSampleId(const ::std::string& sampleId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendSampleId(sampleId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendSampleId(const ::std::string& sampleId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendSampleId(sampleId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendSampleId(const ::std::string& sampleId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendSampleId(sampleId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendSampleId(const ::std::string& sampleId, const ::BGI::RPC::Callback_StageRunMgrIPC_SendSampleIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendSampleId(sampleId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendSampleId(const ::std::string& sampleId, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_SendSampleIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendSampleId(sampleId, context, cb, cookie);
    }

    void end_SendSampleId(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendSampleId(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::BGI::RPC::ExperimentInfo GetExperimentInfo(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetExperimentInfo(_iceI_begin_GetExperimentInfo(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetExperimentInfo(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetExperimentInfo(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetExperimentInfo(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetExperimentInfo(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetExperimentInfo(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetExperimentInfo(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetExperimentInfo(const ::BGI::RPC::Callback_StageRunMgrIPC_GetExperimentInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetExperimentInfo(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetExperimentInfo(const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_GetExperimentInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetExperimentInfo(context, cb, cookie);
    }

    ::BGI::RPC::ExperimentInfo end_GetExperimentInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetExperimentInfo(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void DownloadScriptFile(::std::string& workFlowScript, ::std::string& imageScript, ::std::string& biochemistryScript, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_DownloadScriptFile(workFlowScript, imageScript, biochemistryScript, _iceI_begin_DownloadScriptFile(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_DownloadScriptFile(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_DownloadScriptFile(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_DownloadScriptFile(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DownloadScriptFile(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_DownloadScriptFile(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DownloadScriptFile(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_DownloadScriptFile(const ::BGI::RPC::Callback_StageRunMgrIPC_DownloadScriptFilePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DownloadScriptFile(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_DownloadScriptFile(const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_DownloadScriptFilePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_DownloadScriptFile(context, cb, cookie);
    }

    void end_DownloadScriptFile(::std::string& workFlowScript, ::std::string& imageScript, ::std::string& biochemistryScript, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_DownloadScriptFile(::std::string& iceP_workFlowScript, ::std::string& iceP_imageScript, ::std::string& iceP_biochemistryScript, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_DownloadScriptFile(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void UIOperation(const ::std::string& message, const ::std::string& datetime, const ::std::string& errorcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_UIOperation(_iceI_begin_UIOperation(message, datetime, errorcode, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_UIOperation(const ::std::string& message, const ::std::string& datetime, const ::std::string& errorcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_UIOperation(message, datetime, errorcode, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_UIOperation(const ::std::string& message, const ::std::string& datetime, const ::std::string& errorcode, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UIOperation(message, datetime, errorcode, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UIOperation(const ::std::string& message, const ::std::string& datetime, const ::std::string& errorcode, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UIOperation(message, datetime, errorcode, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UIOperation(const ::std::string& message, const ::std::string& datetime, const ::std::string& errorcode, const ::BGI::RPC::Callback_StageRunMgrIPC_UIOperationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UIOperation(message, datetime, errorcode, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_UIOperation(const ::std::string& message, const ::std::string& datetime, const ::std::string& errorcode, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_UIOperationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_UIOperation(message, datetime, errorcode, context, cb, cookie);
    }

    void end_UIOperation(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_UIOperation(const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::BGI::RPC::AlarmMessageList GetAlarmMessages(::Ice::Int startMessageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetAlarmMessages(_iceI_begin_GetAlarmMessages(startMessageId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetAlarmMessages(::Ice::Int startMessageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetAlarmMessages(startMessageId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetAlarmMessages(::Ice::Int startMessageId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAlarmMessages(startMessageId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAlarmMessages(::Ice::Int startMessageId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAlarmMessages(startMessageId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAlarmMessages(::Ice::Int startMessageId, const ::BGI::RPC::Callback_StageRunMgrIPC_GetAlarmMessagesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAlarmMessages(startMessageId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAlarmMessages(::Ice::Int startMessageId, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_GetAlarmMessagesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAlarmMessages(startMessageId, context, cb, cookie);
    }

    ::BGI::RPC::AlarmMessageList end_GetAlarmMessages(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetAlarmMessages(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::BGI::RPC::LogMessageList GetLogMessages(::Ice::Int startMessageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetLogMessages(_iceI_begin_GetLogMessages(startMessageId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetLogMessages(::Ice::Int startMessageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetLogMessages(startMessageId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetLogMessages(::Ice::Int startMessageId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLogMessages(startMessageId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLogMessages(::Ice::Int startMessageId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLogMessages(startMessageId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLogMessages(::Ice::Int startMessageId, const ::BGI::RPC::Callback_StageRunMgrIPC_GetLogMessagesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLogMessages(startMessageId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLogMessages(::Ice::Int startMessageId, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_GetLogMessagesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLogMessages(startMessageId, context, cb, cookie);
    }

    ::BGI::RPC::LogMessageList end_GetLogMessages(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetLogMessages(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void ClearAlarmMessages(const ::BGI::RPC::ClearAlarmMessageIds& ids, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_ClearAlarmMessages(_iceI_begin_ClearAlarmMessages(ids, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ClearAlarmMessages(const ::BGI::RPC::ClearAlarmMessageIds& ids, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ClearAlarmMessages(ids, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ClearAlarmMessages(const ::BGI::RPC::ClearAlarmMessageIds& ids, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearAlarmMessages(ids, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearAlarmMessages(const ::BGI::RPC::ClearAlarmMessageIds& ids, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearAlarmMessages(ids, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearAlarmMessages(const ::BGI::RPC::ClearAlarmMessageIds& ids, const ::BGI::RPC::Callback_StageRunMgrIPC_ClearAlarmMessagesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearAlarmMessages(ids, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ClearAlarmMessages(const ::BGI::RPC::ClearAlarmMessageIds& ids, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_ClearAlarmMessagesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ClearAlarmMessages(ids, context, cb, cookie);
    }

    void end_ClearAlarmMessages(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ClearAlarmMessages(const ::BGI::RPC::ClearAlarmMessageIds&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void ReagentNeedle(bool UP, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_ReagentNeedle(_iceI_begin_ReagentNeedle(UP, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ReagentNeedle(bool UP, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ReagentNeedle(UP, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ReagentNeedle(bool UP, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ReagentNeedle(UP, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ReagentNeedle(bool UP, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ReagentNeedle(UP, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ReagentNeedle(bool UP, const ::BGI::RPC::Callback_StageRunMgrIPC_ReagentNeedlePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ReagentNeedle(UP, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ReagentNeedle(bool UP, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_ReagentNeedlePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ReagentNeedle(UP, context, cb, cookie);
    }

    void end_ReagentNeedle(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ReagentNeedle(bool, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendExperimentType(const ::std::string& experimentType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendExperimentType(_iceI_begin_SendExperimentType(experimentType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendExperimentType(const ::std::string& experimentType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendExperimentType(experimentType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendExperimentType(const ::std::string& experimentType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendExperimentType(experimentType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendExperimentType(const ::std::string& experimentType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendExperimentType(experimentType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendExperimentType(const ::std::string& experimentType, const ::BGI::RPC::Callback_StageRunMgrIPC_SendExperimentTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendExperimentType(experimentType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendExperimentType(const ::std::string& experimentType, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_SendExperimentTypePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendExperimentType(experimentType, context, cb, cookie);
    }

    void end_SendExperimentType(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendExperimentType(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SetBuzzerVolume(::Ice::Int frenquency, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SetBuzzerVolume(_iceI_begin_SetBuzzerVolume(frenquency, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetBuzzerVolume(::Ice::Int frenquency, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetBuzzerVolume(frenquency, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetBuzzerVolume(::Ice::Int frenquency, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetBuzzerVolume(frenquency, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetBuzzerVolume(::Ice::Int frenquency, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetBuzzerVolume(frenquency, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetBuzzerVolume(::Ice::Int frenquency, const ::BGI::RPC::Callback_StageRunMgrIPC_SetBuzzerVolumePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetBuzzerVolume(frenquency, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetBuzzerVolume(::Ice::Int frenquency, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_SetBuzzerVolumePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetBuzzerVolume(frenquency, context, cb, cookie);
    }

    void end_SetBuzzerVolume(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetBuzzerVolume(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::BGI::RPC::SequenceTypes GetSequenceTypes(const ::std::string& sampleId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetSequenceTypes(_iceI_begin_GetSequenceTypes(sampleId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetSequenceTypes(const ::std::string& sampleId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetSequenceTypes(sampleId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetSequenceTypes(const ::std::string& sampleId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetSequenceTypes(sampleId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetSequenceTypes(const ::std::string& sampleId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetSequenceTypes(sampleId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetSequenceTypes(const ::std::string& sampleId, const ::BGI::RPC::Callback_StageRunMgrIPC_GetSequenceTypesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetSequenceTypes(sampleId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetSequenceTypes(const ::std::string& sampleId, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_GetSequenceTypesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetSequenceTypes(sampleId, context, cb, cookie);
    }

    ::BGI::RPC::SequenceTypes end_GetSequenceTypes(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetSequenceTypes(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool SetClearData(const ::BGI::RPC::DataList& datas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetClearData(_iceI_begin_SetClearData(datas, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetClearData(const ::BGI::RPC::DataList& datas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetClearData(datas, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetClearData(const ::BGI::RPC::DataList& datas, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetClearData(datas, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetClearData(const ::BGI::RPC::DataList& datas, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetClearData(datas, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetClearData(const ::BGI::RPC::DataList& datas, const ::BGI::RPC::Callback_StageRunMgrIPC_SetClearDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetClearData(datas, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetClearData(const ::BGI::RPC::DataList& datas, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_SetClearDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetClearData(datas, context, cb, cookie);
    }

    bool end_SetClearData(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetClearData(const ::BGI::RPC::DataList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void StartRunLength(::Ice::Int read1length, ::Ice::Int read2length, ::Ice::Int bardcodelength, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_StartRunLength(_iceI_begin_StartRunLength(read1length, read2length, bardcodelength, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_StartRunLength(::Ice::Int read1length, ::Ice::Int read2length, ::Ice::Int bardcodelength, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_StartRunLength(read1length, read2length, bardcodelength, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StartRunLength(::Ice::Int read1length, ::Ice::Int read2length, ::Ice::Int bardcodelength, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartRunLength(read1length, read2length, bardcodelength, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartRunLength(::Ice::Int read1length, ::Ice::Int read2length, ::Ice::Int bardcodelength, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartRunLength(read1length, read2length, bardcodelength, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartRunLength(::Ice::Int read1length, ::Ice::Int read2length, ::Ice::Int bardcodelength, const ::BGI::RPC::Callback_StageRunMgrIPC_StartRunLengthPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartRunLength(read1length, read2length, bardcodelength, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartRunLength(::Ice::Int read1length, ::Ice::Int read2length, ::Ice::Int bardcodelength, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_StartRunLengthPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartRunLength(read1length, read2length, bardcodelength, context, cb, cookie);
    }

    void end_StartRunLength(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_StartRunLength(::Ice::Int, ::Ice::Int, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SetupRunInfo(const ::BGI::RPC::RunInfo& runInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SetupRunInfo(_iceI_begin_SetupRunInfo(runInfo, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetupRunInfo(const ::BGI::RPC::RunInfo& runInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetupRunInfo(runInfo, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetupRunInfo(const ::BGI::RPC::RunInfo& runInfo, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetupRunInfo(runInfo, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetupRunInfo(const ::BGI::RPC::RunInfo& runInfo, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetupRunInfo(runInfo, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetupRunInfo(const ::BGI::RPC::RunInfo& runInfo, const ::BGI::RPC::Callback_StageRunMgrIPC_SetupRunInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetupRunInfo(runInfo, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetupRunInfo(const ::BGI::RPC::RunInfo& runInfo, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_SetupRunInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetupRunInfo(runInfo, context, cb, cookie);
    }

    void end_SetupRunInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetupRunInfo(const ::BGI::RPC::RunInfo&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void MotorMove(::BGI::RPC::MotorTypeEnum motor, bool up, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_MotorMove(_iceI_begin_MotorMove(motor, up, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_MotorMove(::BGI::RPC::MotorTypeEnum motor, bool up, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_MotorMove(motor, up, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_MotorMove(::BGI::RPC::MotorTypeEnum motor, bool up, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MotorMove(motor, up, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MotorMove(::BGI::RPC::MotorTypeEnum motor, bool up, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MotorMove(motor, up, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MotorMove(::BGI::RPC::MotorTypeEnum motor, bool up, const ::BGI::RPC::Callback_StageRunMgrIPC_MotorMovePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MotorMove(motor, up, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_MotorMove(::BGI::RPC::MotorTypeEnum motor, bool up, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_MotorMovePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_MotorMove(motor, up, context, cb, cookie);
    }

    void end_MotorMove(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_MotorMove(::BGI::RPC::MotorTypeEnum, bool, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::BGI::RPC::LoginedInfo Authenicate(const ::std::string& userName, const ::std::string& password, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_Authenicate(_iceI_begin_Authenicate(userName, password, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_Authenicate(const ::std::string& userName, const ::std::string& password, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_Authenicate(userName, password, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Authenicate(const ::std::string& userName, const ::std::string& password, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Authenicate(userName, password, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Authenicate(const ::std::string& userName, const ::std::string& password, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Authenicate(userName, password, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Authenicate(const ::std::string& userName, const ::std::string& password, const ::BGI::RPC::Callback_StageRunMgrIPC_AuthenicatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Authenicate(userName, password, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Authenicate(const ::std::string& userName, const ::std::string& password, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_AuthenicatePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Authenicate(userName, password, context, cb, cookie);
    }

    ::BGI::RPC::LoginedInfo end_Authenicate(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_Authenicate(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string GetLanguage(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetLanguage(_iceI_begin_GetLanguage(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetLanguage(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetLanguage(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetLanguage(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLanguage(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLanguage(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLanguage(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLanguage(const ::BGI::RPC::Callback_StageRunMgrIPC_GetLanguagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLanguage(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetLanguage(const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_GetLanguagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetLanguage(context, cb, cookie);
    }

    ::std::string end_GetLanguage(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetLanguage(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SetLanguage(const ::std::string& language, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SetLanguage(_iceI_begin_SetLanguage(language, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetLanguage(const ::std::string& language, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetLanguage(language, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetLanguage(const ::std::string& language, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetLanguage(language, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetLanguage(const ::std::string& language, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetLanguage(language, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetLanguage(const ::std::string& language, const ::BGI::RPC::Callback_StageRunMgrIPC_SetLanguagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetLanguage(language, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetLanguage(const ::std::string& language, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_SetLanguagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetLanguage(language, context, cb, cookie);
    }

    void end_SetLanguage(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetLanguage(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SetBaseCallIpAddr(const ::std::string& ipAddr, ::Ice::Int port, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SetBaseCallIpAddr(_iceI_begin_SetBaseCallIpAddr(ipAddr, port, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetBaseCallIpAddr(const ::std::string& ipAddr, ::Ice::Int port, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetBaseCallIpAddr(ipAddr, port, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetBaseCallIpAddr(const ::std::string& ipAddr, ::Ice::Int port, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetBaseCallIpAddr(ipAddr, port, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetBaseCallIpAddr(const ::std::string& ipAddr, ::Ice::Int port, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetBaseCallIpAddr(ipAddr, port, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetBaseCallIpAddr(const ::std::string& ipAddr, ::Ice::Int port, const ::BGI::RPC::Callback_StageRunMgrIPC_SetBaseCallIpAddrPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetBaseCallIpAddr(ipAddr, port, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetBaseCallIpAddr(const ::std::string& ipAddr, ::Ice::Int port, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_SetBaseCallIpAddrPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetBaseCallIpAddr(ipAddr, port, context, cb, cookie);
    }

    void end_SetBaseCallIpAddr(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetBaseCallIpAddr(const ::std::string&, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SetZLIMSIpAddr(const ::std::string& ipAddr, ::Ice::Int port, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SetZLIMSIpAddr(_iceI_begin_SetZLIMSIpAddr(ipAddr, port, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetZLIMSIpAddr(const ::std::string& ipAddr, ::Ice::Int port, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetZLIMSIpAddr(ipAddr, port, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetZLIMSIpAddr(const ::std::string& ipAddr, ::Ice::Int port, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetZLIMSIpAddr(ipAddr, port, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetZLIMSIpAddr(const ::std::string& ipAddr, ::Ice::Int port, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetZLIMSIpAddr(ipAddr, port, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetZLIMSIpAddr(const ::std::string& ipAddr, ::Ice::Int port, const ::BGI::RPC::Callback_StageRunMgrIPC_SetZLIMSIpAddrPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetZLIMSIpAddr(ipAddr, port, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetZLIMSIpAddr(const ::std::string& ipAddr, ::Ice::Int port, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_SetZLIMSIpAddrPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetZLIMSIpAddr(ipAddr, port, context, cb, cookie);
    }

    void end_SetZLIMSIpAddr(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetZLIMSIpAddr(const ::std::string&, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::BGI::RPC::IpAddr GetZLIMSAddr(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetZLIMSAddr(_iceI_begin_GetZLIMSAddr(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetZLIMSAddr(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetZLIMSAddr(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetZLIMSAddr(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetZLIMSAddr(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetZLIMSAddr(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetZLIMSAddr(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetZLIMSAddr(const ::BGI::RPC::Callback_StageRunMgrIPC_GetZLIMSAddrPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetZLIMSAddr(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetZLIMSAddr(const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_GetZLIMSAddrPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetZLIMSAddr(context, cb, cookie);
    }

    ::BGI::RPC::IpAddr end_GetZLIMSAddr(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetZLIMSAddr(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SetCategoryParas(const ::std::string& category, const ::BGI::RPC::ParaDict& paraDict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SetCategoryParas(_iceI_begin_SetCategoryParas(category, paraDict, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetCategoryParas(const ::std::string& category, const ::BGI::RPC::ParaDict& paraDict, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetCategoryParas(category, paraDict, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetCategoryParas(const ::std::string& category, const ::BGI::RPC::ParaDict& paraDict, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetCategoryParas(category, paraDict, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetCategoryParas(const ::std::string& category, const ::BGI::RPC::ParaDict& paraDict, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetCategoryParas(category, paraDict, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetCategoryParas(const ::std::string& category, const ::BGI::RPC::ParaDict& paraDict, const ::BGI::RPC::Callback_StageRunMgrIPC_SetCategoryParasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetCategoryParas(category, paraDict, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetCategoryParas(const ::std::string& category, const ::BGI::RPC::ParaDict& paraDict, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_SetCategoryParasPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetCategoryParas(category, paraDict, context, cb, cookie);
    }

    void end_SetCategoryParas(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetCategoryParas(const ::std::string&, const ::BGI::RPC::ParaDict&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::std::string GetParaValue(const ::std::string& category, const ::std::string& paraName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetParaValue(_iceI_begin_GetParaValue(category, paraName, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetParaValue(const ::std::string& category, const ::std::string& paraName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetParaValue(category, paraName, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetParaValue(const ::std::string& category, const ::std::string& paraName, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetParaValue(category, paraName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetParaValue(const ::std::string& category, const ::std::string& paraName, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetParaValue(category, paraName, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetParaValue(const ::std::string& category, const ::std::string& paraName, const ::BGI::RPC::Callback_StageRunMgrIPC_GetParaValuePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetParaValue(category, paraName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetParaValue(const ::std::string& category, const ::std::string& paraName, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_GetParaValuePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetParaValue(category, paraName, context, cb, cookie);
    }

    ::std::string end_GetParaValue(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetParaValue(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void StartSelfCheck(::BGI::RPC::DeviceCheckTypeEnum checkType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_StartSelfCheck(_iceI_begin_StartSelfCheck(checkType, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_StartSelfCheck(::BGI::RPC::DeviceCheckTypeEnum checkType, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_StartSelfCheck(checkType, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StartSelfCheck(::BGI::RPC::DeviceCheckTypeEnum checkType, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartSelfCheck(checkType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartSelfCheck(::BGI::RPC::DeviceCheckTypeEnum checkType, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartSelfCheck(checkType, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartSelfCheck(::BGI::RPC::DeviceCheckTypeEnum checkType, const ::BGI::RPC::Callback_StageRunMgrIPC_StartSelfCheckPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartSelfCheck(checkType, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartSelfCheck(::BGI::RPC::DeviceCheckTypeEnum checkType, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPC_StartSelfCheckPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartSelfCheck(checkType, context, cb, cookie);
    }

    void end_StartSelfCheck(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_StartSelfCheck(::BGI::RPC::DeviceCheckTypeEnum, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class StageRunMgrIPCCallback : public virtual ::Ice::Proxy<StageRunMgrIPCCallback, ::IceProxy::Ice::Object>
{
public:

    void AddClient(const ::Ice::Identity& ident, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_AddClient(_iceI_begin_AddClient(ident, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_AddClient(const ::Ice::Identity& ident, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_AddClient(ident, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_AddClient(const ::Ice::Identity& ident, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AddClient(ident, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_AddClient(const ::Ice::Identity& ident, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AddClient(ident, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_AddClient(const ::Ice::Identity& ident, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_AddClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AddClient(ident, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_AddClient(const ::Ice::Identity& ident, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_AddClientPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_AddClient(ident, context, cb, cookie);
    }

    void end_AddClient(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_AddClient(const ::Ice::Identity&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendScriptName(const ::std::string& scriptName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendScriptName(_iceI_begin_SendScriptName(scriptName, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendScriptName(const ::std::string& scriptName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendScriptName(scriptName, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendScriptName(const ::std::string& scriptName, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendScriptName(scriptName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendScriptName(const ::std::string& scriptName, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendScriptName(scriptName, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendScriptName(const ::std::string& scriptName, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendScriptNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendScriptName(scriptName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendScriptName(const ::std::string& scriptName, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendScriptNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendScriptName(scriptName, context, cb, cookie);
    }

    void end_SendScriptName(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendScriptName(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendActionName(const ::std::string& actionName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendActionName(_iceI_begin_SendActionName(actionName, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendActionName(const ::std::string& actionName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendActionName(actionName, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendActionName(const ::std::string& actionName, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendActionName(actionName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendActionName(const ::std::string& actionName, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendActionName(actionName, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendActionName(const ::std::string& actionName, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendActionNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendActionName(actionName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendActionName(const ::std::string& actionName, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendActionNamePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendActionName(actionName, context, cb, cookie);
    }

    void end_SendActionName(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendActionName(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendFlowcellBarcode(const ::std::string& flowcellBarcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendFlowcellBarcode(_iceI_begin_SendFlowcellBarcode(flowcellBarcode, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendFlowcellBarcode(const ::std::string& flowcellBarcode, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendFlowcellBarcode(flowcellBarcode, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendFlowcellBarcode(const ::std::string& flowcellBarcode, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendFlowcellBarcode(flowcellBarcode, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendFlowcellBarcode(const ::std::string& flowcellBarcode, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendFlowcellBarcode(flowcellBarcode, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendFlowcellBarcode(const ::std::string& flowcellBarcode, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendFlowcellBarcodePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendFlowcellBarcode(flowcellBarcode, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendFlowcellBarcode(const ::std::string& flowcellBarcode, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendFlowcellBarcodePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendFlowcellBarcode(flowcellBarcode, context, cb, cookie);
    }

    void end_SendFlowcellBarcode(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendFlowcellBarcode(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendPositionNumber(::Ice::Int cycleNum, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendPositionNumber(_iceI_begin_SendPositionNumber(cycleNum, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendPositionNumber(::Ice::Int cycleNum, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendPositionNumber(cycleNum, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendPositionNumber(::Ice::Int cycleNum, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendPositionNumber(cycleNum, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendPositionNumber(::Ice::Int cycleNum, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendPositionNumber(cycleNum, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendPositionNumber(::Ice::Int cycleNum, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendPositionNumberPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendPositionNumber(cycleNum, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendPositionNumber(::Ice::Int cycleNum, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendPositionNumberPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendPositionNumber(cycleNum, context, cb, cookie);
    }

    void end_SendPositionNumber(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendPositionNumber(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendPcntDone(::Ice::Int pctDone, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendPcntDone(_iceI_begin_SendPcntDone(pctDone, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendPcntDone(::Ice::Int pctDone, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendPcntDone(pctDone, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendPcntDone(::Ice::Int pctDone, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendPcntDone(pctDone, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendPcntDone(::Ice::Int pctDone, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendPcntDone(pctDone, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendPcntDone(::Ice::Int pctDone, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendPcntDonePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendPcntDone(pctDone, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendPcntDone(::Ice::Int pctDone, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendPcntDonePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendPcntDone(pctDone, context, cb, cookie);
    }

    void end_SendPcntDone(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendPcntDone(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendScriptStatus(::BGI::RPC::ScriptStateEnum curState, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendScriptStatus(_iceI_begin_SendScriptStatus(curState, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendScriptStatus(::BGI::RPC::ScriptStateEnum curState, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendScriptStatus(curState, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendScriptStatus(::BGI::RPC::ScriptStateEnum curState, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendScriptStatus(curState, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendScriptStatus(::BGI::RPC::ScriptStateEnum curState, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendScriptStatus(curState, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendScriptStatus(::BGI::RPC::ScriptStateEnum curState, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendScriptStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendScriptStatus(curState, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendScriptStatus(::BGI::RPC::ScriptStateEnum curState, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendScriptStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendScriptStatus(curState, context, cb, cookie);
    }

    void end_SendScriptStatus(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendScriptStatus(::BGI::RPC::ScriptStateEnum, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendScriptMessageId(::Ice::Int messageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendScriptMessageId(_iceI_begin_SendScriptMessageId(messageId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendScriptMessageId(::Ice::Int messageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendScriptMessageId(messageId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendScriptMessageId(::Ice::Int messageId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendScriptMessageId(messageId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendScriptMessageId(::Ice::Int messageId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendScriptMessageId(messageId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendScriptMessageId(::Ice::Int messageId, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendScriptMessageIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendScriptMessageId(messageId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendScriptMessageId(::Ice::Int messageId, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendScriptMessageIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendScriptMessageId(messageId, context, cb, cookie);
    }

    void end_SendScriptMessageId(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendScriptMessageId(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendStageMessage(const ::std::string& msgType, const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendStageMessage(_iceI_begin_SendStageMessage(msgType, message, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendStageMessage(const ::std::string& msgType, const ::std::string& message, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendStageMessage(msgType, message, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendStageMessage(const ::std::string& msgType, const ::std::string& message, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendStageMessage(msgType, message, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendStageMessage(const ::std::string& msgType, const ::std::string& message, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendStageMessage(msgType, message, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendStageMessage(const ::std::string& msgType, const ::std::string& message, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendStageMessagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendStageMessage(msgType, message, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendStageMessage(const ::std::string& msgType, const ::std::string& message, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendStageMessagePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendStageMessage(msgType, message, context, cb, cookie);
    }

    void end_SendStageMessage(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendStageMessage(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendQCValue(const ::BGI::RPC::QCDataValue& qcValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendQCValue(_iceI_begin_SendQCValue(qcValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendQCValue(const ::BGI::RPC::QCDataValue& qcValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendQCValue(qcValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendQCValue(const ::BGI::RPC::QCDataValue& qcValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendQCValue(qcValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendQCValue(const ::BGI::RPC::QCDataValue& qcValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendQCValue(qcValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendQCValue(const ::BGI::RPC::QCDataValue& qcValue, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendQCValuePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendQCValue(qcValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendQCValue(const ::BGI::RPC::QCDataValue& qcValue, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendQCValuePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendQCValue(qcValue, context, cb, cookie);
    }

    void end_SendQCValue(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendQCValue(const ::BGI::RPC::QCDataValue&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendQCValues(const ::BGI::RPC::QCDataValues& qcValues, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendQCValues(_iceI_begin_SendQCValues(qcValues, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendQCValues(const ::BGI::RPC::QCDataValues& qcValues, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendQCValues(qcValues, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendQCValues(const ::BGI::RPC::QCDataValues& qcValues, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendQCValues(qcValues, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendQCValues(const ::BGI::RPC::QCDataValues& qcValues, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendQCValues(qcValues, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendQCValues(const ::BGI::RPC::QCDataValues& qcValues, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendQCValuesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendQCValues(qcValues, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendQCValues(const ::BGI::RPC::QCDataValues& qcValues, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendQCValuesPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendQCValues(qcValues, context, cb, cookie);
    }

    void end_SendQCValues(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendQCValues(const ::BGI::RPC::QCDataValues&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendAlarmMessageId(::Ice::Int messageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendAlarmMessageId(_iceI_begin_SendAlarmMessageId(messageId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendAlarmMessageId(::Ice::Int messageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendAlarmMessageId(messageId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendAlarmMessageId(::Ice::Int messageId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendAlarmMessageId(messageId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendAlarmMessageId(::Ice::Int messageId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendAlarmMessageId(messageId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendAlarmMessageId(::Ice::Int messageId, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendAlarmMessageIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendAlarmMessageId(messageId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendAlarmMessageId(::Ice::Int messageId, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendAlarmMessageIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendAlarmMessageId(messageId, context, cb, cookie);
    }

    void end_SendAlarmMessageId(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendAlarmMessageId(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendLogMessageId(::Ice::Int messageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendLogMessageId(_iceI_begin_SendLogMessageId(messageId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendLogMessageId(::Ice::Int messageId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendLogMessageId(messageId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendLogMessageId(::Ice::Int messageId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendLogMessageId(messageId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendLogMessageId(::Ice::Int messageId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendLogMessageId(messageId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendLogMessageId(::Ice::Int messageId, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendLogMessageIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendLogMessageId(messageId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendLogMessageId(::Ice::Int messageId, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendLogMessageIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendLogMessageId(messageId, context, cb, cookie);
    }

    void end_SendLogMessageId(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendLogMessageId(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendRemainingTime(::Ice::Double remainingTimeMinute, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendRemainingTime(_iceI_begin_SendRemainingTime(remainingTimeMinute, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendRemainingTime(::Ice::Double remainingTimeMinute, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendRemainingTime(remainingTimeMinute, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendRemainingTime(::Ice::Double remainingTimeMinute, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendRemainingTime(remainingTimeMinute, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendRemainingTime(::Ice::Double remainingTimeMinute, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendRemainingTime(remainingTimeMinute, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendRemainingTime(::Ice::Double remainingTimeMinute, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendRemainingTimePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendRemainingTime(remainingTimeMinute, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendRemainingTime(::Ice::Double remainingTimeMinute, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendRemainingTimePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendRemainingTime(remainingTimeMinute, context, cb, cookie);
    }

    void end_SendRemainingTime(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendRemainingTime(::Ice::Double, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendDataList(const ::BGI::RPC::DataList& datas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendDataList(_iceI_begin_SendDataList(datas, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendDataList(const ::BGI::RPC::DataList& datas, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendDataList(datas, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendDataList(const ::BGI::RPC::DataList& datas, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendDataList(datas, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendDataList(const ::BGI::RPC::DataList& datas, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendDataList(datas, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendDataList(const ::BGI::RPC::DataList& datas, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendDataListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendDataList(datas, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendDataList(const ::BGI::RPC::DataList& datas, const ::Ice::Context& context, const ::BGI::RPC::Callback_StageRunMgrIPCCallback_SendDataListPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendDataList(datas, context, cb, cookie);
    }

    void end_SendDataList(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendDataList(const ::BGI::RPC::DataList&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

}

namespace BGI
{

namespace RPC
{

class StageRunMgrIPC : public virtual ::Ice::Object
{
public:

    typedef StageRunMgrIPCPrx ProxyType;
    typedef StageRunMgrIPCPtr PointerType;

    virtual ~StageRunMgrIPC();

#ifdef ICE_CPP11_COMPILER
    StageRunMgrIPC() = default;
    StageRunMgrIPC(const StageRunMgrIPC&) = default;
    StageRunMgrIPC& operator=(const StageRunMgrIPC&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual ::Ice::Int GetHeartbeat(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetHeartbeat(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void StartSetup(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_StartSetup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SaveSelectedScriptFileName(const ::std::string& strFileName, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SaveSelectedScriptFileName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void ScanFlowcellBarcode(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ScanFlowcellBarcode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void ScanReagentKitBarcode(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ScanReagentKitBarcode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void OverrideFlowcellBarcode(const ::std::string& barcode, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_OverrideFlowcellBarcode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendReagentKit(const ::std::string& reagentKit, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendReagentKit(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void StartRun(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_StartRun(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void PauseScript(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_PauseScript(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void ResumeScript(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ResumeScript(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void StopScript(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_StopScript(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void AbortScript(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_AbortScript(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int RunScriptNow(const ::std::string& strFileName, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_RunScriptNow(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ScriptRunInfo GetScriptRunInfo(::Ice::Int scriptRunId, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetScriptRunInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual MessageArray GetScriptMessages(::Ice::Int startMessageId, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetScriptMessages(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SetupScriptFile(const ::std::string& msgType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetupScriptFile(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual QCDataValues GetQCValues(const ::std::string& qcMetricName, ::Ice::Int startCycleNum, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetQCValues(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendSampleId(const ::std::string& sampleId, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendSampleId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ExperimentInfo GetExperimentInfo(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetExperimentInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void DownloadScriptFile(::std::string& workFlowScript, ::std::string& imageScript, ::std::string& biochemistryScript, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_DownloadScriptFile(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void UIOperation(const ::std::string& message, const ::std::string& datetime, const ::std::string& errorcode, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_UIOperation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual AlarmMessageList GetAlarmMessages(::Ice::Int startMessageId, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetAlarmMessages(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LogMessageList GetLogMessages(::Ice::Int startMessageId, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetLogMessages(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void ClearAlarmMessages(const ClearAlarmMessageIds& ids, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ClearAlarmMessages(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void ReagentNeedle(bool UP, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ReagentNeedle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendExperimentType(const ::std::string& experimentType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendExperimentType(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SetBuzzerVolume(::Ice::Int frenquency, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetBuzzerVolume(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual SequenceTypes GetSequenceTypes(const ::std::string& sampleId, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetSequenceTypes(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool SetClearData(const DataList& datas, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetClearData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void StartRunLength(::Ice::Int read1length, ::Ice::Int read2length, ::Ice::Int bardcodelength, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_StartRunLength(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SetupRunInfo(const RunInfo& runInfo, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetupRunInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void MotorMove(MotorTypeEnum motor, bool up, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_MotorMove(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual LoginedInfo Authenicate(const ::std::string& userName, const ::std::string& password, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_Authenicate(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string GetLanguage(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetLanguage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SetLanguage(const ::std::string& language, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetLanguage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SetBaseCallIpAddr(const ::std::string& ipAddr, ::Ice::Int port, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetBaseCallIpAddr(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SetZLIMSIpAddr(const ::std::string& ipAddr, ::Ice::Int port, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetZLIMSIpAddr(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual IpAddr GetZLIMSAddr(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetZLIMSAddr(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SetCategoryParas(const ::std::string& category, const ParaDict& paraDict, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetCategoryParas(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::std::string GetParaValue(const ::std::string& category, const ::std::string& paraName, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetParaValue(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void StartSelfCheck(DeviceCheckTypeEnum checkType, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_StartSelfCheck(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const StageRunMgrIPC& lhs, const StageRunMgrIPC& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const StageRunMgrIPC& lhs, const StageRunMgrIPC& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class StageRunMgrIPCCallback : public virtual ::Ice::Object
{
public:

    typedef StageRunMgrIPCCallbackPrx ProxyType;
    typedef StageRunMgrIPCCallbackPtr PointerType;

    virtual ~StageRunMgrIPCCallback();

#ifdef ICE_CPP11_COMPILER
    StageRunMgrIPCCallback() = default;
    StageRunMgrIPCCallback(const StageRunMgrIPCCallback&) = default;
    StageRunMgrIPCCallback& operator=(const StageRunMgrIPCCallback&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void AddClient(const ::Ice::Identity& ident, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_AddClient(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendScriptName(const ::std::string& scriptName, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendScriptName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendActionName(const ::std::string& actionName, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendActionName(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendFlowcellBarcode(const ::std::string& flowcellBarcode, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendFlowcellBarcode(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendPositionNumber(::Ice::Int cycleNum, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendPositionNumber(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendPcntDone(::Ice::Int pctDone, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendPcntDone(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendScriptStatus(ScriptStateEnum curState, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendScriptStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendScriptMessageId(::Ice::Int messageId, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendScriptMessageId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendStageMessage(const ::std::string& msgType, const ::std::string& message, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendStageMessage(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendQCValue(const QCDataValue& qcValue, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendQCValue(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendQCValues(const QCDataValues& qcValues, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendQCValues(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendAlarmMessageId(::Ice::Int messageId, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendAlarmMessageId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendLogMessageId(::Ice::Int messageId, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendLogMessageId(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendRemainingTime(::Ice::Double remainingTimeMinute, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendRemainingTime(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendDataList(const DataList& datas, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendDataList(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const StageRunMgrIPCCallback& lhs, const StageRunMgrIPCCallback& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const StageRunMgrIPCCallback& lhs, const StageRunMgrIPCCallback& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::BGI::RPC::ScriptStateEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 7;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::ScriptMessageSeverityEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 4;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::MotorTypeEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::ScriptRunInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::BGI::RPC::ScriptRunInfo, S>
{
    static void write(S* ostr, const ::BGI::RPC::ScriptRunInfo& v)
    {
        ostr->write(v.ScriptRunId);
        ostr->write(v.ScriptFilename);
        ostr->write(v.ParentScriptRunId);
        ostr->write(v.StartDate);
        ostr->write(v.EndDate);
        ostr->write(v.StatusStr);
        ostr->write(v.IsSuccess);
    }
};

template<typename S>
struct StreamReader< ::BGI::RPC::ScriptRunInfo, S>
{
    static void read(S* istr, ::BGI::RPC::ScriptRunInfo& v)
    {
        istr->read(v.ScriptRunId);
        istr->read(v.ScriptFilename);
        istr->read(v.ParentScriptRunId);
        istr->read(v.StartDate);
        istr->read(v.EndDate);
        istr->read(v.StatusStr);
        istr->read(v.IsSuccess);
    }
};

template<>
struct StreamableTraits< ::BGI::RPC::DeviceCheckTypeEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 4;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::ServiceMessageInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 13;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::BGI::RPC::ServiceMessageInfo, S>
{
    static void write(S* ostr, const ::BGI::RPC::ServiceMessageInfo& v)
    {
        ostr->write(v.MessageId);
        ostr->write(v.InstructmentId);
        ostr->write(v.FlowCellId);
        ostr->write(v.UserName);
        ostr->write(v.SoftwareVersion);
        ostr->write(v.MessageType);
        ostr->write(v.Errorcode);
        ostr->write(v.Message);
        ostr->write(v.Datetime);
        ostr->write(v.IsPublic);
    }
};

template<typename S>
struct StreamReader< ::BGI::RPC::ServiceMessageInfo, S>
{
    static void read(S* istr, ::BGI::RPC::ServiceMessageInfo& v)
    {
        istr->read(v.MessageId);
        istr->read(v.InstructmentId);
        istr->read(v.FlowCellId);
        istr->read(v.UserName);
        istr->read(v.SoftwareVersion);
        istr->read(v.MessageType);
        istr->read(v.Errorcode);
        istr->read(v.Message);
        istr->read(v.Datetime);
        istr->read(v.IsPublic);
    }
};

template<>
struct StreamableTraits< ::BGI::RPC::IpAddr>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 5;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::BGI::RPC::IpAddr, S>
{
    static void write(S* ostr, const ::BGI::RPC::IpAddr& v)
    {
        ostr->write(v.IP);
        ostr->write(v.Port);
    }
};

template<typename S>
struct StreamReader< ::BGI::RPC::IpAddr, S>
{
    static void read(S* istr, ::BGI::RPC::IpAddr& v)
    {
        istr->read(v.IP);
        istr->read(v.Port);
    }
};

template<>
struct StreamableTraits< ::BGI::RPC::ScriptMessageInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 7;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::BGI::RPC::ScriptMessageInfo, S>
{
    static void write(S* ostr, const ::BGI::RPC::ScriptMessageInfo& v)
    {
        ostr->write(v.MessageId);
        ostr->write(v.MessageSeverity);
        ostr->write(v.MessageDateTime);
        ostr->write(v.MessageStr);
    }
};

template<typename S>
struct StreamReader< ::BGI::RPC::ScriptMessageInfo, S>
{
    static void read(S* istr, ::BGI::RPC::ScriptMessageInfo& v)
    {
        istr->read(v.MessageId);
        istr->read(v.MessageSeverity);
        istr->read(v.MessageDateTime);
        istr->read(v.MessageStr);
    }
};

template<>
struct StreamableTraits< ::BGI::RPC::QCDataValue>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 9;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::BGI::RPC::QCDataValue, S>
{
    static void write(S* ostr, const ::BGI::RPC::QCDataValue& v)
    {
        ostr->write(v.QCMetricName);
        ostr->write(v.cycleNum);
        ostr->write(v.QCValue);
    }
};

template<typename S>
struct StreamReader< ::BGI::RPC::QCDataValue, S>
{
    static void read(S* istr, ::BGI::RPC::QCDataValue& v)
    {
        istr->read(v.QCMetricName);
        istr->read(v.cycleNum);
        istr->read(v.QCValue);
    }
};

template<>
struct StreamableTraits< ::BGI::RPC::LoginedInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 2;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::BGI::RPC::LoginedInfo, S>
{
    static void write(S* ostr, const ::BGI::RPC::LoginedInfo& v)
    {
        ostr->write(v.IsSuccess);
        ostr->write(v.UserRole);
    }
};

template<typename S>
struct StreamReader< ::BGI::RPC::LoginedInfo, S>
{
    static void read(S* istr, ::BGI::RPC::LoginedInfo& v)
    {
        istr->read(v.IsSuccess);
        istr->read(v.UserRole);
    }
};

}
/// \endcond

namespace BGI
{

namespace RPC
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetHeartbeat.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetHeartbeat.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_GetHeartbeat : public Callback_StageRunMgrIPC_GetHeartbeat_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_StageRunMgrIPC_GetHeartbeat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_GetHeartbeat(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetHeartbeat.
 */
template<class T> Callback_StageRunMgrIPC_GetHeartbeatPtr
newCallback_StageRunMgrIPC_GetHeartbeat(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetHeartbeat<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetHeartbeat.
 */
template<class T> Callback_StageRunMgrIPC_GetHeartbeatPtr
newCallback_StageRunMgrIPC_GetHeartbeat(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetHeartbeat<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetHeartbeat.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetHeartbeat.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_GetHeartbeat : public Callback_StageRunMgrIPC_GetHeartbeat_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_StageRunMgrIPC_GetHeartbeat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_GetHeartbeat(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetHeartbeat.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetHeartbeatPtr
newCallback_StageRunMgrIPC_GetHeartbeat(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetHeartbeat<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetHeartbeat.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetHeartbeatPtr
newCallback_StageRunMgrIPC_GetHeartbeat(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetHeartbeat<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSetup.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StartSetup.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_StartSetup : public Callback_StageRunMgrIPC_StartSetup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_StartSetup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_StartSetup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSetup.
 */
template<class T> Callback_StageRunMgrIPC_StartSetupPtr
newCallback_StageRunMgrIPC_StartSetup(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartSetup<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSetup.
 */
template<class T> Callback_StageRunMgrIPC_StartSetupPtr
newCallback_StageRunMgrIPC_StartSetup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartSetup<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSetup.
 */
template<class T> Callback_StageRunMgrIPC_StartSetupPtr
newCallback_StageRunMgrIPC_StartSetup(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartSetup<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSetup.
 */
template<class T> Callback_StageRunMgrIPC_StartSetupPtr
newCallback_StageRunMgrIPC_StartSetup(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartSetup<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSetup.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StartSetup.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_StartSetup : public Callback_StageRunMgrIPC_StartSetup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_StartSetup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_StartSetup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSetup.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartSetupPtr
newCallback_StageRunMgrIPC_StartSetup(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartSetup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSetup.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartSetupPtr
newCallback_StageRunMgrIPC_StartSetup(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartSetup<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSetup.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartSetupPtr
newCallback_StageRunMgrIPC_StartSetup(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartSetup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSetup.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartSetupPtr
newCallback_StageRunMgrIPC_StartSetup(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartSetup<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SaveSelectedScriptFileName.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SaveSelectedScriptFileName.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_SaveSelectedScriptFileName : public Callback_StageRunMgrIPC_SaveSelectedScriptFileName_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_SaveSelectedScriptFileName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_SaveSelectedScriptFileName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SaveSelectedScriptFileName.
 */
template<class T> Callback_StageRunMgrIPC_SaveSelectedScriptFileNamePtr
newCallback_StageRunMgrIPC_SaveSelectedScriptFileName(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SaveSelectedScriptFileName<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SaveSelectedScriptFileName.
 */
template<class T> Callback_StageRunMgrIPC_SaveSelectedScriptFileNamePtr
newCallback_StageRunMgrIPC_SaveSelectedScriptFileName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SaveSelectedScriptFileName<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SaveSelectedScriptFileName.
 */
template<class T> Callback_StageRunMgrIPC_SaveSelectedScriptFileNamePtr
newCallback_StageRunMgrIPC_SaveSelectedScriptFileName(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SaveSelectedScriptFileName<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SaveSelectedScriptFileName.
 */
template<class T> Callback_StageRunMgrIPC_SaveSelectedScriptFileNamePtr
newCallback_StageRunMgrIPC_SaveSelectedScriptFileName(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SaveSelectedScriptFileName<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SaveSelectedScriptFileName.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SaveSelectedScriptFileName.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_SaveSelectedScriptFileName : public Callback_StageRunMgrIPC_SaveSelectedScriptFileName_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_SaveSelectedScriptFileName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_SaveSelectedScriptFileName(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SaveSelectedScriptFileName.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SaveSelectedScriptFileNamePtr
newCallback_StageRunMgrIPC_SaveSelectedScriptFileName(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SaveSelectedScriptFileName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SaveSelectedScriptFileName.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SaveSelectedScriptFileNamePtr
newCallback_StageRunMgrIPC_SaveSelectedScriptFileName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SaveSelectedScriptFileName<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SaveSelectedScriptFileName.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SaveSelectedScriptFileNamePtr
newCallback_StageRunMgrIPC_SaveSelectedScriptFileName(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SaveSelectedScriptFileName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SaveSelectedScriptFileName.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SaveSelectedScriptFileNamePtr
newCallback_StageRunMgrIPC_SaveSelectedScriptFileName(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SaveSelectedScriptFileName<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanFlowcellBarcode.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ScanFlowcellBarcode.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_ScanFlowcellBarcode : public Callback_StageRunMgrIPC_ScanFlowcellBarcode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_ScanFlowcellBarcode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_ScanFlowcellBarcode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanFlowcellBarcode.
 */
template<class T> Callback_StageRunMgrIPC_ScanFlowcellBarcodePtr
newCallback_StageRunMgrIPC_ScanFlowcellBarcode(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ScanFlowcellBarcode<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanFlowcellBarcode.
 */
template<class T> Callback_StageRunMgrIPC_ScanFlowcellBarcodePtr
newCallback_StageRunMgrIPC_ScanFlowcellBarcode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ScanFlowcellBarcode<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanFlowcellBarcode.
 */
template<class T> Callback_StageRunMgrIPC_ScanFlowcellBarcodePtr
newCallback_StageRunMgrIPC_ScanFlowcellBarcode(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ScanFlowcellBarcode<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanFlowcellBarcode.
 */
template<class T> Callback_StageRunMgrIPC_ScanFlowcellBarcodePtr
newCallback_StageRunMgrIPC_ScanFlowcellBarcode(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ScanFlowcellBarcode<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanFlowcellBarcode.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ScanFlowcellBarcode.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_ScanFlowcellBarcode : public Callback_StageRunMgrIPC_ScanFlowcellBarcode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_ScanFlowcellBarcode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_ScanFlowcellBarcode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanFlowcellBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ScanFlowcellBarcodePtr
newCallback_StageRunMgrIPC_ScanFlowcellBarcode(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ScanFlowcellBarcode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanFlowcellBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ScanFlowcellBarcodePtr
newCallback_StageRunMgrIPC_ScanFlowcellBarcode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ScanFlowcellBarcode<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanFlowcellBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ScanFlowcellBarcodePtr
newCallback_StageRunMgrIPC_ScanFlowcellBarcode(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ScanFlowcellBarcode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanFlowcellBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ScanFlowcellBarcodePtr
newCallback_StageRunMgrIPC_ScanFlowcellBarcode(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ScanFlowcellBarcode<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanReagentKitBarcode.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ScanReagentKitBarcode.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_ScanReagentKitBarcode : public Callback_StageRunMgrIPC_ScanReagentKitBarcode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_ScanReagentKitBarcode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_ScanReagentKitBarcode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanReagentKitBarcode.
 */
template<class T> Callback_StageRunMgrIPC_ScanReagentKitBarcodePtr
newCallback_StageRunMgrIPC_ScanReagentKitBarcode(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ScanReagentKitBarcode<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanReagentKitBarcode.
 */
template<class T> Callback_StageRunMgrIPC_ScanReagentKitBarcodePtr
newCallback_StageRunMgrIPC_ScanReagentKitBarcode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ScanReagentKitBarcode<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanReagentKitBarcode.
 */
template<class T> Callback_StageRunMgrIPC_ScanReagentKitBarcodePtr
newCallback_StageRunMgrIPC_ScanReagentKitBarcode(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ScanReagentKitBarcode<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanReagentKitBarcode.
 */
template<class T> Callback_StageRunMgrIPC_ScanReagentKitBarcodePtr
newCallback_StageRunMgrIPC_ScanReagentKitBarcode(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ScanReagentKitBarcode<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanReagentKitBarcode.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ScanReagentKitBarcode.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_ScanReagentKitBarcode : public Callback_StageRunMgrIPC_ScanReagentKitBarcode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_ScanReagentKitBarcode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_ScanReagentKitBarcode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanReagentKitBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ScanReagentKitBarcodePtr
newCallback_StageRunMgrIPC_ScanReagentKitBarcode(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ScanReagentKitBarcode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanReagentKitBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ScanReagentKitBarcodePtr
newCallback_StageRunMgrIPC_ScanReagentKitBarcode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ScanReagentKitBarcode<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanReagentKitBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ScanReagentKitBarcodePtr
newCallback_StageRunMgrIPC_ScanReagentKitBarcode(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ScanReagentKitBarcode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ScanReagentKitBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ScanReagentKitBarcodePtr
newCallback_StageRunMgrIPC_ScanReagentKitBarcode(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ScanReagentKitBarcode<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_OverrideFlowcellBarcode.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_OverrideFlowcellBarcode.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_OverrideFlowcellBarcode : public Callback_StageRunMgrIPC_OverrideFlowcellBarcode_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_OverrideFlowcellBarcode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_OverrideFlowcellBarcode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_OverrideFlowcellBarcode.
 */
template<class T> Callback_StageRunMgrIPC_OverrideFlowcellBarcodePtr
newCallback_StageRunMgrIPC_OverrideFlowcellBarcode(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_OverrideFlowcellBarcode<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_OverrideFlowcellBarcode.
 */
template<class T> Callback_StageRunMgrIPC_OverrideFlowcellBarcodePtr
newCallback_StageRunMgrIPC_OverrideFlowcellBarcode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_OverrideFlowcellBarcode<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_OverrideFlowcellBarcode.
 */
template<class T> Callback_StageRunMgrIPC_OverrideFlowcellBarcodePtr
newCallback_StageRunMgrIPC_OverrideFlowcellBarcode(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_OverrideFlowcellBarcode<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_OverrideFlowcellBarcode.
 */
template<class T> Callback_StageRunMgrIPC_OverrideFlowcellBarcodePtr
newCallback_StageRunMgrIPC_OverrideFlowcellBarcode(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_OverrideFlowcellBarcode<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_OverrideFlowcellBarcode.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_OverrideFlowcellBarcode.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_OverrideFlowcellBarcode : public Callback_StageRunMgrIPC_OverrideFlowcellBarcode_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_OverrideFlowcellBarcode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_OverrideFlowcellBarcode(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_OverrideFlowcellBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_OverrideFlowcellBarcodePtr
newCallback_StageRunMgrIPC_OverrideFlowcellBarcode(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_OverrideFlowcellBarcode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_OverrideFlowcellBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_OverrideFlowcellBarcodePtr
newCallback_StageRunMgrIPC_OverrideFlowcellBarcode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_OverrideFlowcellBarcode<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_OverrideFlowcellBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_OverrideFlowcellBarcodePtr
newCallback_StageRunMgrIPC_OverrideFlowcellBarcode(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_OverrideFlowcellBarcode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_OverrideFlowcellBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_OverrideFlowcellBarcodePtr
newCallback_StageRunMgrIPC_OverrideFlowcellBarcode(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_OverrideFlowcellBarcode<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendReagentKit.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SendReagentKit.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_SendReagentKit : public Callback_StageRunMgrIPC_SendReagentKit_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_SendReagentKit(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_SendReagentKit(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendReagentKit.
 */
template<class T> Callback_StageRunMgrIPC_SendReagentKitPtr
newCallback_StageRunMgrIPC_SendReagentKit(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SendReagentKit<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendReagentKit.
 */
template<class T> Callback_StageRunMgrIPC_SendReagentKitPtr
newCallback_StageRunMgrIPC_SendReagentKit(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SendReagentKit<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendReagentKit.
 */
template<class T> Callback_StageRunMgrIPC_SendReagentKitPtr
newCallback_StageRunMgrIPC_SendReagentKit(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SendReagentKit<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendReagentKit.
 */
template<class T> Callback_StageRunMgrIPC_SendReagentKitPtr
newCallback_StageRunMgrIPC_SendReagentKit(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SendReagentKit<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendReagentKit.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SendReagentKit.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_SendReagentKit : public Callback_StageRunMgrIPC_SendReagentKit_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_SendReagentKit(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_SendReagentKit(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendReagentKit.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SendReagentKitPtr
newCallback_StageRunMgrIPC_SendReagentKit(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SendReagentKit<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendReagentKit.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SendReagentKitPtr
newCallback_StageRunMgrIPC_SendReagentKit(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SendReagentKit<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendReagentKit.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SendReagentKitPtr
newCallback_StageRunMgrIPC_SendReagentKit(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SendReagentKit<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendReagentKit.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SendReagentKitPtr
newCallback_StageRunMgrIPC_SendReagentKit(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SendReagentKit<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRun.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StartRun.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_StartRun : public Callback_StageRunMgrIPC_StartRun_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_StartRun(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_StartRun(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRun.
 */
template<class T> Callback_StageRunMgrIPC_StartRunPtr
newCallback_StageRunMgrIPC_StartRun(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartRun<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRun.
 */
template<class T> Callback_StageRunMgrIPC_StartRunPtr
newCallback_StageRunMgrIPC_StartRun(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartRun<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRun.
 */
template<class T> Callback_StageRunMgrIPC_StartRunPtr
newCallback_StageRunMgrIPC_StartRun(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartRun<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRun.
 */
template<class T> Callback_StageRunMgrIPC_StartRunPtr
newCallback_StageRunMgrIPC_StartRun(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartRun<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRun.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StartRun.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_StartRun : public Callback_StageRunMgrIPC_StartRun_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_StartRun(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_StartRun(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRun.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartRunPtr
newCallback_StageRunMgrIPC_StartRun(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartRun<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRun.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartRunPtr
newCallback_StageRunMgrIPC_StartRun(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartRun<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRun.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartRunPtr
newCallback_StageRunMgrIPC_StartRun(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartRun<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRun.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartRunPtr
newCallback_StageRunMgrIPC_StartRun(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartRun<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_PauseScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_PauseScript.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_PauseScript : public Callback_StageRunMgrIPC_PauseScript_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_PauseScript(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_PauseScript(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_PauseScript.
 */
template<class T> Callback_StageRunMgrIPC_PauseScriptPtr
newCallback_StageRunMgrIPC_PauseScript(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_PauseScript<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_PauseScript.
 */
template<class T> Callback_StageRunMgrIPC_PauseScriptPtr
newCallback_StageRunMgrIPC_PauseScript(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_PauseScript<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_PauseScript.
 */
template<class T> Callback_StageRunMgrIPC_PauseScriptPtr
newCallback_StageRunMgrIPC_PauseScript(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_PauseScript<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_PauseScript.
 */
template<class T> Callback_StageRunMgrIPC_PauseScriptPtr
newCallback_StageRunMgrIPC_PauseScript(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_PauseScript<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_PauseScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_PauseScript.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_PauseScript : public Callback_StageRunMgrIPC_PauseScript_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_PauseScript(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_PauseScript(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_PauseScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_PauseScriptPtr
newCallback_StageRunMgrIPC_PauseScript(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_PauseScript<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_PauseScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_PauseScriptPtr
newCallback_StageRunMgrIPC_PauseScript(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_PauseScript<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_PauseScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_PauseScriptPtr
newCallback_StageRunMgrIPC_PauseScript(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_PauseScript<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_PauseScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_PauseScriptPtr
newCallback_StageRunMgrIPC_PauseScript(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_PauseScript<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ResumeScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ResumeScript.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_ResumeScript : public Callback_StageRunMgrIPC_ResumeScript_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_ResumeScript(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_ResumeScript(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ResumeScript.
 */
template<class T> Callback_StageRunMgrIPC_ResumeScriptPtr
newCallback_StageRunMgrIPC_ResumeScript(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ResumeScript<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ResumeScript.
 */
template<class T> Callback_StageRunMgrIPC_ResumeScriptPtr
newCallback_StageRunMgrIPC_ResumeScript(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ResumeScript<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ResumeScript.
 */
template<class T> Callback_StageRunMgrIPC_ResumeScriptPtr
newCallback_StageRunMgrIPC_ResumeScript(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ResumeScript<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ResumeScript.
 */
template<class T> Callback_StageRunMgrIPC_ResumeScriptPtr
newCallback_StageRunMgrIPC_ResumeScript(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ResumeScript<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ResumeScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ResumeScript.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_ResumeScript : public Callback_StageRunMgrIPC_ResumeScript_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_ResumeScript(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_ResumeScript(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ResumeScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ResumeScriptPtr
newCallback_StageRunMgrIPC_ResumeScript(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ResumeScript<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ResumeScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ResumeScriptPtr
newCallback_StageRunMgrIPC_ResumeScript(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ResumeScript<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ResumeScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ResumeScriptPtr
newCallback_StageRunMgrIPC_ResumeScript(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ResumeScript<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ResumeScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ResumeScriptPtr
newCallback_StageRunMgrIPC_ResumeScript(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ResumeScript<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StopScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StopScript.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_StopScript : public Callback_StageRunMgrIPC_StopScript_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_StopScript(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_StopScript(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StopScript.
 */
template<class T> Callback_StageRunMgrIPC_StopScriptPtr
newCallback_StageRunMgrIPC_StopScript(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StopScript<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StopScript.
 */
template<class T> Callback_StageRunMgrIPC_StopScriptPtr
newCallback_StageRunMgrIPC_StopScript(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StopScript<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StopScript.
 */
template<class T> Callback_StageRunMgrIPC_StopScriptPtr
newCallback_StageRunMgrIPC_StopScript(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StopScript<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StopScript.
 */
template<class T> Callback_StageRunMgrIPC_StopScriptPtr
newCallback_StageRunMgrIPC_StopScript(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StopScript<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StopScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StopScript.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_StopScript : public Callback_StageRunMgrIPC_StopScript_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_StopScript(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_StopScript(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StopScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StopScriptPtr
newCallback_StageRunMgrIPC_StopScript(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StopScript<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StopScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StopScriptPtr
newCallback_StageRunMgrIPC_StopScript(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StopScript<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StopScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StopScriptPtr
newCallback_StageRunMgrIPC_StopScript(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StopScript<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StopScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StopScriptPtr
newCallback_StageRunMgrIPC_StopScript(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StopScript<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_AbortScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_AbortScript.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_AbortScript : public Callback_StageRunMgrIPC_AbortScript_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_AbortScript(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_AbortScript(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_AbortScript.
 */
template<class T> Callback_StageRunMgrIPC_AbortScriptPtr
newCallback_StageRunMgrIPC_AbortScript(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_AbortScript<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_AbortScript.
 */
template<class T> Callback_StageRunMgrIPC_AbortScriptPtr
newCallback_StageRunMgrIPC_AbortScript(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_AbortScript<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_AbortScript.
 */
template<class T> Callback_StageRunMgrIPC_AbortScriptPtr
newCallback_StageRunMgrIPC_AbortScript(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_AbortScript<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_AbortScript.
 */
template<class T> Callback_StageRunMgrIPC_AbortScriptPtr
newCallback_StageRunMgrIPC_AbortScript(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_AbortScript<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_AbortScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_AbortScript.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_AbortScript : public Callback_StageRunMgrIPC_AbortScript_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_AbortScript(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_AbortScript(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_AbortScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_AbortScriptPtr
newCallback_StageRunMgrIPC_AbortScript(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_AbortScript<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_AbortScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_AbortScriptPtr
newCallback_StageRunMgrIPC_AbortScript(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_AbortScript<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_AbortScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_AbortScriptPtr
newCallback_StageRunMgrIPC_AbortScript(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_AbortScript<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_AbortScript.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_AbortScriptPtr
newCallback_StageRunMgrIPC_AbortScript(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_AbortScript<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_RunScriptNow.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_RunScriptNow.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_RunScriptNow : public Callback_StageRunMgrIPC_RunScriptNow_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_StageRunMgrIPC_RunScriptNow(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_RunScriptNow(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_RunScriptNow.
 */
template<class T> Callback_StageRunMgrIPC_RunScriptNowPtr
newCallback_StageRunMgrIPC_RunScriptNow(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_RunScriptNow<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_RunScriptNow.
 */
template<class T> Callback_StageRunMgrIPC_RunScriptNowPtr
newCallback_StageRunMgrIPC_RunScriptNow(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_RunScriptNow<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_RunScriptNow.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_RunScriptNow.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_RunScriptNow : public Callback_StageRunMgrIPC_RunScriptNow_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_StageRunMgrIPC_RunScriptNow(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_RunScriptNow(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_RunScriptNow.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_RunScriptNowPtr
newCallback_StageRunMgrIPC_RunScriptNow(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_RunScriptNow<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_RunScriptNow.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_RunScriptNowPtr
newCallback_StageRunMgrIPC_RunScriptNow(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_RunScriptNow<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetScriptRunInfo.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetScriptRunInfo.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_GetScriptRunInfo : public Callback_StageRunMgrIPC_GetScriptRunInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ScriptRunInfo&);

    CallbackNC_StageRunMgrIPC_GetScriptRunInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        ScriptRunInfo ret;
        try
        {
            ret = proxy->end_GetScriptRunInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetScriptRunInfo.
 */
template<class T> Callback_StageRunMgrIPC_GetScriptRunInfoPtr
newCallback_StageRunMgrIPC_GetScriptRunInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const ScriptRunInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetScriptRunInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetScriptRunInfo.
 */
template<class T> Callback_StageRunMgrIPC_GetScriptRunInfoPtr
newCallback_StageRunMgrIPC_GetScriptRunInfo(T* instance, void (T::*cb)(const ScriptRunInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetScriptRunInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetScriptRunInfo.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetScriptRunInfo.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_GetScriptRunInfo : public Callback_StageRunMgrIPC_GetScriptRunInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ScriptRunInfo&, const CT&);

    Callback_StageRunMgrIPC_GetScriptRunInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        ScriptRunInfo ret;
        try
        {
            ret = proxy->end_GetScriptRunInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetScriptRunInfo.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetScriptRunInfoPtr
newCallback_StageRunMgrIPC_GetScriptRunInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const ScriptRunInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetScriptRunInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetScriptRunInfo.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetScriptRunInfoPtr
newCallback_StageRunMgrIPC_GetScriptRunInfo(T* instance, void (T::*cb)(const ScriptRunInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetScriptRunInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetScriptMessages.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetScriptMessages.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_GetScriptMessages : public Callback_StageRunMgrIPC_GetScriptMessages_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const MessageArray&);

    CallbackNC_StageRunMgrIPC_GetScriptMessages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        MessageArray ret;
        try
        {
            ret = proxy->end_GetScriptMessages(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetScriptMessages.
 */
template<class T> Callback_StageRunMgrIPC_GetScriptMessagesPtr
newCallback_StageRunMgrIPC_GetScriptMessages(const IceUtil::Handle<T>& instance, void (T::*cb)(const MessageArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetScriptMessages<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetScriptMessages.
 */
template<class T> Callback_StageRunMgrIPC_GetScriptMessagesPtr
newCallback_StageRunMgrIPC_GetScriptMessages(T* instance, void (T::*cb)(const MessageArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetScriptMessages<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetScriptMessages.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetScriptMessages.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_GetScriptMessages : public Callback_StageRunMgrIPC_GetScriptMessages_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const MessageArray&, const CT&);

    Callback_StageRunMgrIPC_GetScriptMessages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        MessageArray ret;
        try
        {
            ret = proxy->end_GetScriptMessages(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetScriptMessages.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetScriptMessagesPtr
newCallback_StageRunMgrIPC_GetScriptMessages(const IceUtil::Handle<T>& instance, void (T::*cb)(const MessageArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetScriptMessages<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetScriptMessages.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetScriptMessagesPtr
newCallback_StageRunMgrIPC_GetScriptMessages(T* instance, void (T::*cb)(const MessageArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetScriptMessages<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupScriptFile.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetupScriptFile.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_SetupScriptFile : public Callback_StageRunMgrIPC_SetupScriptFile_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_SetupScriptFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_SetupScriptFile(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupScriptFile.
 */
template<class T> Callback_StageRunMgrIPC_SetupScriptFilePtr
newCallback_StageRunMgrIPC_SetupScriptFile(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetupScriptFile<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupScriptFile.
 */
template<class T> Callback_StageRunMgrIPC_SetupScriptFilePtr
newCallback_StageRunMgrIPC_SetupScriptFile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetupScriptFile<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupScriptFile.
 */
template<class T> Callback_StageRunMgrIPC_SetupScriptFilePtr
newCallback_StageRunMgrIPC_SetupScriptFile(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetupScriptFile<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupScriptFile.
 */
template<class T> Callback_StageRunMgrIPC_SetupScriptFilePtr
newCallback_StageRunMgrIPC_SetupScriptFile(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetupScriptFile<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupScriptFile.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetupScriptFile.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_SetupScriptFile : public Callback_StageRunMgrIPC_SetupScriptFile_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_SetupScriptFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_SetupScriptFile(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupScriptFile.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetupScriptFilePtr
newCallback_StageRunMgrIPC_SetupScriptFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetupScriptFile<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupScriptFile.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetupScriptFilePtr
newCallback_StageRunMgrIPC_SetupScriptFile(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetupScriptFile<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupScriptFile.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetupScriptFilePtr
newCallback_StageRunMgrIPC_SetupScriptFile(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetupScriptFile<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupScriptFile.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetupScriptFilePtr
newCallback_StageRunMgrIPC_SetupScriptFile(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetupScriptFile<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetQCValues.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetQCValues.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_GetQCValues : public Callback_StageRunMgrIPC_GetQCValues_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const QCDataValues&);

    CallbackNC_StageRunMgrIPC_GetQCValues(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        QCDataValues ret;
        try
        {
            ret = proxy->end_GetQCValues(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetQCValues.
 */
template<class T> Callback_StageRunMgrIPC_GetQCValuesPtr
newCallback_StageRunMgrIPC_GetQCValues(const IceUtil::Handle<T>& instance, void (T::*cb)(const QCDataValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetQCValues<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetQCValues.
 */
template<class T> Callback_StageRunMgrIPC_GetQCValuesPtr
newCallback_StageRunMgrIPC_GetQCValues(T* instance, void (T::*cb)(const QCDataValues&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetQCValues<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetQCValues.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetQCValues.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_GetQCValues : public Callback_StageRunMgrIPC_GetQCValues_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const QCDataValues&, const CT&);

    Callback_StageRunMgrIPC_GetQCValues(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        QCDataValues ret;
        try
        {
            ret = proxy->end_GetQCValues(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetQCValues.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetQCValuesPtr
newCallback_StageRunMgrIPC_GetQCValues(const IceUtil::Handle<T>& instance, void (T::*cb)(const QCDataValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetQCValues<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetQCValues.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetQCValuesPtr
newCallback_StageRunMgrIPC_GetQCValues(T* instance, void (T::*cb)(const QCDataValues&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetQCValues<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendSampleId.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SendSampleId.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_SendSampleId : public Callback_StageRunMgrIPC_SendSampleId_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_SendSampleId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_SendSampleId(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)();
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendSampleId.
 */
template<class T> Callback_StageRunMgrIPC_SendSampleIdPtr
newCallback_StageRunMgrIPC_SendSampleId(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SendSampleId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendSampleId.
 */
template<class T> Callback_StageRunMgrIPC_SendSampleIdPtr
newCallback_StageRunMgrIPC_SendSampleId(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SendSampleId<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendSampleId.
 */
template<class T> Callback_StageRunMgrIPC_SendSampleIdPtr
newCallback_StageRunMgrIPC_SendSampleId(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SendSampleId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendSampleId.
 */
template<class T> Callback_StageRunMgrIPC_SendSampleIdPtr
newCallback_StageRunMgrIPC_SendSampleId(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SendSampleId<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendSampleId.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SendSampleId.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_SendSampleId : public Callback_StageRunMgrIPC_SendSampleId_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_SendSampleId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        try
        {
            proxy->end_SendSampleId(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendSampleId.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SendSampleIdPtr
newCallback_StageRunMgrIPC_SendSampleId(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SendSampleId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendSampleId.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SendSampleIdPtr
newCallback_StageRunMgrIPC_SendSampleId(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SendSampleId<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendSampleId.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SendSampleIdPtr
newCallback_StageRunMgrIPC_SendSampleId(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SendSampleId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendSampleId.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SendSampleIdPtr
newCallback_StageRunMgrIPC_SendSampleId(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SendSampleId<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetExperimentInfo.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetExperimentInfo.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_GetExperimentInfo : public Callback_StageRunMgrIPC_GetExperimentInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ExperimentInfo&);

    CallbackNC_StageRunMgrIPC_GetExperimentInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        ExperimentInfo ret;
        try
        {
            ret = proxy->end_GetExperimentInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetExperimentInfo.
 */
template<class T> Callback_StageRunMgrIPC_GetExperimentInfoPtr
newCallback_StageRunMgrIPC_GetExperimentInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const ExperimentInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetExperimentInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetExperimentInfo.
 */
template<class T> Callback_StageRunMgrIPC_GetExperimentInfoPtr
newCallback_StageRunMgrIPC_GetExperimentInfo(T* instance, void (T::*cb)(const ExperimentInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetExperimentInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetExperimentInfo.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetExperimentInfo.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_GetExperimentInfo : public Callback_StageRunMgrIPC_GetExperimentInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ExperimentInfo&, const CT&);

    Callback_StageRunMgrIPC_GetExperimentInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        ExperimentInfo ret;
        try
        {
            ret = proxy->end_GetExperimentInfo(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetExperimentInfo.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetExperimentInfoPtr
newCallback_StageRunMgrIPC_GetExperimentInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const ExperimentInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetExperimentInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetExperimentInfo.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetExperimentInfoPtr
newCallback_StageRunMgrIPC_GetExperimentInfo(T* instance, void (T::*cb)(const ExperimentInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetExperimentInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_DownloadScriptFile.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_DownloadScriptFile.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_DownloadScriptFile : public Callback_StageRunMgrIPC_DownloadScriptFile_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&, const ::std::string&, const ::std::string&);

    CallbackNC_StageRunMgrIPC_DownloadScriptFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_workFlowScript;
        ::std::string iceP_imageScript;
        ::std::string iceP_biochemistryScript;
        try
        {
            proxy->end_DownloadScriptFile(iceP_workFlowScript, iceP_imageScript, iceP_biochemistryScript, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_workFlowScript, iceP_imageScript, iceP_biochemistryScript);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_DownloadScriptFile.
 */
template<class T> Callback_StageRunMgrIPC_DownloadScriptFilePtr
newCallback_StageRunMgrIPC_DownloadScriptFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_DownloadScriptFile<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_DownloadScriptFile.
 */
template<class T> Callback_StageRunMgrIPC_DownloadScriptFilePtr
newCallback_StageRunMgrIPC_DownloadScriptFile(T* instance, void (T::*cb)(const ::std::string&, const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_DownloadScriptFile<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_DownloadScriptFile.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_DownloadScriptFile.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_DownloadScriptFile : public Callback_StageRunMgrIPC_DownloadScriptFile_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const ::std::string&, const ::std::string&, const CT&);

    Callback_StageRunMgrIPC_DownloadScriptFile(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_workFlowScript;
        ::std::string iceP_imageScript;
        ::std::string iceP_biochemistryScript;
        try
        {
            proxy->end_DownloadScriptFile(iceP_workFlowScript, iceP_imageScript, iceP_biochemistryScript, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_workFlowScript, iceP_imageScript, iceP_biochemistryScript, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_DownloadScriptFile.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_DownloadScriptFilePtr
newCallback_StageRunMgrIPC_DownloadScriptFile(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_DownloadScriptFile<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_DownloadScriptFile.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_DownloadScriptFilePtr
newCallback_StageRunMgrIPC_DownloadScriptFile(T* instance, void (T::*cb)(const ::std::string&, const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_DownloadScriptFile<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_UIOperation.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_UIOperation.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_UIOperation : public Callback_StageRunMgrIPC_UIOperation_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_UIOperation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_UIOperation.
 */
template<class T> Callback_StageRunMgrIPC_UIOperationPtr
newCallback_StageRunMgrIPC_UIOperation(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_UIOperation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_UIOperation.
 */
template<class T> Callback_StageRunMgrIPC_UIOperationPtr
newCallback_StageRunMgrIPC_UIOperation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_UIOperation<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_UIOperation.
 */
template<class T> Callback_StageRunMgrIPC_UIOperationPtr
newCallback_StageRunMgrIPC_UIOperation(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_UIOperation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_UIOperation.
 */
template<class T> Callback_StageRunMgrIPC_UIOperationPtr
newCallback_StageRunMgrIPC_UIOperation(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_UIOperation<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_UIOperation.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_UIOperation.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_UIOperation : public Callback_StageRunMgrIPC_UIOperation_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_UIOperation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_UIOperation.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_UIOperationPtr
newCallback_StageRunMgrIPC_UIOperation(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_UIOperation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_UIOperation.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_UIOperationPtr
newCallback_StageRunMgrIPC_UIOperation(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_UIOperation<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_UIOperation.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_UIOperationPtr
newCallback_StageRunMgrIPC_UIOperation(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_UIOperation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_UIOperation.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_UIOperationPtr
newCallback_StageRunMgrIPC_UIOperation(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_UIOperation<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetAlarmMessages.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetAlarmMessages.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_GetAlarmMessages : public Callback_StageRunMgrIPC_GetAlarmMessages_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const AlarmMessageList&);

    CallbackNC_StageRunMgrIPC_GetAlarmMessages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        AlarmMessageList ret;
        try
        {
            ret = proxy->end_GetAlarmMessages(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetAlarmMessages.
 */
template<class T> Callback_StageRunMgrIPC_GetAlarmMessagesPtr
newCallback_StageRunMgrIPC_GetAlarmMessages(const IceUtil::Handle<T>& instance, void (T::*cb)(const AlarmMessageList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetAlarmMessages<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetAlarmMessages.
 */
template<class T> Callback_StageRunMgrIPC_GetAlarmMessagesPtr
newCallback_StageRunMgrIPC_GetAlarmMessages(T* instance, void (T::*cb)(const AlarmMessageList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetAlarmMessages<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetAlarmMessages.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetAlarmMessages.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_GetAlarmMessages : public Callback_StageRunMgrIPC_GetAlarmMessages_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const AlarmMessageList&, const CT&);

    Callback_StageRunMgrIPC_GetAlarmMessages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        AlarmMessageList ret;
        try
        {
            ret = proxy->end_GetAlarmMessages(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetAlarmMessages.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetAlarmMessagesPtr
newCallback_StageRunMgrIPC_GetAlarmMessages(const IceUtil::Handle<T>& instance, void (T::*cb)(const AlarmMessageList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetAlarmMessages<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetAlarmMessages.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetAlarmMessagesPtr
newCallback_StageRunMgrIPC_GetAlarmMessages(T* instance, void (T::*cb)(const AlarmMessageList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetAlarmMessages<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetLogMessages.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetLogMessages.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_GetLogMessages : public Callback_StageRunMgrIPC_GetLogMessages_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LogMessageList&);

    CallbackNC_StageRunMgrIPC_GetLogMessages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        LogMessageList ret;
        try
        {
            ret = proxy->end_GetLogMessages(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetLogMessages.
 */
template<class T> Callback_StageRunMgrIPC_GetLogMessagesPtr
newCallback_StageRunMgrIPC_GetLogMessages(const IceUtil::Handle<T>& instance, void (T::*cb)(const LogMessageList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetLogMessages<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetLogMessages.
 */
template<class T> Callback_StageRunMgrIPC_GetLogMessagesPtr
newCallback_StageRunMgrIPC_GetLogMessages(T* instance, void (T::*cb)(const LogMessageList&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetLogMessages<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetLogMessages.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetLogMessages.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_GetLogMessages : public Callback_StageRunMgrIPC_GetLogMessages_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LogMessageList&, const CT&);

    Callback_StageRunMgrIPC_GetLogMessages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        LogMessageList ret;
        try
        {
            ret = proxy->end_GetLogMessages(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetLogMessages.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetLogMessagesPtr
newCallback_StageRunMgrIPC_GetLogMessages(const IceUtil::Handle<T>& instance, void (T::*cb)(const LogMessageList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetLogMessages<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetLogMessages.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetLogMessagesPtr
newCallback_StageRunMgrIPC_GetLogMessages(T* instance, void (T::*cb)(const LogMessageList&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetLogMessages<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ClearAlarmMessages.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ClearAlarmMessages.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_ClearAlarmMessages : public Callback_StageRunMgrIPC_ClearAlarmMessages_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_ClearAlarmMessages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ClearAlarmMessages.
 */
template<class T> Callback_StageRunMgrIPC_ClearAlarmMessagesPtr
newCallback_StageRunMgrIPC_ClearAlarmMessages(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ClearAlarmMessages<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ClearAlarmMessages.
 */
template<class T> Callback_StageRunMgrIPC_ClearAlarmMessagesPtr
newCallback_StageRunMgrIPC_ClearAlarmMessages(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ClearAlarmMessages<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ClearAlarmMessages.
 */
template<class T> Callback_StageRunMgrIPC_ClearAlarmMessagesPtr
newCallback_StageRunMgrIPC_ClearAlarmMessages(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ClearAlarmMessages<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ClearAlarmMessages.
 */
template<class T> Callback_StageRunMgrIPC_ClearAlarmMessagesPtr
newCallback_StageRunMgrIPC_ClearAlarmMessages(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ClearAlarmMessages<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ClearAlarmMessages.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ClearAlarmMessages.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_ClearAlarmMessages : public Callback_StageRunMgrIPC_ClearAlarmMessages_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_ClearAlarmMessages(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ClearAlarmMessages.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ClearAlarmMessagesPtr
newCallback_StageRunMgrIPC_ClearAlarmMessages(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ClearAlarmMessages<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ClearAlarmMessages.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ClearAlarmMessagesPtr
newCallback_StageRunMgrIPC_ClearAlarmMessages(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ClearAlarmMessages<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ClearAlarmMessages.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ClearAlarmMessagesPtr
newCallback_StageRunMgrIPC_ClearAlarmMessages(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ClearAlarmMessages<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ClearAlarmMessages.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ClearAlarmMessagesPtr
newCallback_StageRunMgrIPC_ClearAlarmMessages(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ClearAlarmMessages<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ReagentNeedle.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ReagentNeedle.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_ReagentNeedle : public Callback_StageRunMgrIPC_ReagentNeedle_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_ReagentNeedle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ReagentNeedle.
 */
template<class T> Callback_StageRunMgrIPC_ReagentNeedlePtr
newCallback_StageRunMgrIPC_ReagentNeedle(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ReagentNeedle<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ReagentNeedle.
 */
template<class T> Callback_StageRunMgrIPC_ReagentNeedlePtr
newCallback_StageRunMgrIPC_ReagentNeedle(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ReagentNeedle<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ReagentNeedle.
 */
template<class T> Callback_StageRunMgrIPC_ReagentNeedlePtr
newCallback_StageRunMgrIPC_ReagentNeedle(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ReagentNeedle<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ReagentNeedle.
 */
template<class T> Callback_StageRunMgrIPC_ReagentNeedlePtr
newCallback_StageRunMgrIPC_ReagentNeedle(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_ReagentNeedle<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_ReagentNeedle.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_ReagentNeedle.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_ReagentNeedle : public Callback_StageRunMgrIPC_ReagentNeedle_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_ReagentNeedle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ReagentNeedle.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ReagentNeedlePtr
newCallback_StageRunMgrIPC_ReagentNeedle(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ReagentNeedle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ReagentNeedle.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ReagentNeedlePtr
newCallback_StageRunMgrIPC_ReagentNeedle(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ReagentNeedle<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ReagentNeedle.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ReagentNeedlePtr
newCallback_StageRunMgrIPC_ReagentNeedle(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ReagentNeedle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_ReagentNeedle.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_ReagentNeedlePtr
newCallback_StageRunMgrIPC_ReagentNeedle(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_ReagentNeedle<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendExperimentType.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SendExperimentType.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_SendExperimentType : public Callback_StageRunMgrIPC_SendExperimentType_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_SendExperimentType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendExperimentType.
 */
template<class T> Callback_StageRunMgrIPC_SendExperimentTypePtr
newCallback_StageRunMgrIPC_SendExperimentType(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SendExperimentType<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendExperimentType.
 */
template<class T> Callback_StageRunMgrIPC_SendExperimentTypePtr
newCallback_StageRunMgrIPC_SendExperimentType(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SendExperimentType<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendExperimentType.
 */
template<class T> Callback_StageRunMgrIPC_SendExperimentTypePtr
newCallback_StageRunMgrIPC_SendExperimentType(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SendExperimentType<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendExperimentType.
 */
template<class T> Callback_StageRunMgrIPC_SendExperimentTypePtr
newCallback_StageRunMgrIPC_SendExperimentType(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SendExperimentType<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendExperimentType.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SendExperimentType.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_SendExperimentType : public Callback_StageRunMgrIPC_SendExperimentType_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_SendExperimentType(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendExperimentType.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SendExperimentTypePtr
newCallback_StageRunMgrIPC_SendExperimentType(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SendExperimentType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendExperimentType.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SendExperimentTypePtr
newCallback_StageRunMgrIPC_SendExperimentType(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SendExperimentType<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendExperimentType.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SendExperimentTypePtr
newCallback_StageRunMgrIPC_SendExperimentType(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SendExperimentType<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SendExperimentType.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SendExperimentTypePtr
newCallback_StageRunMgrIPC_SendExperimentType(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SendExperimentType<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBuzzerVolume.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetBuzzerVolume.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_SetBuzzerVolume : public Callback_StageRunMgrIPC_SetBuzzerVolume_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_SetBuzzerVolume(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBuzzerVolume.
 */
template<class T> Callback_StageRunMgrIPC_SetBuzzerVolumePtr
newCallback_StageRunMgrIPC_SetBuzzerVolume(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetBuzzerVolume<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBuzzerVolume.
 */
template<class T> Callback_StageRunMgrIPC_SetBuzzerVolumePtr
newCallback_StageRunMgrIPC_SetBuzzerVolume(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetBuzzerVolume<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBuzzerVolume.
 */
template<class T> Callback_StageRunMgrIPC_SetBuzzerVolumePtr
newCallback_StageRunMgrIPC_SetBuzzerVolume(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetBuzzerVolume<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBuzzerVolume.
 */
template<class T> Callback_StageRunMgrIPC_SetBuzzerVolumePtr
newCallback_StageRunMgrIPC_SetBuzzerVolume(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetBuzzerVolume<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBuzzerVolume.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetBuzzerVolume.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_SetBuzzerVolume : public Callback_StageRunMgrIPC_SetBuzzerVolume_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_SetBuzzerVolume(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBuzzerVolume.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetBuzzerVolumePtr
newCallback_StageRunMgrIPC_SetBuzzerVolume(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetBuzzerVolume<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBuzzerVolume.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetBuzzerVolumePtr
newCallback_StageRunMgrIPC_SetBuzzerVolume(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetBuzzerVolume<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBuzzerVolume.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetBuzzerVolumePtr
newCallback_StageRunMgrIPC_SetBuzzerVolume(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetBuzzerVolume<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBuzzerVolume.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetBuzzerVolumePtr
newCallback_StageRunMgrIPC_SetBuzzerVolume(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetBuzzerVolume<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetSequenceTypes.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetSequenceTypes.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_GetSequenceTypes : public Callback_StageRunMgrIPC_GetSequenceTypes_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const SequenceTypes&);

    CallbackNC_StageRunMgrIPC_GetSequenceTypes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        SequenceTypes ret;
        try
        {
            ret = proxy->end_GetSequenceTypes(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetSequenceTypes.
 */
template<class T> Callback_StageRunMgrIPC_GetSequenceTypesPtr
newCallback_StageRunMgrIPC_GetSequenceTypes(const IceUtil::Handle<T>& instance, void (T::*cb)(const SequenceTypes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetSequenceTypes<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetSequenceTypes.
 */
template<class T> Callback_StageRunMgrIPC_GetSequenceTypesPtr
newCallback_StageRunMgrIPC_GetSequenceTypes(T* instance, void (T::*cb)(const SequenceTypes&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetSequenceTypes<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetSequenceTypes.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetSequenceTypes.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_GetSequenceTypes : public Callback_StageRunMgrIPC_GetSequenceTypes_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const SequenceTypes&, const CT&);

    Callback_StageRunMgrIPC_GetSequenceTypes(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        SequenceTypes ret;
        try
        {
            ret = proxy->end_GetSequenceTypes(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetSequenceTypes.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetSequenceTypesPtr
newCallback_StageRunMgrIPC_GetSequenceTypes(const IceUtil::Handle<T>& instance, void (T::*cb)(const SequenceTypes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetSequenceTypes<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetSequenceTypes.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetSequenceTypesPtr
newCallback_StageRunMgrIPC_GetSequenceTypes(T* instance, void (T::*cb)(const SequenceTypes&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetSequenceTypes<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetClearData.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetClearData.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_SetClearData : public Callback_StageRunMgrIPC_SetClearData_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_StageRunMgrIPC_SetClearData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_SetClearData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetClearData.
 */
template<class T> Callback_StageRunMgrIPC_SetClearDataPtr
newCallback_StageRunMgrIPC_SetClearData(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetClearData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetClearData.
 */
template<class T> Callback_StageRunMgrIPC_SetClearDataPtr
newCallback_StageRunMgrIPC_SetClearData(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetClearData<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetClearData.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetClearData.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_SetClearData : public Callback_StageRunMgrIPC_SetClearData_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_StageRunMgrIPC_SetClearData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_SetClearData(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetClearData.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetClearDataPtr
newCallback_StageRunMgrIPC_SetClearData(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetClearData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetClearData.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetClearDataPtr
newCallback_StageRunMgrIPC_SetClearData(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetClearData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRunLength.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StartRunLength.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_StartRunLength : public Callback_StageRunMgrIPC_StartRunLength_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_StartRunLength(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRunLength.
 */
template<class T> Callback_StageRunMgrIPC_StartRunLengthPtr
newCallback_StageRunMgrIPC_StartRunLength(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartRunLength<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRunLength.
 */
template<class T> Callback_StageRunMgrIPC_StartRunLengthPtr
newCallback_StageRunMgrIPC_StartRunLength(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartRunLength<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRunLength.
 */
template<class T> Callback_StageRunMgrIPC_StartRunLengthPtr
newCallback_StageRunMgrIPC_StartRunLength(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartRunLength<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRunLength.
 */
template<class T> Callback_StageRunMgrIPC_StartRunLengthPtr
newCallback_StageRunMgrIPC_StartRunLength(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartRunLength<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRunLength.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StartRunLength.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_StartRunLength : public Callback_StageRunMgrIPC_StartRunLength_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_StartRunLength(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRunLength.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartRunLengthPtr
newCallback_StageRunMgrIPC_StartRunLength(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartRunLength<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRunLength.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartRunLengthPtr
newCallback_StageRunMgrIPC_StartRunLength(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartRunLength<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRunLength.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartRunLengthPtr
newCallback_StageRunMgrIPC_StartRunLength(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartRunLength<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartRunLength.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartRunLengthPtr
newCallback_StageRunMgrIPC_StartRunLength(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartRunLength<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupRunInfo.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetupRunInfo.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_SetupRunInfo : public Callback_StageRunMgrIPC_SetupRunInfo_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_SetupRunInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupRunInfo.
 */
template<class T> Callback_StageRunMgrIPC_SetupRunInfoPtr
newCallback_StageRunMgrIPC_SetupRunInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetupRunInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupRunInfo.
 */
template<class T> Callback_StageRunMgrIPC_SetupRunInfoPtr
newCallback_StageRunMgrIPC_SetupRunInfo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetupRunInfo<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupRunInfo.
 */
template<class T> Callback_StageRunMgrIPC_SetupRunInfoPtr
newCallback_StageRunMgrIPC_SetupRunInfo(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetupRunInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupRunInfo.
 */
template<class T> Callback_StageRunMgrIPC_SetupRunInfoPtr
newCallback_StageRunMgrIPC_SetupRunInfo(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetupRunInfo<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupRunInfo.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetupRunInfo.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_SetupRunInfo : public Callback_StageRunMgrIPC_SetupRunInfo_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_SetupRunInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupRunInfo.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetupRunInfoPtr
newCallback_StageRunMgrIPC_SetupRunInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetupRunInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupRunInfo.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetupRunInfoPtr
newCallback_StageRunMgrIPC_SetupRunInfo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetupRunInfo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupRunInfo.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetupRunInfoPtr
newCallback_StageRunMgrIPC_SetupRunInfo(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetupRunInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetupRunInfo.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetupRunInfoPtr
newCallback_StageRunMgrIPC_SetupRunInfo(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetupRunInfo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_MotorMove.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_MotorMove.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_MotorMove : public Callback_StageRunMgrIPC_MotorMove_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_MotorMove(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_MotorMove.
 */
template<class T> Callback_StageRunMgrIPC_MotorMovePtr
newCallback_StageRunMgrIPC_MotorMove(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_MotorMove<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_MotorMove.
 */
template<class T> Callback_StageRunMgrIPC_MotorMovePtr
newCallback_StageRunMgrIPC_MotorMove(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_MotorMove<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_MotorMove.
 */
template<class T> Callback_StageRunMgrIPC_MotorMovePtr
newCallback_StageRunMgrIPC_MotorMove(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_MotorMove<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_MotorMove.
 */
template<class T> Callback_StageRunMgrIPC_MotorMovePtr
newCallback_StageRunMgrIPC_MotorMove(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_MotorMove<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_MotorMove.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_MotorMove.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_MotorMove : public Callback_StageRunMgrIPC_MotorMove_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_MotorMove(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_MotorMove.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_MotorMovePtr
newCallback_StageRunMgrIPC_MotorMove(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_MotorMove<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_MotorMove.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_MotorMovePtr
newCallback_StageRunMgrIPC_MotorMove(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_MotorMove<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_MotorMove.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_MotorMovePtr
newCallback_StageRunMgrIPC_MotorMove(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_MotorMove<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_MotorMove.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_MotorMovePtr
newCallback_StageRunMgrIPC_MotorMove(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_MotorMove<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_Authenicate.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_Authenicate.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_Authenicate : public Callback_StageRunMgrIPC_Authenicate_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const LoginedInfo&);

    CallbackNC_StageRunMgrIPC_Authenicate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        LoginedInfo ret;
        try
        {
            ret = proxy->end_Authenicate(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_Authenicate.
 */
template<class T> Callback_StageRunMgrIPC_AuthenicatePtr
newCallback_StageRunMgrIPC_Authenicate(const IceUtil::Handle<T>& instance, void (T::*cb)(const LoginedInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_Authenicate<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_Authenicate.
 */
template<class T> Callback_StageRunMgrIPC_AuthenicatePtr
newCallback_StageRunMgrIPC_Authenicate(T* instance, void (T::*cb)(const LoginedInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_Authenicate<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_Authenicate.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_Authenicate.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_Authenicate : public Callback_StageRunMgrIPC_Authenicate_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const LoginedInfo&, const CT&);

    Callback_StageRunMgrIPC_Authenicate(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        LoginedInfo ret;
        try
        {
            ret = proxy->end_Authenicate(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_Authenicate.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_AuthenicatePtr
newCallback_StageRunMgrIPC_Authenicate(const IceUtil::Handle<T>& instance, void (T::*cb)(const LoginedInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_Authenicate<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_Authenicate.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_AuthenicatePtr
newCallback_StageRunMgrIPC_Authenicate(T* instance, void (T::*cb)(const LoginedInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_Authenicate<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetLanguage.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetLanguage.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_GetLanguage : public Callback_StageRunMgrIPC_GetLanguage_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_StageRunMgrIPC_GetLanguage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_GetLanguage(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetLanguage.
 */
template<class T> Callback_StageRunMgrIPC_GetLanguagePtr
newCallback_StageRunMgrIPC_GetLanguage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetLanguage<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetLanguage.
 */
template<class T> Callback_StageRunMgrIPC_GetLanguagePtr
newCallback_StageRunMgrIPC_GetLanguage(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetLanguage<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetLanguage.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetLanguage.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_GetLanguage : public Callback_StageRunMgrIPC_GetLanguage_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_StageRunMgrIPC_GetLanguage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_GetLanguage(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetLanguage.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetLanguagePtr
newCallback_StageRunMgrIPC_GetLanguage(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetLanguage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetLanguage.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetLanguagePtr
newCallback_StageRunMgrIPC_GetLanguage(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetLanguage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetLanguage.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetLanguage.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_SetLanguage : public Callback_StageRunMgrIPC_SetLanguage_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_SetLanguage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetLanguage.
 */
template<class T> Callback_StageRunMgrIPC_SetLanguagePtr
newCallback_StageRunMgrIPC_SetLanguage(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetLanguage<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetLanguage.
 */
template<class T> Callback_StageRunMgrIPC_SetLanguagePtr
newCallback_StageRunMgrIPC_SetLanguage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetLanguage<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetLanguage.
 */
template<class T> Callback_StageRunMgrIPC_SetLanguagePtr
newCallback_StageRunMgrIPC_SetLanguage(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetLanguage<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetLanguage.
 */
template<class T> Callback_StageRunMgrIPC_SetLanguagePtr
newCallback_StageRunMgrIPC_SetLanguage(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetLanguage<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetLanguage.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetLanguage.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_SetLanguage : public Callback_StageRunMgrIPC_SetLanguage_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_SetLanguage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetLanguage.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetLanguagePtr
newCallback_StageRunMgrIPC_SetLanguage(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetLanguage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetLanguage.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetLanguagePtr
newCallback_StageRunMgrIPC_SetLanguage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetLanguage<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetLanguage.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetLanguagePtr
newCallback_StageRunMgrIPC_SetLanguage(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetLanguage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetLanguage.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetLanguagePtr
newCallback_StageRunMgrIPC_SetLanguage(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetLanguage<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBaseCallIpAddr.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetBaseCallIpAddr.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_SetBaseCallIpAddr : public Callback_StageRunMgrIPC_SetBaseCallIpAddr_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_SetBaseCallIpAddr(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBaseCallIpAddr.
 */
template<class T> Callback_StageRunMgrIPC_SetBaseCallIpAddrPtr
newCallback_StageRunMgrIPC_SetBaseCallIpAddr(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetBaseCallIpAddr<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBaseCallIpAddr.
 */
template<class T> Callback_StageRunMgrIPC_SetBaseCallIpAddrPtr
newCallback_StageRunMgrIPC_SetBaseCallIpAddr(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetBaseCallIpAddr<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBaseCallIpAddr.
 */
template<class T> Callback_StageRunMgrIPC_SetBaseCallIpAddrPtr
newCallback_StageRunMgrIPC_SetBaseCallIpAddr(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetBaseCallIpAddr<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBaseCallIpAddr.
 */
template<class T> Callback_StageRunMgrIPC_SetBaseCallIpAddrPtr
newCallback_StageRunMgrIPC_SetBaseCallIpAddr(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetBaseCallIpAddr<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBaseCallIpAddr.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetBaseCallIpAddr.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_SetBaseCallIpAddr : public Callback_StageRunMgrIPC_SetBaseCallIpAddr_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_SetBaseCallIpAddr(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBaseCallIpAddr.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetBaseCallIpAddrPtr
newCallback_StageRunMgrIPC_SetBaseCallIpAddr(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetBaseCallIpAddr<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBaseCallIpAddr.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetBaseCallIpAddrPtr
newCallback_StageRunMgrIPC_SetBaseCallIpAddr(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetBaseCallIpAddr<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBaseCallIpAddr.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetBaseCallIpAddrPtr
newCallback_StageRunMgrIPC_SetBaseCallIpAddr(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetBaseCallIpAddr<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetBaseCallIpAddr.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetBaseCallIpAddrPtr
newCallback_StageRunMgrIPC_SetBaseCallIpAddr(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetBaseCallIpAddr<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetZLIMSIpAddr.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetZLIMSIpAddr.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_SetZLIMSIpAddr : public Callback_StageRunMgrIPC_SetZLIMSIpAddr_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_SetZLIMSIpAddr(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetZLIMSIpAddr.
 */
template<class T> Callback_StageRunMgrIPC_SetZLIMSIpAddrPtr
newCallback_StageRunMgrIPC_SetZLIMSIpAddr(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetZLIMSIpAddr<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetZLIMSIpAddr.
 */
template<class T> Callback_StageRunMgrIPC_SetZLIMSIpAddrPtr
newCallback_StageRunMgrIPC_SetZLIMSIpAddr(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetZLIMSIpAddr<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetZLIMSIpAddr.
 */
template<class T> Callback_StageRunMgrIPC_SetZLIMSIpAddrPtr
newCallback_StageRunMgrIPC_SetZLIMSIpAddr(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetZLIMSIpAddr<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetZLIMSIpAddr.
 */
template<class T> Callback_StageRunMgrIPC_SetZLIMSIpAddrPtr
newCallback_StageRunMgrIPC_SetZLIMSIpAddr(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetZLIMSIpAddr<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetZLIMSIpAddr.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetZLIMSIpAddr.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_SetZLIMSIpAddr : public Callback_StageRunMgrIPC_SetZLIMSIpAddr_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_SetZLIMSIpAddr(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetZLIMSIpAddr.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetZLIMSIpAddrPtr
newCallback_StageRunMgrIPC_SetZLIMSIpAddr(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetZLIMSIpAddr<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetZLIMSIpAddr.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetZLIMSIpAddrPtr
newCallback_StageRunMgrIPC_SetZLIMSIpAddr(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetZLIMSIpAddr<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetZLIMSIpAddr.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetZLIMSIpAddrPtr
newCallback_StageRunMgrIPC_SetZLIMSIpAddr(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetZLIMSIpAddr<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetZLIMSIpAddr.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetZLIMSIpAddrPtr
newCallback_StageRunMgrIPC_SetZLIMSIpAddr(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetZLIMSIpAddr<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetZLIMSAddr.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetZLIMSAddr.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_GetZLIMSAddr : public Callback_StageRunMgrIPC_GetZLIMSAddr_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const IpAddr&);

    CallbackNC_StageRunMgrIPC_GetZLIMSAddr(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        IpAddr ret;
        try
        {
            ret = proxy->end_GetZLIMSAddr(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetZLIMSAddr.
 */
template<class T> Callback_StageRunMgrIPC_GetZLIMSAddrPtr
newCallback_StageRunMgrIPC_GetZLIMSAddr(const IceUtil::Handle<T>& instance, void (T::*cb)(const IpAddr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetZLIMSAddr<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetZLIMSAddr.
 */
template<class T> Callback_StageRunMgrIPC_GetZLIMSAddrPtr
newCallback_StageRunMgrIPC_GetZLIMSAddr(T* instance, void (T::*cb)(const IpAddr&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetZLIMSAddr<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetZLIMSAddr.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetZLIMSAddr.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_GetZLIMSAddr : public Callback_StageRunMgrIPC_GetZLIMSAddr_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const IpAddr&, const CT&);

    Callback_StageRunMgrIPC_GetZLIMSAddr(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        IpAddr ret;
        try
        {
            ret = proxy->end_GetZLIMSAddr(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetZLIMSAddr.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetZLIMSAddrPtr
newCallback_StageRunMgrIPC_GetZLIMSAddr(const IceUtil::Handle<T>& instance, void (T::*cb)(const IpAddr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetZLIMSAddr<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetZLIMSAddr.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetZLIMSAddrPtr
newCallback_StageRunMgrIPC_GetZLIMSAddr(T* instance, void (T::*cb)(const IpAddr&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetZLIMSAddr<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetCategoryParas.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetCategoryParas.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_SetCategoryParas : public Callback_StageRunMgrIPC_SetCategoryParas_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_SetCategoryParas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetCategoryParas.
 */
template<class T> Callback_StageRunMgrIPC_SetCategoryParasPtr
newCallback_StageRunMgrIPC_SetCategoryParas(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetCategoryParas<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetCategoryParas.
 */
template<class T> Callback_StageRunMgrIPC_SetCategoryParasPtr
newCallback_StageRunMgrIPC_SetCategoryParas(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetCategoryParas<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetCategoryParas.
 */
template<class T> Callback_StageRunMgrIPC_SetCategoryParasPtr
newCallback_StageRunMgrIPC_SetCategoryParas(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetCategoryParas<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetCategoryParas.
 */
template<class T> Callback_StageRunMgrIPC_SetCategoryParasPtr
newCallback_StageRunMgrIPC_SetCategoryParas(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_SetCategoryParas<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetCategoryParas.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_SetCategoryParas.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_SetCategoryParas : public Callback_StageRunMgrIPC_SetCategoryParas_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_SetCategoryParas(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetCategoryParas.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetCategoryParasPtr
newCallback_StageRunMgrIPC_SetCategoryParas(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetCategoryParas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetCategoryParas.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetCategoryParasPtr
newCallback_StageRunMgrIPC_SetCategoryParas(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetCategoryParas<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetCategoryParas.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetCategoryParasPtr
newCallback_StageRunMgrIPC_SetCategoryParas(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetCategoryParas<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_SetCategoryParas.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_SetCategoryParasPtr
newCallback_StageRunMgrIPC_SetCategoryParas(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_SetCategoryParas<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetParaValue.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetParaValue.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_GetParaValue : public Callback_StageRunMgrIPC_GetParaValue_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&);

    CallbackNC_StageRunMgrIPC_GetParaValue(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_GetParaValue(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetParaValue.
 */
template<class T> Callback_StageRunMgrIPC_GetParaValuePtr
newCallback_StageRunMgrIPC_GetParaValue(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetParaValue<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetParaValue.
 */
template<class T> Callback_StageRunMgrIPC_GetParaValuePtr
newCallback_StageRunMgrIPC_GetParaValue(T* instance, void (T::*cb)(const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_GetParaValue<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetParaValue.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_GetParaValue.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_GetParaValue : public Callback_StageRunMgrIPC_GetParaValue_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const CT&);

    Callback_StageRunMgrIPC_GetParaValue(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        StageRunMgrIPCPrx proxy = StageRunMgrIPCPrx::uncheckedCast(result->getProxy());
        ::std::string ret;
        try
        {
            ret = proxy->end_GetParaValue(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetParaValue.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetParaValuePtr
newCallback_StageRunMgrIPC_GetParaValue(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetParaValue<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_GetParaValue.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_GetParaValuePtr
newCallback_StageRunMgrIPC_GetParaValue(T* instance, void (T::*cb)(const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_GetParaValue<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSelfCheck.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StartSelfCheck.
 */
template<class T>
class CallbackNC_StageRunMgrIPC_StartSelfCheck : public Callback_StageRunMgrIPC_StartSelfCheck_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPC_StartSelfCheck(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSelfCheck.
 */
template<class T> Callback_StageRunMgrIPC_StartSelfCheckPtr
newCallback_StageRunMgrIPC_StartSelfCheck(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartSelfCheck<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSelfCheck.
 */
template<class T> Callback_StageRunMgrIPC_StartSelfCheckPtr
newCallback_StageRunMgrIPC_StartSelfCheck(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartSelfCheck<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSelfCheck.
 */
template<class T> Callback_StageRunMgrIPC_StartSelfCheckPtr
newCallback_StageRunMgrIPC_StartSelfCheck(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartSelfCheck<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSelfCheck.
 */
template<class T> Callback_StageRunMgrIPC_StartSelfCheckPtr
newCallback_StageRunMgrIPC_StartSelfCheck(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPC_StartSelfCheck<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSelfCheck.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPC_StartSelfCheck.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPC_StartSelfCheck : public Callback_StageRunMgrIPC_StartSelfCheck_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPC_StartSelfCheck(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSelfCheck.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartSelfCheckPtr
newCallback_StageRunMgrIPC_StartSelfCheck(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartSelfCheck<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSelfCheck.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartSelfCheckPtr
newCallback_StageRunMgrIPC_StartSelfCheck(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartSelfCheck<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSelfCheck.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartSelfCheckPtr
newCallback_StageRunMgrIPC_StartSelfCheck(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartSelfCheck<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPC::begin_StartSelfCheck.
 */
template<class T, typename CT> Callback_StageRunMgrIPC_StartSelfCheckPtr
newCallback_StageRunMgrIPC_StartSelfCheck(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPC_StartSelfCheck<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_AddClient.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_AddClient.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_AddClient : public Callback_StageRunMgrIPCCallback_AddClient_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_AddClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_AddClient.
 */
template<class T> Callback_StageRunMgrIPCCallback_AddClientPtr
newCallback_StageRunMgrIPCCallback_AddClient(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_AddClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_AddClient.
 */
template<class T> Callback_StageRunMgrIPCCallback_AddClientPtr
newCallback_StageRunMgrIPCCallback_AddClient(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_AddClient<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_AddClient.
 */
template<class T> Callback_StageRunMgrIPCCallback_AddClientPtr
newCallback_StageRunMgrIPCCallback_AddClient(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_AddClient<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_AddClient.
 */
template<class T> Callback_StageRunMgrIPCCallback_AddClientPtr
newCallback_StageRunMgrIPCCallback_AddClient(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_AddClient<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_AddClient.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_AddClient.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_AddClient : public Callback_StageRunMgrIPCCallback_AddClient_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_AddClient(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_AddClient.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_AddClientPtr
newCallback_StageRunMgrIPCCallback_AddClient(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_AddClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_AddClient.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_AddClientPtr
newCallback_StageRunMgrIPCCallback_AddClient(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_AddClient<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_AddClient.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_AddClientPtr
newCallback_StageRunMgrIPCCallback_AddClient(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_AddClient<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_AddClient.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_AddClientPtr
newCallback_StageRunMgrIPCCallback_AddClient(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_AddClient<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptName.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendScriptName.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_SendScriptName : public Callback_StageRunMgrIPCCallback_SendScriptName_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_SendScriptName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptName.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendScriptNamePtr
newCallback_StageRunMgrIPCCallback_SendScriptName(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendScriptName<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptName.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendScriptNamePtr
newCallback_StageRunMgrIPCCallback_SendScriptName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendScriptName<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptName.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendScriptNamePtr
newCallback_StageRunMgrIPCCallback_SendScriptName(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendScriptName<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptName.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendScriptNamePtr
newCallback_StageRunMgrIPCCallback_SendScriptName(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendScriptName<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptName.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendScriptName.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_SendScriptName : public Callback_StageRunMgrIPCCallback_SendScriptName_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_SendScriptName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptName.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendScriptNamePtr
newCallback_StageRunMgrIPCCallback_SendScriptName(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendScriptName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptName.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendScriptNamePtr
newCallback_StageRunMgrIPCCallback_SendScriptName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendScriptName<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptName.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendScriptNamePtr
newCallback_StageRunMgrIPCCallback_SendScriptName(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendScriptName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptName.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendScriptNamePtr
newCallback_StageRunMgrIPCCallback_SendScriptName(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendScriptName<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendActionName.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendActionName.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_SendActionName : public Callback_StageRunMgrIPCCallback_SendActionName_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_SendActionName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendActionName.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendActionNamePtr
newCallback_StageRunMgrIPCCallback_SendActionName(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendActionName<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendActionName.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendActionNamePtr
newCallback_StageRunMgrIPCCallback_SendActionName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendActionName<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendActionName.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendActionNamePtr
newCallback_StageRunMgrIPCCallback_SendActionName(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendActionName<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendActionName.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendActionNamePtr
newCallback_StageRunMgrIPCCallback_SendActionName(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendActionName<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendActionName.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendActionName.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_SendActionName : public Callback_StageRunMgrIPCCallback_SendActionName_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_SendActionName(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendActionName.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendActionNamePtr
newCallback_StageRunMgrIPCCallback_SendActionName(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendActionName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendActionName.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendActionNamePtr
newCallback_StageRunMgrIPCCallback_SendActionName(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendActionName<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendActionName.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendActionNamePtr
newCallback_StageRunMgrIPCCallback_SendActionName(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendActionName<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendActionName.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendActionNamePtr
newCallback_StageRunMgrIPCCallback_SendActionName(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendActionName<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendFlowcellBarcode.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendFlowcellBarcode.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_SendFlowcellBarcode : public Callback_StageRunMgrIPCCallback_SendFlowcellBarcode_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_SendFlowcellBarcode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendFlowcellBarcode.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendFlowcellBarcodePtr
newCallback_StageRunMgrIPCCallback_SendFlowcellBarcode(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendFlowcellBarcode<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendFlowcellBarcode.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendFlowcellBarcodePtr
newCallback_StageRunMgrIPCCallback_SendFlowcellBarcode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendFlowcellBarcode<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendFlowcellBarcode.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendFlowcellBarcodePtr
newCallback_StageRunMgrIPCCallback_SendFlowcellBarcode(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendFlowcellBarcode<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendFlowcellBarcode.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendFlowcellBarcodePtr
newCallback_StageRunMgrIPCCallback_SendFlowcellBarcode(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendFlowcellBarcode<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendFlowcellBarcode.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendFlowcellBarcode.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_SendFlowcellBarcode : public Callback_StageRunMgrIPCCallback_SendFlowcellBarcode_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_SendFlowcellBarcode(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendFlowcellBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendFlowcellBarcodePtr
newCallback_StageRunMgrIPCCallback_SendFlowcellBarcode(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendFlowcellBarcode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendFlowcellBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendFlowcellBarcodePtr
newCallback_StageRunMgrIPCCallback_SendFlowcellBarcode(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendFlowcellBarcode<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendFlowcellBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendFlowcellBarcodePtr
newCallback_StageRunMgrIPCCallback_SendFlowcellBarcode(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendFlowcellBarcode<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendFlowcellBarcode.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendFlowcellBarcodePtr
newCallback_StageRunMgrIPCCallback_SendFlowcellBarcode(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendFlowcellBarcode<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPositionNumber.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendPositionNumber.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_SendPositionNumber : public Callback_StageRunMgrIPCCallback_SendPositionNumber_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_SendPositionNumber(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPositionNumber.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendPositionNumberPtr
newCallback_StageRunMgrIPCCallback_SendPositionNumber(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendPositionNumber<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPositionNumber.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendPositionNumberPtr
newCallback_StageRunMgrIPCCallback_SendPositionNumber(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendPositionNumber<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPositionNumber.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendPositionNumberPtr
newCallback_StageRunMgrIPCCallback_SendPositionNumber(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendPositionNumber<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPositionNumber.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendPositionNumberPtr
newCallback_StageRunMgrIPCCallback_SendPositionNumber(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendPositionNumber<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPositionNumber.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendPositionNumber.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_SendPositionNumber : public Callback_StageRunMgrIPCCallback_SendPositionNumber_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_SendPositionNumber(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPositionNumber.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendPositionNumberPtr
newCallback_StageRunMgrIPCCallback_SendPositionNumber(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendPositionNumber<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPositionNumber.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendPositionNumberPtr
newCallback_StageRunMgrIPCCallback_SendPositionNumber(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendPositionNumber<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPositionNumber.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendPositionNumberPtr
newCallback_StageRunMgrIPCCallback_SendPositionNumber(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendPositionNumber<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPositionNumber.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendPositionNumberPtr
newCallback_StageRunMgrIPCCallback_SendPositionNumber(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendPositionNumber<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPcntDone.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendPcntDone.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_SendPcntDone : public Callback_StageRunMgrIPCCallback_SendPcntDone_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_SendPcntDone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPcntDone.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendPcntDonePtr
newCallback_StageRunMgrIPCCallback_SendPcntDone(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendPcntDone<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPcntDone.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendPcntDonePtr
newCallback_StageRunMgrIPCCallback_SendPcntDone(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendPcntDone<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPcntDone.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendPcntDonePtr
newCallback_StageRunMgrIPCCallback_SendPcntDone(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendPcntDone<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPcntDone.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendPcntDonePtr
newCallback_StageRunMgrIPCCallback_SendPcntDone(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendPcntDone<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPcntDone.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendPcntDone.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_SendPcntDone : public Callback_StageRunMgrIPCCallback_SendPcntDone_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_SendPcntDone(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPcntDone.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendPcntDonePtr
newCallback_StageRunMgrIPCCallback_SendPcntDone(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendPcntDone<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPcntDone.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendPcntDonePtr
newCallback_StageRunMgrIPCCallback_SendPcntDone(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendPcntDone<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPcntDone.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendPcntDonePtr
newCallback_StageRunMgrIPCCallback_SendPcntDone(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendPcntDone<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendPcntDone.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendPcntDonePtr
newCallback_StageRunMgrIPCCallback_SendPcntDone(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendPcntDone<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptStatus.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendScriptStatus.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_SendScriptStatus : public Callback_StageRunMgrIPCCallback_SendScriptStatus_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_SendScriptStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptStatus.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendScriptStatusPtr
newCallback_StageRunMgrIPCCallback_SendScriptStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendScriptStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptStatus.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendScriptStatusPtr
newCallback_StageRunMgrIPCCallback_SendScriptStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendScriptStatus<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptStatus.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendScriptStatusPtr
newCallback_StageRunMgrIPCCallback_SendScriptStatus(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendScriptStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptStatus.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendScriptStatusPtr
newCallback_StageRunMgrIPCCallback_SendScriptStatus(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendScriptStatus<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptStatus.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendScriptStatus.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_SendScriptStatus : public Callback_StageRunMgrIPCCallback_SendScriptStatus_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_SendScriptStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptStatus.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendScriptStatusPtr
newCallback_StageRunMgrIPCCallback_SendScriptStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendScriptStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptStatus.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendScriptStatusPtr
newCallback_StageRunMgrIPCCallback_SendScriptStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendScriptStatus<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptStatus.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendScriptStatusPtr
newCallback_StageRunMgrIPCCallback_SendScriptStatus(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendScriptStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptStatus.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendScriptStatusPtr
newCallback_StageRunMgrIPCCallback_SendScriptStatus(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendScriptStatus<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptMessageId.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendScriptMessageId.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_SendScriptMessageId : public Callback_StageRunMgrIPCCallback_SendScriptMessageId_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_SendScriptMessageId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptMessageId.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendScriptMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendScriptMessageId(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendScriptMessageId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptMessageId.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendScriptMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendScriptMessageId(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendScriptMessageId<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptMessageId.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendScriptMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendScriptMessageId(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendScriptMessageId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptMessageId.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendScriptMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendScriptMessageId(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendScriptMessageId<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptMessageId.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendScriptMessageId.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_SendScriptMessageId : public Callback_StageRunMgrIPCCallback_SendScriptMessageId_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_SendScriptMessageId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptMessageId.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendScriptMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendScriptMessageId(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendScriptMessageId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptMessageId.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendScriptMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendScriptMessageId(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendScriptMessageId<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptMessageId.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendScriptMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendScriptMessageId(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendScriptMessageId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendScriptMessageId.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendScriptMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendScriptMessageId(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendScriptMessageId<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendStageMessage.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendStageMessage.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_SendStageMessage : public Callback_StageRunMgrIPCCallback_SendStageMessage_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_SendStageMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendStageMessage.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendStageMessagePtr
newCallback_StageRunMgrIPCCallback_SendStageMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendStageMessage<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendStageMessage.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendStageMessagePtr
newCallback_StageRunMgrIPCCallback_SendStageMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendStageMessage<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendStageMessage.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendStageMessagePtr
newCallback_StageRunMgrIPCCallback_SendStageMessage(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendStageMessage<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendStageMessage.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendStageMessagePtr
newCallback_StageRunMgrIPCCallback_SendStageMessage(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendStageMessage<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendStageMessage.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendStageMessage.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_SendStageMessage : public Callback_StageRunMgrIPCCallback_SendStageMessage_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_SendStageMessage(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendStageMessage.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendStageMessagePtr
newCallback_StageRunMgrIPCCallback_SendStageMessage(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendStageMessage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendStageMessage.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendStageMessagePtr
newCallback_StageRunMgrIPCCallback_SendStageMessage(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendStageMessage<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendStageMessage.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendStageMessagePtr
newCallback_StageRunMgrIPCCallback_SendStageMessage(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendStageMessage<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendStageMessage.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendStageMessagePtr
newCallback_StageRunMgrIPCCallback_SendStageMessage(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendStageMessage<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValue.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendQCValue.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_SendQCValue : public Callback_StageRunMgrIPCCallback_SendQCValue_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_SendQCValue(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValue.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendQCValuePtr
newCallback_StageRunMgrIPCCallback_SendQCValue(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendQCValue<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValue.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendQCValuePtr
newCallback_StageRunMgrIPCCallback_SendQCValue(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendQCValue<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValue.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendQCValuePtr
newCallback_StageRunMgrIPCCallback_SendQCValue(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendQCValue<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValue.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendQCValuePtr
newCallback_StageRunMgrIPCCallback_SendQCValue(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendQCValue<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValue.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendQCValue.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_SendQCValue : public Callback_StageRunMgrIPCCallback_SendQCValue_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_SendQCValue(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValue.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendQCValuePtr
newCallback_StageRunMgrIPCCallback_SendQCValue(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendQCValue<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValue.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendQCValuePtr
newCallback_StageRunMgrIPCCallback_SendQCValue(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendQCValue<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValue.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendQCValuePtr
newCallback_StageRunMgrIPCCallback_SendQCValue(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendQCValue<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValue.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendQCValuePtr
newCallback_StageRunMgrIPCCallback_SendQCValue(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendQCValue<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValues.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendQCValues.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_SendQCValues : public Callback_StageRunMgrIPCCallback_SendQCValues_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_SendQCValues(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValues.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendQCValuesPtr
newCallback_StageRunMgrIPCCallback_SendQCValues(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendQCValues<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValues.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendQCValuesPtr
newCallback_StageRunMgrIPCCallback_SendQCValues(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendQCValues<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValues.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendQCValuesPtr
newCallback_StageRunMgrIPCCallback_SendQCValues(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendQCValues<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValues.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendQCValuesPtr
newCallback_StageRunMgrIPCCallback_SendQCValues(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendQCValues<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValues.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendQCValues.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_SendQCValues : public Callback_StageRunMgrIPCCallback_SendQCValues_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_SendQCValues(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValues.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendQCValuesPtr
newCallback_StageRunMgrIPCCallback_SendQCValues(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendQCValues<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValues.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendQCValuesPtr
newCallback_StageRunMgrIPCCallback_SendQCValues(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendQCValues<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValues.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendQCValuesPtr
newCallback_StageRunMgrIPCCallback_SendQCValues(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendQCValues<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendQCValues.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendQCValuesPtr
newCallback_StageRunMgrIPCCallback_SendQCValues(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendQCValues<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendAlarmMessageId.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendAlarmMessageId.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_SendAlarmMessageId : public Callback_StageRunMgrIPCCallback_SendAlarmMessageId_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_SendAlarmMessageId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendAlarmMessageId.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendAlarmMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendAlarmMessageId(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendAlarmMessageId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendAlarmMessageId.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendAlarmMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendAlarmMessageId(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendAlarmMessageId<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendAlarmMessageId.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendAlarmMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendAlarmMessageId(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendAlarmMessageId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendAlarmMessageId.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendAlarmMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendAlarmMessageId(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendAlarmMessageId<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendAlarmMessageId.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendAlarmMessageId.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_SendAlarmMessageId : public Callback_StageRunMgrIPCCallback_SendAlarmMessageId_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_SendAlarmMessageId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendAlarmMessageId.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendAlarmMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendAlarmMessageId(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendAlarmMessageId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendAlarmMessageId.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendAlarmMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendAlarmMessageId(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendAlarmMessageId<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendAlarmMessageId.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendAlarmMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendAlarmMessageId(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendAlarmMessageId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendAlarmMessageId.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendAlarmMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendAlarmMessageId(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendAlarmMessageId<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendLogMessageId.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendLogMessageId.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_SendLogMessageId : public Callback_StageRunMgrIPCCallback_SendLogMessageId_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_SendLogMessageId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendLogMessageId.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendLogMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendLogMessageId(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendLogMessageId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendLogMessageId.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendLogMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendLogMessageId(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendLogMessageId<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendLogMessageId.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendLogMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendLogMessageId(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendLogMessageId<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendLogMessageId.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendLogMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendLogMessageId(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendLogMessageId<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendLogMessageId.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendLogMessageId.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_SendLogMessageId : public Callback_StageRunMgrIPCCallback_SendLogMessageId_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_SendLogMessageId(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendLogMessageId.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendLogMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendLogMessageId(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendLogMessageId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendLogMessageId.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendLogMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendLogMessageId(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendLogMessageId<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendLogMessageId.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendLogMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendLogMessageId(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendLogMessageId<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendLogMessageId.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendLogMessageIdPtr
newCallback_StageRunMgrIPCCallback_SendLogMessageId(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendLogMessageId<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendRemainingTime.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendRemainingTime.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_SendRemainingTime : public Callback_StageRunMgrIPCCallback_SendRemainingTime_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_SendRemainingTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendRemainingTime.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendRemainingTimePtr
newCallback_StageRunMgrIPCCallback_SendRemainingTime(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendRemainingTime<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendRemainingTime.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendRemainingTimePtr
newCallback_StageRunMgrIPCCallback_SendRemainingTime(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendRemainingTime<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendRemainingTime.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendRemainingTimePtr
newCallback_StageRunMgrIPCCallback_SendRemainingTime(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendRemainingTime<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendRemainingTime.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendRemainingTimePtr
newCallback_StageRunMgrIPCCallback_SendRemainingTime(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendRemainingTime<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendRemainingTime.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendRemainingTime.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_SendRemainingTime : public Callback_StageRunMgrIPCCallback_SendRemainingTime_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_SendRemainingTime(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendRemainingTime.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendRemainingTimePtr
newCallback_StageRunMgrIPCCallback_SendRemainingTime(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendRemainingTime<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendRemainingTime.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendRemainingTimePtr
newCallback_StageRunMgrIPCCallback_SendRemainingTime(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendRemainingTime<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendRemainingTime.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendRemainingTimePtr
newCallback_StageRunMgrIPCCallback_SendRemainingTime(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendRemainingTime<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendRemainingTime.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendRemainingTimePtr
newCallback_StageRunMgrIPCCallback_SendRemainingTime(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendRemainingTime<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendDataList.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendDataList.
 */
template<class T>
class CallbackNC_StageRunMgrIPCCallback_SendDataList : public Callback_StageRunMgrIPCCallback_SendDataList_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_StageRunMgrIPCCallback_SendDataList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendDataList.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendDataListPtr
newCallback_StageRunMgrIPCCallback_SendDataList(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendDataList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendDataList.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendDataListPtr
newCallback_StageRunMgrIPCCallback_SendDataList(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendDataList<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendDataList.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendDataListPtr
newCallback_StageRunMgrIPCCallback_SendDataList(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendDataList<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendDataList.
 */
template<class T> Callback_StageRunMgrIPCCallback_SendDataListPtr
newCallback_StageRunMgrIPCCallback_SendDataList(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_StageRunMgrIPCCallback_SendDataList<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendDataList.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_StageRunMgrIPCCallback_SendDataList.
 */
template<class T, typename CT>
class Callback_StageRunMgrIPCCallback_SendDataList : public Callback_StageRunMgrIPCCallback_SendDataList_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_StageRunMgrIPCCallback_SendDataList(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendDataList.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendDataListPtr
newCallback_StageRunMgrIPCCallback_SendDataList(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendDataList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendDataList.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendDataListPtr
newCallback_StageRunMgrIPCCallback_SendDataList(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendDataList<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendDataList.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendDataListPtr
newCallback_StageRunMgrIPCCallback_SendDataList(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendDataList<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::StageRunMgrIPCCallback::begin_SendDataList.
 */
template<class T, typename CT> Callback_StageRunMgrIPCCallback_SendDataListPtr
newCallback_StageRunMgrIPCCallback_SendDataList(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_StageRunMgrIPCCallback_SendDataList<T, CT>(instance, 0, excb, sentcb);
}

}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
