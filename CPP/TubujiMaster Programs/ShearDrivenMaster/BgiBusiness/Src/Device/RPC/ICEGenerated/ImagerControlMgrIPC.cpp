//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.8
//
// <auto-generated>
//
// Generated from file `ImagerControlMgrIPC.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#include "ImagerControlMgrIPC.h"
#include <IceUtil/PushDisableWarnings.h>
#include <Ice/LocalException.h>
#include <Ice/ValueFactory.h>
#include <Ice/OutgoingAsync.h>
#include <Ice/InputStream.h>
#include <Ice/OutputStream.h>
#include <Ice/LocalException.h>
#include <IceUtil/PopDisableWarnings.h>

#if defined(_MSC_VER)
#   pragma warning(disable:4458) // declaration of ... hides class member
#elif defined(__clang__)
#   pragma clang diagnostic ignored "-Wshadow"
#elif defined(__GNUC__)
#   pragma GCC diagnostic ignored "-Wshadow"
#endif

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 8
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace
{

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_ids[3] =
{
    "::BGI::RPC::ImagerControlMgrIPC",
    "::BGI::RPC::StageRunMgrIPC",
    "::Ice::Object"
};
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_ops[] =
{
    "AbortScript",
    "Authenicate",
    "ClearAlarmMessages",
    "DownloadScriptFile",
    "EndCycle",
    "GetAlarmMessages",
    "GetAllRunInformations",
    "GetBasecallFlowcellConsumptionDiskSpace",
    "GetBasecallInformation",
    "GetBasecallLocalDiskSpace",
    "GetBasecallRemoteDiskSpace",
    "GetExperimentInfo",
    "GetHeartbeat",
    "GetLanguage",
    "GetLogMessages",
    "GetParaValue",
    "GetParam",
    "GetQCValues",
    "GetRunInformation",
    "GetScriptMessages",
    "GetScriptRunInfo",
    "GetSequenceTypes",
    "GetVacuumStatus",
    "GetVersions",
    "GetZLIMSAddr",
    "GoHome",
    "GoLoadingPos",
    "GoWashPos",
    "ImagerConfigGet",
    "ImagerConfigSet",
    "ImagerSetup",
    "IsAtLoadPosition",
    "MotorMove",
    "OverrideFlowcellBarcode",
    "PauseScript",
    "PreInjectSRE",
    "PreProcessing",
    "ReagentNeedle",
    "ReleaseRun",
    "Reset",
    "ResumeScript",
    "RunScriptNow",
    "SaveSelectedScriptFileName",
    "ScanFlowcellBarcode",
    "ScanReagentKitBarcode",
    "SendExperimentType",
    "SendReagentKit",
    "SendSampleId",
    "SetBaseCallIpAddr",
    "SetBuzzerVolume",
    "SetCategoryParas",
    "SetClearData",
    "SetLanguage",
    "SetParam",
    "SetZLIMSIpAddr",
    "SetupRun",
    "SetupRunInfo",
    "SetupScriptFile",
    "SlideLeavedImager",
    "StartRun",
    "StartRunLength",
    "StartRunScript",
    "StartSelfCheck",
    "StartSetup",
    "StopScript",
    "SwitchVacuum",
    "UIOperation",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_ImagerSetup_name = "ImagerSetup";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_Reset_name = "Reset";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_SetupRun_name = "SetupRun";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_ReleaseRun_name = "ReleaseRun";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GoHome_name = "GoHome";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GoLoadingPos_name = "GoLoadingPos";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GoWashPos_name = "GoWashPos";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_IsAtLoadPosition_name = "IsAtLoadPosition";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_SwitchVacuum_name = "SwitchVacuum";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetVacuumStatus_name = "GetVacuumStatus";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_PreInjectSRE_name = "PreInjectSRE";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_PreProcessing_name = "PreProcessing";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigSet_name = "ImagerConfigSet";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigGet_name = "ImagerConfigGet";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_SlideLeavedImager_name = "SlideLeavedImager";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetAllRunInformations_name = "GetAllRunInformations";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetRunInformation_name = "GetRunInformation";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallInformation_name = "GetBasecallInformation";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_EndCycle_name = "EndCycle";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_StartRunScript_name = "StartRunScript";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace_name = "GetBasecallFlowcellConsumptionDiskSpace";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace_name = "GetBasecallRemoteDiskSpace";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallLocalDiskSpace_name = "GetBasecallLocalDiskSpace";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetParam_name = "GetParam";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_SetParam_name = "SetParam";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetVersions_name = "GetVersions";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_ids[3] =
{
    "::BGI::RPC::ImagerControlMgrIPCCallback",
    "::BGI::RPC::StageRunMgrIPCCallback",
    "::Ice::Object"
};
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_ops[] =
{
    "AddClient",
    "SendActionName",
    "SendAlarmMessageId",
    "SendData",
    "SendDataList",
    "SendFlowcellBarcode",
    "SendHeartbeat",
    "SendImagerError",
    "SendImagerRunInfo",
    "SendImagerTaskEnd",
    "SendLogMessageId",
    "SendPcntDone",
    "SendPositionNumber",
    "SendQCValue",
    "SendQCValues",
    "SendRemainingTime",
    "SendScriptMessageId",
    "SendScriptName",
    "SendScriptStatus",
    "SendStageMessage",
    "SendStatus",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerError_name = "SendImagerError";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerRunInfo_name = "SendImagerRunInfo";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerTaskEnd_name = "SendImagerTaskEnd";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendData_name = "SendData";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendHeartbeat_name = "SendHeartbeat";
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendStatus_name = "SendStatus";

}

bool
BGI::RPC::ImagerControlMgrIPC::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_BGI_RPC_ImagerControlMgrIPC_ids, iceC_BGI_RPC_ImagerControlMgrIPC_ids + 3, s);
}

::std::vector<::std::string>
BGI::RPC::ImagerControlMgrIPC::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_BGI_RPC_ImagerControlMgrIPC_ids[0], &iceC_BGI_RPC_ImagerControlMgrIPC_ids[3]);
}

::std::string
BGI::RPC::ImagerControlMgrIPC::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
BGI::RPC::ImagerControlMgrIPC::ice_staticId()
{
    static const ::std::string typeId = "::BGI::RPC::ImagerControlMgrIPC";
    return typeId;
}

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_ImagerSetup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ImagerSetupInfo iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    bool ret = this->ImagerSetup(::std::move(iceP_info), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_Reset(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->Reset(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_SetupRun(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ImagerSetupInfo iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    bool ret = this->SetupRun(::std::move(iceP_info), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_ReleaseRun(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ImagerSetupInfo iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    bool ret = this->ReleaseRun(::std::move(iceP_info), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GoHome(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->GoHome(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GoLoadingPos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->GoLoadingPos(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GoWashPos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->GoWashPos(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_IsAtLoadPosition(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->IsAtLoadPosition(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_SwitchVacuum(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    bool iceP_valveStatus;
    bool iceP_pumpStatus;
    istr->readAll(iceP_valveStatus, iceP_pumpStatus);
    inS.endReadParams();
    bool ret = this->SwitchVacuum(iceP_valveStatus, iceP_pumpStatus, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetVacuumStatus(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    double iceP_thresholdValueMin;
    double iceP_thresholdValueMax;
    int iceP_timeoutSec;
    istr->readAll(iceP_thresholdValueMin, iceP_thresholdValueMax, iceP_timeoutSec);
    inS.endReadParams();
    bool ret = this->GetVacuumStatus(iceP_thresholdValueMin, iceP_thresholdValueMax, iceP_timeoutSec, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_PreInjectSRE(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->PreInjectSRE(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_PreProcessing(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    PreProcessingEnum iceP_type;
    int iceP_timeoutSec;
    istr->readAll(iceP_type, iceP_timeoutSec);
    inS.endReadParams();
    bool ret = this->PreProcessing(iceP_type, iceP_timeoutSec, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_ImagerConfigSet(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ImagerConfigData iceP_config;
    istr->readAll(iceP_config);
    inS.endReadParams();
    bool ret = this->ImagerConfigSet(::std::move(iceP_config), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_ImagerConfigGet(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ImagerConfigData ret = this->ImagerConfigGet(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_SlideLeavedImager(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ImagerSlideLeavedReason iceP_reason;
    istr->readAll(iceP_reason);
    inS.endReadParams();
    this->SlideLeavedImager(iceP_reason, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetAllRunInformations(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    RunInformationArray ret = this->GetAllRunInformations(current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetRunInformation(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_slideID;
    istr->readAll(iceP_slideID);
    inS.endReadParams();
    ImagerSetupInfo iceP_runInfo;
    this->GetRunInformation(::std::move(iceP_slideID), iceP_runInfo, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_runInfo);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetBasecallInformation(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_slideID;
    istr->readAll(iceP_slideID);
    inS.endReadParams();
    bool ret = this->GetBasecallInformation(::std::move(iceP_slideID), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_EndCycle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    bool iceP_reSeq;
    istr->readAll(iceP_reSeq);
    inS.endReadParams();
    bool ret = this->EndCycle(iceP_reSeq, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_StartRunScript(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_scriptName;
    istr->readAll(iceP_scriptName);
    inS.endReadParams();
    bool ret = this->StartRunScript(::std::move(iceP_scriptName), current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetBasecallFlowcellConsumptionDiskSpace(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    double iceP_value;
    bool ret = this->GetBasecallFlowcellConsumptionDiskSpace(iceP_value, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_value, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetBasecallRemoteDiskSpace(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    double iceP_value;
    bool ret = this->GetBasecallRemoteDiskSpace(iceP_value, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_value, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetBasecallLocalDiskSpace(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    double iceP_value;
    bool ret = this->GetBasecallLocalDiskSpace(iceP_value, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_value, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetParam(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->readAll(iceP_name);
    inS.endReadParams();
    ::std::string iceP_value;
    bool ret = this->GetParam(::std::move(iceP_name), iceP_value, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_value, ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_SetParam(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_value;
    bool iceP_saveToDisk;
    istr->readAll(iceP_name, iceP_value, iceP_saveToDisk);
    inS.endReadParams();
    bool ret = this->SetParam(::std::move(iceP_name), ::std::move(iceP_value), iceP_saveToDisk, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetVersions(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string iceP_bcsVer;
    ::std::string iceP_sbcVer;
    ::std::string iceP_imagerVer;
    this->GetVersions(iceP_bcsVer, iceP_sbcVer, iceP_imagerVer, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(iceP_bcsVer, iceP_sbcVer, iceP_imagerVer);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_BGI_RPC_ImagerControlMgrIPC_ops, iceC_BGI_RPC_ImagerControlMgrIPC_ops + 71, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_BGI_RPC_ImagerControlMgrIPC_ops)
    {
        case 0:
        {
            return _iceD_AbortScript(in, current);
        }
        case 1:
        {
            return _iceD_Authenicate(in, current);
        }
        case 2:
        {
            return _iceD_ClearAlarmMessages(in, current);
        }
        case 3:
        {
            return _iceD_DownloadScriptFile(in, current);
        }
        case 4:
        {
            return _iceD_EndCycle(in, current);
        }
        case 5:
        {
            return _iceD_GetAlarmMessages(in, current);
        }
        case 6:
        {
            return _iceD_GetAllRunInformations(in, current);
        }
        case 7:
        {
            return _iceD_GetBasecallFlowcellConsumptionDiskSpace(in, current);
        }
        case 8:
        {
            return _iceD_GetBasecallInformation(in, current);
        }
        case 9:
        {
            return _iceD_GetBasecallLocalDiskSpace(in, current);
        }
        case 10:
        {
            return _iceD_GetBasecallRemoteDiskSpace(in, current);
        }
        case 11:
        {
            return _iceD_GetExperimentInfo(in, current);
        }
        case 12:
        {
            return _iceD_GetHeartbeat(in, current);
        }
        case 13:
        {
            return _iceD_GetLanguage(in, current);
        }
        case 14:
        {
            return _iceD_GetLogMessages(in, current);
        }
        case 15:
        {
            return _iceD_GetParaValue(in, current);
        }
        case 16:
        {
            return _iceD_GetParam(in, current);
        }
        case 17:
        {
            return _iceD_GetQCValues(in, current);
        }
        case 18:
        {
            return _iceD_GetRunInformation(in, current);
        }
        case 19:
        {
            return _iceD_GetScriptMessages(in, current);
        }
        case 20:
        {
            return _iceD_GetScriptRunInfo(in, current);
        }
        case 21:
        {
            return _iceD_GetSequenceTypes(in, current);
        }
        case 22:
        {
            return _iceD_GetVacuumStatus(in, current);
        }
        case 23:
        {
            return _iceD_GetVersions(in, current);
        }
        case 24:
        {
            return _iceD_GetZLIMSAddr(in, current);
        }
        case 25:
        {
            return _iceD_GoHome(in, current);
        }
        case 26:
        {
            return _iceD_GoLoadingPos(in, current);
        }
        case 27:
        {
            return _iceD_GoWashPos(in, current);
        }
        case 28:
        {
            return _iceD_ImagerConfigGet(in, current);
        }
        case 29:
        {
            return _iceD_ImagerConfigSet(in, current);
        }
        case 30:
        {
            return _iceD_ImagerSetup(in, current);
        }
        case 31:
        {
            return _iceD_IsAtLoadPosition(in, current);
        }
        case 32:
        {
            return _iceD_MotorMove(in, current);
        }
        case 33:
        {
            return _iceD_OverrideFlowcellBarcode(in, current);
        }
        case 34:
        {
            return _iceD_PauseScript(in, current);
        }
        case 35:
        {
            return _iceD_PreInjectSRE(in, current);
        }
        case 36:
        {
            return _iceD_PreProcessing(in, current);
        }
        case 37:
        {
            return _iceD_ReagentNeedle(in, current);
        }
        case 38:
        {
            return _iceD_ReleaseRun(in, current);
        }
        case 39:
        {
            return _iceD_Reset(in, current);
        }
        case 40:
        {
            return _iceD_ResumeScript(in, current);
        }
        case 41:
        {
            return _iceD_RunScriptNow(in, current);
        }
        case 42:
        {
            return _iceD_SaveSelectedScriptFileName(in, current);
        }
        case 43:
        {
            return _iceD_ScanFlowcellBarcode(in, current);
        }
        case 44:
        {
            return _iceD_ScanReagentKitBarcode(in, current);
        }
        case 45:
        {
            return _iceD_SendExperimentType(in, current);
        }
        case 46:
        {
            return _iceD_SendReagentKit(in, current);
        }
        case 47:
        {
            return _iceD_SendSampleId(in, current);
        }
        case 48:
        {
            return _iceD_SetBaseCallIpAddr(in, current);
        }
        case 49:
        {
            return _iceD_SetBuzzerVolume(in, current);
        }
        case 50:
        {
            return _iceD_SetCategoryParas(in, current);
        }
        case 51:
        {
            return _iceD_SetClearData(in, current);
        }
        case 52:
        {
            return _iceD_SetLanguage(in, current);
        }
        case 53:
        {
            return _iceD_SetParam(in, current);
        }
        case 54:
        {
            return _iceD_SetZLIMSIpAddr(in, current);
        }
        case 55:
        {
            return _iceD_SetupRun(in, current);
        }
        case 56:
        {
            return _iceD_SetupRunInfo(in, current);
        }
        case 57:
        {
            return _iceD_SetupScriptFile(in, current);
        }
        case 58:
        {
            return _iceD_SlideLeavedImager(in, current);
        }
        case 59:
        {
            return _iceD_StartRun(in, current);
        }
        case 60:
        {
            return _iceD_StartRunLength(in, current);
        }
        case 61:
        {
            return _iceD_StartRunScript(in, current);
        }
        case 62:
        {
            return _iceD_StartSelfCheck(in, current);
        }
        case 63:
        {
            return _iceD_StartSetup(in, current);
        }
        case 64:
        {
            return _iceD_StopScript(in, current);
        }
        case 65:
        {
            return _iceD_SwitchVacuum(in, current);
        }
        case 66:
        {
            return _iceD_UIOperation(in, current);
        }
        case 67:
        {
            return _iceD_ice_id(in, current);
        }
        case 68:
        {
            return _iceD_ice_ids(in, current);
        }
        case 69:
        {
            return _iceD_ice_isA(in, current);
        }
        case 70:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

bool
BGI::RPC::ImagerControlMgrIPCCallback::ice_isA(::std::string s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_BGI_RPC_ImagerControlMgrIPCCallback_ids, iceC_BGI_RPC_ImagerControlMgrIPCCallback_ids + 3, s);
}

::std::vector<::std::string>
BGI::RPC::ImagerControlMgrIPCCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector<::std::string>(&iceC_BGI_RPC_ImagerControlMgrIPCCallback_ids[0], &iceC_BGI_RPC_ImagerControlMgrIPCCallback_ids[3]);
}

::std::string
BGI::RPC::ImagerControlMgrIPCCallback::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
BGI::RPC::ImagerControlMgrIPCCallback::ice_staticId()
{
    static const ::std::string typeId = "::BGI::RPC::ImagerControlMgrIPCCallback";
    return typeId;
}

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPCCallback::_iceD_SendImagerError(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ImagerErrorEnum iceP_error;
    istr->readAll(iceP_error);
    inS.endReadParams();
    this->SendImagerError(iceP_error, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPCCallback::_iceD_SendImagerRunInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ImagerRunInfo iceP_info;
    istr->readAll(iceP_info);
    inS.endReadParams();
    this->SendImagerRunInfo(::std::move(iceP_info), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPCCallback::_iceD_SendImagerTaskEnd(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ImagerSetupInfo iceP_info;
    ImagerErrorEnum iceP_error;
    istr->readAll(iceP_info, iceP_error);
    inS.endReadParams();
    this->SendImagerTaskEnd(::std::move(iceP_info), iceP_error, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPCCallback::_iceD_SendData(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    ::std::string iceP_key;
    ::std::string iceP_value;
    istr->readAll(iceP_key, iceP_value);
    inS.endReadParams();
    this->SendData(::std::move(iceP_key), ::std::move(iceP_value), current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPCCallback::_iceD_SendHeartbeat(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    int iceP_count;
    istr->readAll(iceP_count);
    inS.endReadParams();
    int ret = this->SendHeartbeat(iceP_count, current);
    auto ostr = inS.startWriteParams();
    ostr->writeAll(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPCCallback::_iceD_SendStatus(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::OperationMode::Normal, current.mode);
    auto istr = inS.startReadParams();
    BasecallConnectState iceP_StateBasecall;
    ImagerServerState iceP_StateServer;
    ImagerState iceP_StateImager;
    istr->readAll(iceP_StateBasecall, iceP_StateServer, iceP_StateImager);
    inS.endReadParams();
    this->SendStatus(iceP_StateBasecall, iceP_StateServer, iceP_StateImager, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPCCallback::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_BGI_RPC_ImagerControlMgrIPCCallback_ops, iceC_BGI_RPC_ImagerControlMgrIPCCallback_ops + 25, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_BGI_RPC_ImagerControlMgrIPCCallback_ops)
    {
        case 0:
        {
            return _iceD_AddClient(in, current);
        }
        case 1:
        {
            return _iceD_SendActionName(in, current);
        }
        case 2:
        {
            return _iceD_SendAlarmMessageId(in, current);
        }
        case 3:
        {
            return _iceD_SendData(in, current);
        }
        case 4:
        {
            return _iceD_SendDataList(in, current);
        }
        case 5:
        {
            return _iceD_SendFlowcellBarcode(in, current);
        }
        case 6:
        {
            return _iceD_SendHeartbeat(in, current);
        }
        case 7:
        {
            return _iceD_SendImagerError(in, current);
        }
        case 8:
        {
            return _iceD_SendImagerRunInfo(in, current);
        }
        case 9:
        {
            return _iceD_SendImagerTaskEnd(in, current);
        }
        case 10:
        {
            return _iceD_SendLogMessageId(in, current);
        }
        case 11:
        {
            return _iceD_SendPcntDone(in, current);
        }
        case 12:
        {
            return _iceD_SendPositionNumber(in, current);
        }
        case 13:
        {
            return _iceD_SendQCValue(in, current);
        }
        case 14:
        {
            return _iceD_SendQCValues(in, current);
        }
        case 15:
        {
            return _iceD_SendRemainingTime(in, current);
        }
        case 16:
        {
            return _iceD_SendScriptMessageId(in, current);
        }
        case 17:
        {
            return _iceD_SendScriptName(in, current);
        }
        case 18:
        {
            return _iceD_SendScriptStatus(in, current);
        }
        case 19:
        {
            return _iceD_SendStageMessage(in, current);
        }
        case 20:
        {
            return _iceD_SendStatus(in, current);
        }
        case 21:
        {
            return _iceD_ice_id(in, current);
        }
        case 22:
        {
            return _iceD_ice_ids(in, current);
        }
        case 23:
        {
            return _iceD_ice_isA(in, current);
        }
        case 24:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_ImagerSetup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ImagerSetupInfo& iceP_info, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerSetup_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerSetup_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_Reset(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_Reset_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_Reset_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_SetupRun(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ImagerSetupInfo& iceP_info, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_SetupRun_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_SetupRun_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_ReleaseRun(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ImagerSetupInfo& iceP_info, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_ReleaseRun_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_ReleaseRun_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GoHome(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GoHome_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GoHome_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GoLoadingPos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GoLoadingPos_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GoLoadingPos_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GoWashPos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GoWashPos_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GoWashPos_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_IsAtLoadPosition(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_IsAtLoadPosition_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_IsAtLoadPosition_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_SwitchVacuum(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, bool iceP_valveStatus, bool iceP_pumpStatus, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_SwitchVacuum_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_SwitchVacuum_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_valveStatus, iceP_pumpStatus);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetVacuumStatus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, double iceP_thresholdValueMin, double iceP_thresholdValueMax, int iceP_timeoutSec, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetVacuumStatus_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetVacuumStatus_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_thresholdValueMin, iceP_thresholdValueMax, iceP_timeoutSec);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_PreInjectSRE(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_PreInjectSRE_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_PreInjectSRE_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_PreProcessing(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, PreProcessingEnum iceP_type, int iceP_timeoutSec, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_PreProcessing_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_PreProcessing_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_type, iceP_timeoutSec);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_ImagerConfigSet(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ImagerConfigData& iceP_config, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigSet_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigSet_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_config);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_ImagerConfigGet(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::ImagerConfigData>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigGet_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigGet_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_SlideLeavedImager(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ImagerSlideLeavedReason iceP_reason, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_SlideLeavedImager_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_reason);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetAllRunInformations(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::RunInformationArray>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetAllRunInformations_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetAllRunInformations_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetRunInformation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::ImagerSetupInfo>>& outAsync, const ::std::string& iceP_slideID, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetRunInformation_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetRunInformation_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_slideID);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetBasecallInformation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::std::string& iceP_slideID, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallInformation_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallInformation_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_slideID);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_EndCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, bool iceP_reSeq, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_EndCycle_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_EndCycle_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_reSeq);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_StartRunScript(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::std::string& iceP_scriptName, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_StartRunScript_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_StartRunScript_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_scriptName);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetBasecallFlowcellConsumptionDiskSpace(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ImagerControlMgrIPC::GetBasecallFlowcellConsumptionDiskSpaceResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ImagerControlMgrIPC::GetBasecallFlowcellConsumptionDiskSpaceResult v;
            istr->readAll(v.value, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetBasecallRemoteDiskSpace(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ImagerControlMgrIPC::GetBasecallRemoteDiskSpaceResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ImagerControlMgrIPC::GetBasecallRemoteDiskSpaceResult v;
            istr->readAll(v.value, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetBasecallLocalDiskSpace(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ImagerControlMgrIPC::GetBasecallLocalDiskSpaceResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallLocalDiskSpace_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallLocalDiskSpace_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ImagerControlMgrIPC::GetBasecallLocalDiskSpaceResult v;
            istr->readAll(v.value, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetParam(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ImagerControlMgrIPC::GetParamResult>>& outAsync, const ::std::string& iceP_name, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetParam_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetParam_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name);
        },
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ImagerControlMgrIPC::GetParamResult v;
            istr->readAll(v.value, v.returnValue);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_SetParam(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>& outAsync, const ::std::string& iceP_name, const ::std::string& iceP_value, bool iceP_saveToDisk, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_SetParam_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_SetParam_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_name, iceP_value, iceP_saveToDisk);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetVersions(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ImagerControlMgrIPC::GetVersionsResult>>& outAsync, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetVersions_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetVersions_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        nullptr,
        nullptr,
        [](::Ice::InputStream* istr)
        {
            ImagerControlMgrIPC::GetVersionsResult v;
            istr->readAll(v.bcsVer, v.sbcVer, v.imagerVer);
            return v;
        });
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
BGI::RPC::ImagerControlMgrIPCPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ImagerControlMgrIPCPrx>();
}
/// \endcond

const ::std::string&
BGI::RPC::ImagerControlMgrIPCPrx::ice_staticId()
{
    return ImagerControlMgrIPC::ice_staticId();
}

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCCallbackPrx::_iceI_SendImagerError(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, ImagerErrorEnum iceP_error, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerError_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_error);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCCallbackPrx::_iceI_SendImagerRunInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ImagerRunInfo& iceP_info, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerRunInfo_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCCallbackPrx::_iceI_SendImagerTaskEnd(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ImagerSetupInfo& iceP_info, ImagerErrorEnum iceP_error, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerTaskEnd_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_info, iceP_error);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCCallbackPrx::_iceI_SendData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, const ::std::string& iceP_key, const ::std::string& iceP_value, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendData_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_key, iceP_value);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCCallbackPrx::_iceI_SendHeartbeat(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>& outAsync, int iceP_count, const ::Ice::Context& context)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendHeartbeat_name);
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendHeartbeat_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_count);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::ImagerControlMgrIPCCallbackPrx::_iceI_SendStatus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>& outAsync, BasecallConnectState iceP_StateBasecall, ImagerServerState iceP_StateServer, ImagerState iceP_StateImager, const ::Ice::Context& context)
{
    outAsync->invoke(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendStatus_name, ::Ice::OperationMode::Normal, ::Ice::FormatType::DefaultFormat, context,
        [&](::Ice::OutputStream* ostr)
        {
            ostr->writeAll(iceP_StateBasecall, iceP_StateServer, iceP_StateImager);
        },
        nullptr);
}
/// \endcond

/// \cond INTERNAL
::std::shared_ptr<::Ice::ObjectPrx>
BGI::RPC::ImagerControlMgrIPCCallbackPrx::_newInstance() const
{
    return ::IceInternal::createProxy<ImagerControlMgrIPCCallbackPrx>();
}
/// \endcond

const ::std::string&
BGI::RPC::ImagerControlMgrIPCCallbackPrx::ice_staticId()
{
    return ImagerControlMgrIPCCallback::ice_staticId();
}

namespace Ice
{
}

#else // C++98 mapping

namespace
{

namespace
{

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_ImagerSetup_name = "ImagerSetup";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_Reset_name = "Reset";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_SetupRun_name = "SetupRun";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_ReleaseRun_name = "ReleaseRun";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GoHome_name = "GoHome";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GoLoadingPos_name = "GoLoadingPos";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GoWashPos_name = "GoWashPos";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_IsAtLoadPosition_name = "IsAtLoadPosition";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_SwitchVacuum_name = "SwitchVacuum";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetVacuumStatus_name = "GetVacuumStatus";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_PreInjectSRE_name = "PreInjectSRE";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_PreProcessing_name = "PreProcessing";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigSet_name = "ImagerConfigSet";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigGet_name = "ImagerConfigGet";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_SlideLeavedImager_name = "SlideLeavedImager";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetAllRunInformations_name = "GetAllRunInformations";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetRunInformation_name = "GetRunInformation";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallInformation_name = "GetBasecallInformation";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_EndCycle_name = "EndCycle";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_StartRunScript_name = "StartRunScript";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace_name = "GetBasecallFlowcellConsumptionDiskSpace";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace_name = "GetBasecallRemoteDiskSpace";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallLocalDiskSpace_name = "GetBasecallLocalDiskSpace";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetParam_name = "GetParam";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_SetParam_name = "SetParam";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_GetVersions_name = "GetVersions";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerError_name = "SendImagerError";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerRunInfo_name = "SendImagerRunInfo";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerTaskEnd_name = "SendImagerTaskEnd";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendData_name = "SendData";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendHeartbeat_name = "SendHeartbeat";

const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendStatus_name = "SendStatus";

}

}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::BGI::RPC::upCast(ImagerControlMgrIPC* p) { return p; }

void
::IceProxy::BGI::RPC::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ImagerControlMgrIPC>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ImagerControlMgrIPC;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_ImagerSetup(const ::BGI::RPC::ImagerSetupInfo& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerSetup_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_ImagerSetup_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerSetup_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerSetup_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_ImagerSetup(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_ImagerSetup_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_Reset(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_Reset_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_Reset_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_Reset_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_Reset_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_Reset(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_Reset_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_SetupRun(const ::BGI::RPC::ImagerSetupInfo& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_SetupRun_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_SetupRun_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_SetupRun_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_SetupRun_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_SetupRun(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_SetupRun_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_ReleaseRun(const ::BGI::RPC::ImagerSetupInfo& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_ReleaseRun_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_ReleaseRun_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_ReleaseRun_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_ReleaseRun_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_ReleaseRun(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_ReleaseRun_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_GoHome(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GoHome_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_GoHome_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_GoHome_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GoHome_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_GoHome(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GoHome_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_GoLoadingPos(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GoLoadingPos_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_GoLoadingPos_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_GoLoadingPos_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GoLoadingPos_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_GoLoadingPos(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GoLoadingPos_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_GoWashPos(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GoWashPos_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_GoWashPos_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_GoWashPos_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GoWashPos_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_GoWashPos(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GoWashPos_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_IsAtLoadPosition(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_IsAtLoadPosition_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_IsAtLoadPosition_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_IsAtLoadPosition_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_IsAtLoadPosition_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_IsAtLoadPosition(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_IsAtLoadPosition_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_SwitchVacuum(bool iceP_valveStatus, bool iceP_pumpStatus, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_SwitchVacuum_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_SwitchVacuum_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_SwitchVacuum_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_valveStatus);
        ostr->write(iceP_pumpStatus);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_SwitchVacuum_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_SwitchVacuum(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_SwitchVacuum_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_GetVacuumStatus(::Ice::Double iceP_thresholdValueMin, ::Ice::Double iceP_thresholdValueMax, ::Ice::Int iceP_timeoutSec, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetVacuumStatus_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_GetVacuumStatus_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_GetVacuumStatus_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_thresholdValueMin);
        ostr->write(iceP_thresholdValueMax);
        ostr->write(iceP_timeoutSec);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetVacuumStatus_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_GetVacuumStatus(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetVacuumStatus_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_PreInjectSRE(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_PreInjectSRE_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_PreInjectSRE_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_PreInjectSRE_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_PreInjectSRE_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_PreInjectSRE(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_PreInjectSRE_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_PreProcessing(::BGI::RPC::PreProcessingEnum iceP_type, ::Ice::Int iceP_timeoutSec, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_PreProcessing_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_PreProcessing_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_PreProcessing_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_type);
        ostr->write(iceP_timeoutSec);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_PreProcessing_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_PreProcessing(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_PreProcessing_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_ImagerConfigSet(const ::BGI::RPC::ImagerConfigData& iceP_config, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigSet_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigSet_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigSet_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_config);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigSet_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_ImagerConfigSet(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigSet_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_ImagerConfigGet(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigGet_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigGet_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigGet_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigGet_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::BGI::RPC::ImagerConfigData
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_ImagerConfigGet(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_ImagerConfigGet_name);
    ::BGI::RPC::ImagerConfigData ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_SlideLeavedImager(::BGI::RPC::ImagerSlideLeavedReason iceP_reason, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_SlideLeavedImager_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_SlideLeavedImager_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_reason);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_SlideLeavedImager_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_SlideLeavedImager(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_BGI_RPC_ImagerControlMgrIPC_SlideLeavedImager_name);
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_GetAllRunInformations(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetAllRunInformations_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_GetAllRunInformations_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_GetAllRunInformations_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetAllRunInformations_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::BGI::RPC::RunInformationArray
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_GetAllRunInformations(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetAllRunInformations_name);
    ::BGI::RPC::RunInformationArray ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_GetRunInformation(const ::std::string& iceP_slideID, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetRunInformation_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_GetRunInformation_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_GetRunInformation_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_slideID);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetRunInformation_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_GetRunInformation(::BGI::RPC::ImagerSetupInfo& iceP_runInfo, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetRunInformation_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_runInfo);
    result->_endReadParams();
}

void IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_end_GetRunInformation(::BGI::RPC::ImagerSetupInfo& iceP_runInfo, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetRunInformation_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_runInfo);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_GetBasecallInformation(const ::std::string& iceP_slideID, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallInformation_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallInformation_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallInformation_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_slideID);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallInformation_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_GetBasecallInformation(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallInformation_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_EndCycle(bool iceP_reSeq, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_EndCycle_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_EndCycle_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_EndCycle_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_reSeq);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_EndCycle_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_EndCycle(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_EndCycle_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_StartRunScript(const ::std::string& iceP_scriptName, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_StartRunScript_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_StartRunScript_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_StartRunScript_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_scriptName);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_StartRunScript_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_StartRunScript(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_StartRunScript_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_GetBasecallFlowcellConsumptionDiskSpace(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_GetBasecallFlowcellConsumptionDiskSpace(::Ice::Double& iceP_value, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_value);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_end_GetBasecallFlowcellConsumptionDiskSpace(::Ice::Double& iceP_value, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_value);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_GetBasecallRemoteDiskSpace(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_GetBasecallRemoteDiskSpace(::Ice::Double& iceP_value, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_value);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_end_GetBasecallRemoteDiskSpace(::Ice::Double& iceP_value, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_value);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_GetBasecallLocalDiskSpace(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallLocalDiskSpace_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallLocalDiskSpace_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallLocalDiskSpace_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallLocalDiskSpace_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_GetBasecallLocalDiskSpace(::Ice::Double& iceP_value, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallLocalDiskSpace_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_value);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_end_GetBasecallLocalDiskSpace(::Ice::Double& iceP_value, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetBasecallLocalDiskSpace_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_value);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_GetParam(const ::std::string& iceP_name, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetParam_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_GetParam_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_GetParam_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetParam_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_GetParam(::std::string& iceP_value, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetParam_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_value);
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

void IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_end_GetParam(::std::string& iceP_value, bool& ret, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetParam_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_value);
    istr->read(ret);
    result->_endReadParams();
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_SetParam(const ::std::string& iceP_name, const ::std::string& iceP_value, bool iceP_saveToDisk, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_SetParam_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_SetParam_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_SetParam_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_name);
        ostr->write(iceP_value);
        ostr->write(iceP_saveToDisk);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_SetParam_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

bool
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_SetParam(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_SetParam_name);
    bool ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_begin_GetVersions(const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPC_GetVersions_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPC_GetVersions_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPC_GetVersions_name, ::Ice::Normal, context);
        result->writeEmptyParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPC_GetVersions_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::BGI::RPC::ImagerControlMgrIPC::end_GetVersions(::std::string& iceP_bcsVer, ::std::string& iceP_sbcVer, ::std::string& iceP_imagerVer, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetVersions_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_bcsVer);
    istr->read(iceP_sbcVer);
    istr->read(iceP_imagerVer);
    result->_endReadParams();
}

void IceProxy::BGI::RPC::ImagerControlMgrIPC::_iceI_end_GetVersions(::std::string& iceP_bcsVer, ::std::string& iceP_sbcVer, ::std::string& iceP_imagerVer, const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPC_GetVersions_name);
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(iceP_bcsVer);
    istr->read(iceP_sbcVer);
    istr->read(iceP_imagerVer);
    result->_endReadParams();
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::BGI::RPC::ImagerControlMgrIPC::_newInstance() const
{
    return new ImagerControlMgrIPC;
}
/// \endcond

const ::std::string&
IceProxy::BGI::RPC::ImagerControlMgrIPC::ice_staticId()
{
    return ::BGI::RPC::ImagerControlMgrIPC::ice_staticId();
}

/// \cond INTERNAL
::IceProxy::Ice::Object* ::IceProxy::BGI::RPC::upCast(ImagerControlMgrIPCCallback* p) { return p; }

void
::IceProxy::BGI::RPC::_readProxy(::Ice::InputStream* istr, ::IceInternal::ProxyHandle< ImagerControlMgrIPCCallback>& v)
{
    ::Ice::ObjectPrx proxy;
    istr->read(proxy);
    if(!proxy)
    {
        v = 0;
    }
    else
    {
        v = new ImagerControlMgrIPCCallback;
        v->_copyFrom(proxy);
    }
}
/// \endcond

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::_iceI_begin_SendImagerError(::BGI::RPC::ImagerErrorEnum iceP_error, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerError_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerError_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_error);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerError_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::end_SendImagerError(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerError_name);
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::_iceI_begin_SendImagerRunInfo(const ::BGI::RPC::ImagerRunInfo& iceP_info, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerRunInfo_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerRunInfo_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_info);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerRunInfo_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::end_SendImagerRunInfo(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerRunInfo_name);
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::_iceI_begin_SendImagerTaskEnd(const ::BGI::RPC::ImagerSetupInfo& iceP_info, ::BGI::RPC::ImagerErrorEnum iceP_error, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerTaskEnd_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerTaskEnd_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_info);
        ostr->write(iceP_error);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerTaskEnd_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::end_SendImagerTaskEnd(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendImagerTaskEnd_name);
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::_iceI_begin_SendData(const ::std::string& iceP_key, const ::std::string& iceP_value, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendData_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendData_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_key);
        ostr->write(iceP_value);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendData_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::end_SendData(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendData_name);
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::_iceI_begin_SendHeartbeat(::Ice::Int iceP_count, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    _checkTwowayOnly(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendHeartbeat_name, sync);
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendHeartbeat_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendHeartbeat_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_count);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendHeartbeat_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

::Ice::Int
IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::end_SendHeartbeat(const ::Ice::AsyncResultPtr& result)
{
    ::Ice::AsyncResult::_check(result, this, iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendHeartbeat_name);
    ::Ice::Int ret;
    if(!result->_waitForResponse())
    {
        try
        {
            result->_throwUserException();
        }
        catch(const ::Ice::UserException& ex)
        {
            throw ::Ice::UnknownUserException(__FILE__, __LINE__, ex.ice_id());
        }
    }
    ::Ice::InputStream* istr = result->_startReadParams();
    istr->read(ret);
    result->_endReadParams();
    return ret;
}

::Ice::AsyncResultPtr
IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::_iceI_begin_SendStatus(::BGI::RPC::BasecallConnectState iceP_StateBasecall, ::BGI::RPC::ImagerServerState iceP_StateServer, ::BGI::RPC::ImagerState iceP_StateImager, const ::Ice::Context& context, const ::IceInternal::CallbackBasePtr& del, const ::Ice::LocalObjectPtr& cookie, bool sync)
{
    ::IceInternal::OutgoingAsyncPtr result = new ::IceInternal::CallbackOutgoing(this, iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendStatus_name, del, cookie, sync);
    try
    {
        result->prepare(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendStatus_name, ::Ice::Normal, context);
        ::Ice::OutputStream* ostr = result->startWriteParams(::Ice::DefaultFormat);
        ostr->write(iceP_StateBasecall);
        ostr->write(iceP_StateServer);
        ostr->write(iceP_StateImager);
        result->endWriteParams();
        result->invoke(iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendStatus_name);
    }
    catch(const ::Ice::Exception& ex)
    {
        result->abort(ex);
    }
    return result;
}

void
IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::end_SendStatus(const ::Ice::AsyncResultPtr& result)
{
    _end(result, iceC_BGI_RPC_ImagerControlMgrIPCCallback_SendStatus_name);
}

/// \cond INTERNAL
::IceProxy::Ice::Object*
IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::_newInstance() const
{
    return new ImagerControlMgrIPCCallback;
}
/// \endcond

const ::std::string&
IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::ice_staticId()
{
    return ::BGI::RPC::ImagerControlMgrIPCCallback::ice_staticId();
}

BGI::RPC::ImagerControlMgrIPC::~ImagerControlMgrIPC()
{
}

/// \cond INTERNAL
::Ice::Object* BGI::RPC::upCast(ImagerControlMgrIPC* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_ids[3] =
{
    "::BGI::RPC::ImagerControlMgrIPC",
    "::BGI::RPC::StageRunMgrIPC",
    "::Ice::Object"
};

}

bool
BGI::RPC::ImagerControlMgrIPC::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_BGI_RPC_ImagerControlMgrIPC_ids, iceC_BGI_RPC_ImagerControlMgrIPC_ids + 3, s);
}

::std::vector< ::std::string>
BGI::RPC::ImagerControlMgrIPC::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_BGI_RPC_ImagerControlMgrIPC_ids[0], &iceC_BGI_RPC_ImagerControlMgrIPC_ids[3]);
}

const ::std::string&
BGI::RPC::ImagerControlMgrIPC::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
BGI::RPC::ImagerControlMgrIPC::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::BGI::RPC::ImagerControlMgrIPC";
    return typeId;
#else
    return iceC_BGI_RPC_ImagerControlMgrIPC_ids[0];
#endif
}

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_ImagerSetup(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ImagerSetupInfo iceP_info;
    istr->read(iceP_info);
    inS.endReadParams();
    bool ret = this->ImagerSetup(iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_Reset(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->Reset(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_SetupRun(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ImagerSetupInfo iceP_info;
    istr->read(iceP_info);
    inS.endReadParams();
    bool ret = this->SetupRun(iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_ReleaseRun(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ImagerSetupInfo iceP_info;
    istr->read(iceP_info);
    inS.endReadParams();
    bool ret = this->ReleaseRun(iceP_info, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GoHome(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->GoHome(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GoLoadingPos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->GoLoadingPos(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GoWashPos(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->GoWashPos(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_IsAtLoadPosition(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->IsAtLoadPosition(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_SwitchVacuum(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    bool iceP_valveStatus;
    bool iceP_pumpStatus;
    istr->read(iceP_valveStatus);
    istr->read(iceP_pumpStatus);
    inS.endReadParams();
    bool ret = this->SwitchVacuum(iceP_valveStatus, iceP_pumpStatus, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetVacuumStatus(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Double iceP_thresholdValueMin;
    ::Ice::Double iceP_thresholdValueMax;
    ::Ice::Int iceP_timeoutSec;
    istr->read(iceP_thresholdValueMin);
    istr->read(iceP_thresholdValueMax);
    istr->read(iceP_timeoutSec);
    inS.endReadParams();
    bool ret = this->GetVacuumStatus(iceP_thresholdValueMin, iceP_thresholdValueMax, iceP_timeoutSec, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_PreInjectSRE(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    bool ret = this->PreInjectSRE(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_PreProcessing(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    PreProcessingEnum iceP_type;
    ::Ice::Int iceP_timeoutSec;
    istr->read(iceP_type);
    istr->read(iceP_timeoutSec);
    inS.endReadParams();
    bool ret = this->PreProcessing(iceP_type, iceP_timeoutSec, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_ImagerConfigSet(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ImagerConfigData iceP_config;
    istr->read(iceP_config);
    inS.endReadParams();
    bool ret = this->ImagerConfigSet(iceP_config, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_ImagerConfigGet(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ImagerConfigData ret = this->ImagerConfigGet(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_SlideLeavedImager(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ImagerSlideLeavedReason iceP_reason;
    istr->read(iceP_reason);
    inS.endReadParams();
    this->SlideLeavedImager(iceP_reason, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetAllRunInformations(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    RunInformationArray ret = this->GetAllRunInformations(current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetRunInformation(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_slideID;
    istr->read(iceP_slideID);
    inS.endReadParams();
    ImagerSetupInfo iceP_runInfo;
    this->GetRunInformation(iceP_slideID, iceP_runInfo, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_runInfo);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetBasecallInformation(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_slideID;
    istr->read(iceP_slideID);
    inS.endReadParams();
    bool ret = this->GetBasecallInformation(iceP_slideID, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_EndCycle(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    bool iceP_reSeq;
    istr->read(iceP_reSeq);
    inS.endReadParams();
    bool ret = this->EndCycle(iceP_reSeq, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_StartRunScript(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_scriptName;
    istr->read(iceP_scriptName);
    inS.endReadParams();
    bool ret = this->StartRunScript(iceP_scriptName, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetBasecallFlowcellConsumptionDiskSpace(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Double iceP_value;
    bool ret = this->GetBasecallFlowcellConsumptionDiskSpace(iceP_value, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_value);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetBasecallRemoteDiskSpace(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Double iceP_value;
    bool ret = this->GetBasecallRemoteDiskSpace(iceP_value, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_value);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetBasecallLocalDiskSpace(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::Ice::Double iceP_value;
    bool ret = this->GetBasecallLocalDiskSpace(iceP_value, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_value);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetParam(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    istr->read(iceP_name);
    inS.endReadParams();
    ::std::string iceP_value;
    bool ret = this->GetParam(iceP_name, iceP_value, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_value);
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_SetParam(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_name;
    ::std::string iceP_value;
    bool iceP_saveToDisk;
    istr->read(iceP_name);
    istr->read(iceP_value);
    istr->read(iceP_saveToDisk);
    inS.endReadParams();
    bool ret = this->SetParam(iceP_name, iceP_value, iceP_saveToDisk, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceD_GetVersions(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    inS.readEmptyParams();
    ::std::string iceP_bcsVer;
    ::std::string iceP_sbcVer;
    ::std::string iceP_imagerVer;
    this->GetVersions(iceP_bcsVer, iceP_sbcVer, iceP_imagerVer, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(iceP_bcsVer);
    ostr->write(iceP_sbcVer);
    ostr->write(iceP_imagerVer);
    inS.endWriteParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPC_all[] =
{
    "AbortScript",
    "Authenicate",
    "ClearAlarmMessages",
    "DownloadScriptFile",
    "EndCycle",
    "GetAlarmMessages",
    "GetAllRunInformations",
    "GetBasecallFlowcellConsumptionDiskSpace",
    "GetBasecallInformation",
    "GetBasecallLocalDiskSpace",
    "GetBasecallRemoteDiskSpace",
    "GetExperimentInfo",
    "GetHeartbeat",
    "GetLanguage",
    "GetLogMessages",
    "GetParaValue",
    "GetParam",
    "GetQCValues",
    "GetRunInformation",
    "GetScriptMessages",
    "GetScriptRunInfo",
    "GetSequenceTypes",
    "GetVacuumStatus",
    "GetVersions",
    "GetZLIMSAddr",
    "GoHome",
    "GoLoadingPos",
    "GoWashPos",
    "ImagerConfigGet",
    "ImagerConfigSet",
    "ImagerSetup",
    "IsAtLoadPosition",
    "MotorMove",
    "OverrideFlowcellBarcode",
    "PauseScript",
    "PreInjectSRE",
    "PreProcessing",
    "ReagentNeedle",
    "ReleaseRun",
    "Reset",
    "ResumeScript",
    "RunScriptNow",
    "SaveSelectedScriptFileName",
    "ScanFlowcellBarcode",
    "ScanReagentKitBarcode",
    "SendExperimentType",
    "SendReagentKit",
    "SendSampleId",
    "SetBaseCallIpAddr",
    "SetBuzzerVolume",
    "SetCategoryParas",
    "SetClearData",
    "SetLanguage",
    "SetParam",
    "SetZLIMSIpAddr",
    "SetupRun",
    "SetupRunInfo",
    "SetupScriptFile",
    "SlideLeavedImager",
    "StartRun",
    "StartRunLength",
    "StartRunScript",
    "StartSelfCheck",
    "StartSetup",
    "StopScript",
    "SwitchVacuum",
    "UIOperation",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPC::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_BGI_RPC_ImagerControlMgrIPC_all, iceC_BGI_RPC_ImagerControlMgrIPC_all + 71, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_BGI_RPC_ImagerControlMgrIPC_all)
    {
        case 0:
        {
            return _iceD_AbortScript(in, current);
        }
        case 1:
        {
            return _iceD_Authenicate(in, current);
        }
        case 2:
        {
            return _iceD_ClearAlarmMessages(in, current);
        }
        case 3:
        {
            return _iceD_DownloadScriptFile(in, current);
        }
        case 4:
        {
            return _iceD_EndCycle(in, current);
        }
        case 5:
        {
            return _iceD_GetAlarmMessages(in, current);
        }
        case 6:
        {
            return _iceD_GetAllRunInformations(in, current);
        }
        case 7:
        {
            return _iceD_GetBasecallFlowcellConsumptionDiskSpace(in, current);
        }
        case 8:
        {
            return _iceD_GetBasecallInformation(in, current);
        }
        case 9:
        {
            return _iceD_GetBasecallLocalDiskSpace(in, current);
        }
        case 10:
        {
            return _iceD_GetBasecallRemoteDiskSpace(in, current);
        }
        case 11:
        {
            return _iceD_GetExperimentInfo(in, current);
        }
        case 12:
        {
            return _iceD_GetHeartbeat(in, current);
        }
        case 13:
        {
            return _iceD_GetLanguage(in, current);
        }
        case 14:
        {
            return _iceD_GetLogMessages(in, current);
        }
        case 15:
        {
            return _iceD_GetParaValue(in, current);
        }
        case 16:
        {
            return _iceD_GetParam(in, current);
        }
        case 17:
        {
            return _iceD_GetQCValues(in, current);
        }
        case 18:
        {
            return _iceD_GetRunInformation(in, current);
        }
        case 19:
        {
            return _iceD_GetScriptMessages(in, current);
        }
        case 20:
        {
            return _iceD_GetScriptRunInfo(in, current);
        }
        case 21:
        {
            return _iceD_GetSequenceTypes(in, current);
        }
        case 22:
        {
            return _iceD_GetVacuumStatus(in, current);
        }
        case 23:
        {
            return _iceD_GetVersions(in, current);
        }
        case 24:
        {
            return _iceD_GetZLIMSAddr(in, current);
        }
        case 25:
        {
            return _iceD_GoHome(in, current);
        }
        case 26:
        {
            return _iceD_GoLoadingPos(in, current);
        }
        case 27:
        {
            return _iceD_GoWashPos(in, current);
        }
        case 28:
        {
            return _iceD_ImagerConfigGet(in, current);
        }
        case 29:
        {
            return _iceD_ImagerConfigSet(in, current);
        }
        case 30:
        {
            return _iceD_ImagerSetup(in, current);
        }
        case 31:
        {
            return _iceD_IsAtLoadPosition(in, current);
        }
        case 32:
        {
            return _iceD_MotorMove(in, current);
        }
        case 33:
        {
            return _iceD_OverrideFlowcellBarcode(in, current);
        }
        case 34:
        {
            return _iceD_PauseScript(in, current);
        }
        case 35:
        {
            return _iceD_PreInjectSRE(in, current);
        }
        case 36:
        {
            return _iceD_PreProcessing(in, current);
        }
        case 37:
        {
            return _iceD_ReagentNeedle(in, current);
        }
        case 38:
        {
            return _iceD_ReleaseRun(in, current);
        }
        case 39:
        {
            return _iceD_Reset(in, current);
        }
        case 40:
        {
            return _iceD_ResumeScript(in, current);
        }
        case 41:
        {
            return _iceD_RunScriptNow(in, current);
        }
        case 42:
        {
            return _iceD_SaveSelectedScriptFileName(in, current);
        }
        case 43:
        {
            return _iceD_ScanFlowcellBarcode(in, current);
        }
        case 44:
        {
            return _iceD_ScanReagentKitBarcode(in, current);
        }
        case 45:
        {
            return _iceD_SendExperimentType(in, current);
        }
        case 46:
        {
            return _iceD_SendReagentKit(in, current);
        }
        case 47:
        {
            return _iceD_SendSampleId(in, current);
        }
        case 48:
        {
            return _iceD_SetBaseCallIpAddr(in, current);
        }
        case 49:
        {
            return _iceD_SetBuzzerVolume(in, current);
        }
        case 50:
        {
            return _iceD_SetCategoryParas(in, current);
        }
        case 51:
        {
            return _iceD_SetClearData(in, current);
        }
        case 52:
        {
            return _iceD_SetLanguage(in, current);
        }
        case 53:
        {
            return _iceD_SetParam(in, current);
        }
        case 54:
        {
            return _iceD_SetZLIMSIpAddr(in, current);
        }
        case 55:
        {
            return _iceD_SetupRun(in, current);
        }
        case 56:
        {
            return _iceD_SetupRunInfo(in, current);
        }
        case 57:
        {
            return _iceD_SetupScriptFile(in, current);
        }
        case 58:
        {
            return _iceD_SlideLeavedImager(in, current);
        }
        case 59:
        {
            return _iceD_StartRun(in, current);
        }
        case 60:
        {
            return _iceD_StartRunLength(in, current);
        }
        case 61:
        {
            return _iceD_StartRunScript(in, current);
        }
        case 62:
        {
            return _iceD_StartSelfCheck(in, current);
        }
        case 63:
        {
            return _iceD_StartSetup(in, current);
        }
        case 64:
        {
            return _iceD_StopScript(in, current);
        }
        case 65:
        {
            return _iceD_SwitchVacuum(in, current);
        }
        case 66:
        {
            return _iceD_UIOperation(in, current);
        }
        case 67:
        {
            return _iceD_ice_id(in, current);
        }
        case 68:
        {
            return _iceD_ice_ids(in, current);
        }
        case 69:
        {
            return _iceD_ice_isA(in, current);
        }
        case 70:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
BGI::RPC::ImagerControlMgrIPC::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ImagerControlMgrIPC, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
BGI::RPC::ImagerControlMgrIPC::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ImagerControlMgrIPC, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::_icePatchObjectPtr(ImagerControlMgrIPCPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ImagerControlMgrIPCPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ImagerControlMgrIPC::ice_staticId(), v);
    }
}
/// \endcond

BGI::RPC::ImagerControlMgrIPCCallback::~ImagerControlMgrIPCCallback()
{
}

/// \cond INTERNAL
::Ice::Object* BGI::RPC::upCast(ImagerControlMgrIPCCallback* p) { return p; }

/// \endcond

namespace
{
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_ids[3] =
{
    "::BGI::RPC::ImagerControlMgrIPCCallback",
    "::BGI::RPC::StageRunMgrIPCCallback",
    "::Ice::Object"
};

}

bool
BGI::RPC::ImagerControlMgrIPCCallback::ice_isA(const ::std::string& s, const ::Ice::Current&) const
{
    return ::std::binary_search(iceC_BGI_RPC_ImagerControlMgrIPCCallback_ids, iceC_BGI_RPC_ImagerControlMgrIPCCallback_ids + 3, s);
}

::std::vector< ::std::string>
BGI::RPC::ImagerControlMgrIPCCallback::ice_ids(const ::Ice::Current&) const
{
    return ::std::vector< ::std::string>(&iceC_BGI_RPC_ImagerControlMgrIPCCallback_ids[0], &iceC_BGI_RPC_ImagerControlMgrIPCCallback_ids[3]);
}

const ::std::string&
BGI::RPC::ImagerControlMgrIPCCallback::ice_id(const ::Ice::Current&) const
{
    return ice_staticId();
}

const ::std::string&
BGI::RPC::ImagerControlMgrIPCCallback::ice_staticId()
{
#ifdef ICE_HAS_THREAD_SAFE_LOCAL_STATIC
    static const ::std::string typeId = "::BGI::RPC::ImagerControlMgrIPCCallback";
    return typeId;
#else
    return iceC_BGI_RPC_ImagerControlMgrIPCCallback_ids[0];
#endif
}

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPCCallback::_iceD_SendImagerError(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ImagerErrorEnum iceP_error;
    istr->read(iceP_error);
    inS.endReadParams();
    this->SendImagerError(iceP_error, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPCCallback::_iceD_SendImagerRunInfo(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ImagerRunInfo iceP_info;
    istr->read(iceP_info);
    inS.endReadParams();
    this->SendImagerRunInfo(iceP_info, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPCCallback::_iceD_SendImagerTaskEnd(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ImagerSetupInfo iceP_info;
    ImagerErrorEnum iceP_error;
    istr->read(iceP_info);
    istr->read(iceP_error);
    inS.endReadParams();
    this->SendImagerTaskEnd(iceP_info, iceP_error, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPCCallback::_iceD_SendData(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::std::string iceP_key;
    ::std::string iceP_value;
    istr->read(iceP_key);
    istr->read(iceP_value);
    inS.endReadParams();
    this->SendData(iceP_key, iceP_value, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPCCallback::_iceD_SendHeartbeat(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    ::Ice::Int iceP_count;
    istr->read(iceP_count);
    inS.endReadParams();
    ::Ice::Int ret = this->SendHeartbeat(iceP_count, current);
    ::Ice::OutputStream* ostr = inS.startWriteParams();
    ostr->write(ret);
    inS.endWriteParams();
    return true;
}
/// \endcond

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPCCallback::_iceD_SendStatus(::IceInternal::Incoming& inS, const ::Ice::Current& current)
{
    _iceCheckMode(::Ice::Normal, current.mode);
    ::Ice::InputStream* istr = inS.startReadParams();
    BasecallConnectState iceP_StateBasecall;
    ImagerServerState iceP_StateServer;
    ImagerState iceP_StateImager;
    istr->read(iceP_StateBasecall);
    istr->read(iceP_StateServer);
    istr->read(iceP_StateImager);
    inS.endReadParams();
    this->SendStatus(iceP_StateBasecall, iceP_StateServer, iceP_StateImager, current);
    inS.writeEmptyParams();
    return true;
}
/// \endcond

namespace
{
const ::std::string iceC_BGI_RPC_ImagerControlMgrIPCCallback_all[] =
{
    "AddClient",
    "SendActionName",
    "SendAlarmMessageId",
    "SendData",
    "SendDataList",
    "SendFlowcellBarcode",
    "SendHeartbeat",
    "SendImagerError",
    "SendImagerRunInfo",
    "SendImagerTaskEnd",
    "SendLogMessageId",
    "SendPcntDone",
    "SendPositionNumber",
    "SendQCValue",
    "SendQCValues",
    "SendRemainingTime",
    "SendScriptMessageId",
    "SendScriptName",
    "SendScriptStatus",
    "SendStageMessage",
    "SendStatus",
    "ice_id",
    "ice_ids",
    "ice_isA",
    "ice_ping"
};

}

/// \cond INTERNAL
bool
BGI::RPC::ImagerControlMgrIPCCallback::_iceDispatch(::IceInternal::Incoming& in, const ::Ice::Current& current)
{
    ::std::pair<const ::std::string*, const ::std::string*> r = ::std::equal_range(iceC_BGI_RPC_ImagerControlMgrIPCCallback_all, iceC_BGI_RPC_ImagerControlMgrIPCCallback_all + 25, current.operation);
    if(r.first == r.second)
    {
        throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
    }

    switch(r.first - iceC_BGI_RPC_ImagerControlMgrIPCCallback_all)
    {
        case 0:
        {
            return _iceD_AddClient(in, current);
        }
        case 1:
        {
            return _iceD_SendActionName(in, current);
        }
        case 2:
        {
            return _iceD_SendAlarmMessageId(in, current);
        }
        case 3:
        {
            return _iceD_SendData(in, current);
        }
        case 4:
        {
            return _iceD_SendDataList(in, current);
        }
        case 5:
        {
            return _iceD_SendFlowcellBarcode(in, current);
        }
        case 6:
        {
            return _iceD_SendHeartbeat(in, current);
        }
        case 7:
        {
            return _iceD_SendImagerError(in, current);
        }
        case 8:
        {
            return _iceD_SendImagerRunInfo(in, current);
        }
        case 9:
        {
            return _iceD_SendImagerTaskEnd(in, current);
        }
        case 10:
        {
            return _iceD_SendLogMessageId(in, current);
        }
        case 11:
        {
            return _iceD_SendPcntDone(in, current);
        }
        case 12:
        {
            return _iceD_SendPositionNumber(in, current);
        }
        case 13:
        {
            return _iceD_SendQCValue(in, current);
        }
        case 14:
        {
            return _iceD_SendQCValues(in, current);
        }
        case 15:
        {
            return _iceD_SendRemainingTime(in, current);
        }
        case 16:
        {
            return _iceD_SendScriptMessageId(in, current);
        }
        case 17:
        {
            return _iceD_SendScriptName(in, current);
        }
        case 18:
        {
            return _iceD_SendScriptStatus(in, current);
        }
        case 19:
        {
            return _iceD_SendStageMessage(in, current);
        }
        case 20:
        {
            return _iceD_SendStatus(in, current);
        }
        case 21:
        {
            return _iceD_ice_id(in, current);
        }
        case 22:
        {
            return _iceD_ice_ids(in, current);
        }
        case 23:
        {
            return _iceD_ice_isA(in, current);
        }
        case 24:
        {
            return _iceD_ice_ping(in, current);
        }
        default:
        {
            assert(false);
            throw ::Ice::OperationNotExistException(__FILE__, __LINE__, current.id, current.facet, current.operation);
        }
    }
}
/// \endcond

/// \cond STREAM
void
BGI::RPC::ImagerControlMgrIPCCallback::_iceWriteImpl(::Ice::OutputStream* ostr) const
{
    ostr->startSlice(ice_staticId(), -1, true);
    ::Ice::StreamWriter< ImagerControlMgrIPCCallback, ::Ice::OutputStream>::write(ostr, *this);
    ostr->endSlice();
}

void
BGI::RPC::ImagerControlMgrIPCCallback::_iceReadImpl(::Ice::InputStream* istr)
{
    istr->startSlice();
    ::Ice::StreamReader< ImagerControlMgrIPCCallback, ::Ice::InputStream>::read(istr, *this);
    istr->endSlice();
}
/// \endcond

/// \cond INTERNAL
void
BGI::RPC::_icePatchObjectPtr(ImagerControlMgrIPCCallbackPtr& handle, const ::Ice::ObjectPtr& v)
{
    handle = ImagerControlMgrIPCCallbackPtr::dynamicCast(v);
    if(v && !handle)
    {
        IceInternal::Ex::throwUOE(ImagerControlMgrIPCCallback::ice_staticId(), v);
    }
}
/// \endcond

namespace Ice
{
}

#endif
