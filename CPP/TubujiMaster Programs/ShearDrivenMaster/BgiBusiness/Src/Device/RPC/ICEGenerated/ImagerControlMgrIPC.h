//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.8
//
// <auto-generated>
//
// Generated from file `ImagerControlMgrIPC.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __ImagerControlMgrIPC_h__
#define __ImagerControlMgrIPC_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <Ice/ExceptionHelpers.h>
#include "StageRunMgrIPC.h"
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 8
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace BGI
{


namespace RPC
{

class ImagerControlMgrIPC;
class ImagerControlMgrIPCPrx;
class ImagerControlMgrIPCCallback;
class ImagerControlMgrIPCCallbackPrx;

}

}

namespace BGI
{

namespace RPC
{

enum class BasecallConnectState : unsigned char
{
    bcsConnect,
    bcsDisconnect
};

enum class ImagerServerState : unsigned char
{
    disIdle,
    disReady,
    disImagerRun,
    disScanRunning,
    disSetupRun,
    disWriteFq,
    disRunTask
};

enum class ImagerState : unsigned char
{
    imsDisconnect,
    imsIdle,
    imsReset,
    imsGoHome,
    imsGoLoadingPos,
    imsGoWashPos,
    imsSwitchVacuum,
    imsPreInjectSRE,
    imsPreProcessing,
    imsSlideLeavedImager,
    imsStartRun,
    imsReady,
    imsScanning,
    imsSelfCheck
};

struct ImagerRunInfo
{
    ::std::string SlideID;
    int CurrentRow;
    int CurrentCol;
    int CurrentCycle;
    int CurrentLane;
    int StartRow;
    int EndRow;
    int StartCol;
    int EndCol;
    int TotalLane;
    int ScanDirect;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&> ice_tuple() const
    {
        return std::tie(SlideID, CurrentRow, CurrentCol, CurrentCycle, CurrentLane, StartRow, EndRow, StartCol, EndCol, TotalLane, ScanDirect);
    }
};

enum class ImagerSlideLeavedReason : unsigned char
{
    LeavedReasonNormal,
    LeavedReasonVacuumFailed,
    LeavedReasonOthers
};

enum class ImagerErrorEnum
{
    None = 0,
    BasecallConnect = 2000,
    BasecallDisconnect = 2001,
    ReimagingError = 2003,
    BasecallBusy = 2004,
    BasecallLostFovList = 2010,
    BasecallNotSetupRun = 2011,
    BasecallReadyToAcqTimeout = 2012,
    BasecallIceEXCEP = 2013,
    ServerStdEXCEP = 2014,
    ServerFatalEXCEP = 2015,
    ServerStatusEXCEP = 2016,
    ServerSequenceEXCEP = 2017,
    StageLibEXCEP = 2018,
    StageNotReady = 2050,
    CameraNotReady = 2051,
    ParamsError = 2100,
    DllError = 2101,
    Findlocation = 2201,
    ThetaCorrection = 2202,
    DetectBubbles = 2203,
    StageError = 2204,
    CameraError = 2205,
    LaserError = 2206,
    IOError = 2207,
    XLP6KPumpError = 2208,
    BasecallingError = 2209,
    ImagerStop = 2210,
    SeqDataValid = 2211,
    ConfigDataError = 2212,
    ScriptError = 2213,
    ChipPositionError = 2214,
    ScanRowColError = 2215,
    VacuumError = 2216,
    PrePrimeError = 2220,
    AutoFocusError = 2221,
    MemoryAllocationError = 2222,
    MemoryAllocationInvalid = 2223,
    StageParamError = 2224,
    HardWareSoloistError = 2225,
    HardWareAcsError = 2226,
    HardLiquidPumpError = 2227,
    SoftWareCamAppError = 2228,
    SquirtError = 2303,
    SpreadError = 2304,
    CameraErrorEXCEP = 3000,
    InsuffDiskSpaceEXCEP = 3001,
    InsuffMemSpaceEXCEP = 3002,
    RepeatedRunIdEXCEP = 3003,
    RunInfoErrorEXCEP = 3004,
    VariableErrorEXCEP = 3005,
    CycleErrorEXCEP = 3006,
    InvalidChipTypeEXCEP = 3007,
    GPUErrorEXCEP = 3100,
    SimuAcquireErrorEXCEP = 3101,
    StateErrorEXCEP = 3102,
    UnknownError = 9999,
    ControllerOffLineError = 25000,
    CamOffLineError = 25010,
    ImagerStateError = 25020,
    OpticEngineParamError = 26000,
    SeverParamError = 26100,
    StartRunVaccumError = 21610,
    ScanRowsVaccumError = 22110,
    SreFloodingSoloistError = 21010,
    SreFloodingACSError = 21020,
    SreFloodingLiquidPumpError = 21030,
    SreSpreadingSoloistError = 21110,
    SreSpreadingACSError = 21120,
    LafOnSoloistError = 21210,
    RegistrationSoloistError = 21310,
    RegistrationACSError = 21320,
    RegistrationThetaError = 21302,
    RegistrationImgCalError = 21303,
    RegistrationImgTimeoutError = 21352,
    RegistrationSlidePosError = 21304,
    StartCycleACSError = 21420,
    EndprocessCycleSoloistError = 21510,
    EndprocessCycleACSError = 21520,
    ReadyScanVaccumError = 21640,
    ScanRowSoloistError = 22010,
    ScanRowSoloistDestroyError = 22011,
    ScanRowACSError = 22020,
    ScaningVaccumError = 22140,
    GoHomeSoloistError = 23010,
    GoHomeASCError = 23020,
    GotoLoadSoloistError = 23110,
    GotoLoadASCError = 23120,
    GotoLoadLogicError = 23154,
    VaccumOnOFFError = 23540,
    WaterPipeCleanSoloistError = 23210,
    WaterPipeCleanACSError = 23220,
    WaterPipeCleanLiquidPumpError = 23230,
    CleanObjectiveLensSoloistError = 23310,
    CleanObjectiveLensACSError = 23320,
    CleanObjectiveLensLiquidPumpError = 23330,
    SREPipeCleanSoloistError = 23710,
    SREPipeCleanACSError = 23720,
    SREPipeCleanLiquidPumpError = 23730,
    PreHeatingSoloistError = 23410,
    PreHeatingACSError = 23420,
    PreHeatingLogicError = 23404,
    WasteLiquidError = 23660
};

enum class ImagerDataEnum : unsigned char
{
    Vacuum,
    FlowcellInHolderTimeout
};

enum class EndCycleProcessModeEnum : unsigned char
{
    R1R2None = 0,
    R1Only = 1,
    R2Only = 2,
    R1R2Both = 3
};

enum class SequencingTypeEnum : unsigned char
{
    PE100 = 0,
    PE150 = 1,
    stLFR = 2,
    SE100 = 3,
    SE150 = 4,
    UMIDBarcode = 5,
    QuarterBarcode1 = 6,
    PreProcessing = 8,
    iDropATAC = 9,
    iDropRNA = 10,
    iDropRNANew = 11,
    Custom = 99
};

enum class PreProcessingEnum : unsigned char
{
    WasteLiquidExtract = 1,
    WaterPipeClean = 2,
    PreHeating = 3,
    ObjectiveLensClean = 4,
    PreSpreadingSRE = 5,
    SelfChecking = 6
};

using ExposureTimeArray = ::std::vector<double>;

using ExposureFactorArray = ::std::vector<double>;

struct ImagerConfigData
{
    int Lane;
    ::std::string Reference;
    int BasecallMode;
    bool IsSaveRawImage;
    bool IsImageSimulated;
    int SettingTime;
    int CheckThetaMode;
    int Direction;
    int StartRow;
    int EndRow;
    int StartCol;
    int EndCol;
    bool IsExposureFileClean;
    ::BGI::RPC::ExposureTimeArray ExposureTime;
    ::BGI::RPC::ExposureFactorArray ExposureFactors;
    ::std::string SaveFovString;
    ::BGI::RPC::EndCycleProcessModeEnum EndCycleProcessMode;
    double VacuumSupplyThreshold;
    ::std::string ExtraSettings;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const int&, const ::std::string&, const int&, const bool&, const bool&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const bool&, const ::BGI::RPC::ExposureTimeArray&, const ::BGI::RPC::ExposureFactorArray&, const ::std::string&, const ::BGI::RPC::EndCycleProcessModeEnum&, const double&, const ::std::string&> ice_tuple() const
    {
        return std::tie(Lane, Reference, BasecallMode, IsSaveRawImage, IsImageSimulated, SettingTime, CheckThetaMode, Direction, StartRow, EndRow, StartCol, EndCol, IsExposureFileClean, ExposureTime, ExposureFactors, SaveFovString, EndCycleProcessMode, VacuumSupplyThreshold, ExtraSettings);
    }
};

using SpeciesBarcodesDatas = ::std::map<::std::string, ::std::string>;

struct ImagerSetupInfo
{
    ::std::string SlideID;
    ::std::string ScriptName;
    ::std::string ExperimentName;
    ::std::string UserName;
    int ImagerID;
    int ZAFOffset;
    bool IsCalAFOffset;
    int Read1Len;
    int Read2Len;
    int Barcode1Len;
    int Barcode2Len;
    ::std::string Reference;
    ::BGI::RPC::SpeciesBarcodesDatas BioBarcode;
    int TotalCycle;
    int BiochemCycle;
    int ImagerCycle;
    int TolerancePattern;
    ::std::string sequencingType;
    int FqBarcode1Length;
    int FqBarcode1StartPos;
    int FqSpeciesMismatch;
    int FqBarcode2Length;
    int FqBarcode2StartPos;
    int FqSpeciesMismatch2;
    int FilterMode;
    int WriteFastqMode;
    int BarcodeReverse;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const int&, const int&, const bool&, const int&, const int&, const int&, const int&, const ::std::string&, const ::BGI::RPC::SpeciesBarcodesDatas&, const int&, const int&, const int&, const int&, const ::std::string&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&> ice_tuple() const
    {
        return std::tie(SlideID, ScriptName, ExperimentName, UserName, ImagerID, ZAFOffset, IsCalAFOffset, Read1Len, Read2Len, Barcode1Len, Barcode2Len, Reference, BioBarcode, TotalCycle, BiochemCycle, ImagerCycle, TolerancePattern, sequencingType, FqBarcode1Length, FqBarcode1StartPos, FqSpeciesMismatch, FqBarcode2Length, FqBarcode2StartPos, FqSpeciesMismatch2, FilterMode, WriteFastqMode, BarcodeReverse);
    }
};

enum class BasecallStatusEnum : unsigned char
{
    INACTIVE = 0,
    ACTIVE = 1,
    ACQUIREWAIT = 2,
    ACQUIRING = 3,
    ACQUIRECOMPLETE = 4,
    PROCESSINGCOMPLETE = 5,
    DEAD = 6
};

struct RunInformation
{
    ::BGI::RPC::BasecallStatusEnum Status;
    bool Reseq;
    ::std::string SlideID;
    int CurrentCycle;
    int Lane;
    int StarRow;
    int EndRow;
    int StartCol;
    int EndCol;
    int TotalCycle;
    int StartCycle;
    int Read1Length;
    int Read2Length;
    int BarcodeLength;
    int FovNumMaxPerScan;
    int BarcodePos;

    /**
     * Obtains a tuple containing all of the struct's data members.
     * @return The data members in a tuple.
     */
    std::tuple<const ::BGI::RPC::BasecallStatusEnum&, const bool&, const ::std::string&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&, const int&> ice_tuple() const
    {
        return std::tie(Status, Reseq, SlideID, CurrentCycle, Lane, StarRow, EndRow, StartCol, EndCol, TotalCycle, StartCycle, Read1Length, Read2Length, BarcodeLength, FovNumMaxPerScan, BarcodePos);
    }
};

using RunInformationArray = ::std::vector<RunInformation>;

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

using Ice::operator<;
using Ice::operator<=;
using Ice::operator>;
using Ice::operator>=;
using Ice::operator==;
using Ice::operator!=;

}

namespace BGI
{

namespace RPC
{

class ImagerControlMgrIPC : public virtual StageRunMgrIPC
{
public:

    using ProxyType = ImagerControlMgrIPCPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool ImagerSetup(ImagerSetupInfo info, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ImagerSetup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool Reset(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_Reset(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool SetupRun(ImagerSetupInfo info, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetupRun(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool ReleaseRun(ImagerSetupInfo info, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ReleaseRun(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GoHome(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GoHome(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GoLoadingPos(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GoLoadingPos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GoWashPos(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GoWashPos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool IsAtLoadPosition(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_IsAtLoadPosition(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool SwitchVacuum(bool valveStatus, bool pumpStatus, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SwitchVacuum(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetVacuumStatus(double thresholdValueMin, double thresholdValueMax, int timeoutSec, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetVacuumStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool PreInjectSRE(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PreInjectSRE(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool PreProcessing(PreProcessingEnum type, int timeoutSec, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_PreProcessing(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool ImagerConfigSet(ImagerConfigData config, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ImagerConfigSet(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ImagerConfigData ImagerConfigGet(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_ImagerConfigGet(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SlideLeavedImager(ImagerSlideLeavedReason reason, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SlideLeavedImager(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual RunInformationArray GetAllRunInformations(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetAllRunInformations(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetRunInformation(::std::string slideID, ImagerSetupInfo& runInfo, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetRunInformation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetBasecallInformation(::std::string slideID, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetBasecallInformation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool EndCycle(bool reSeq, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_EndCycle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool StartRunScript(::std::string scriptName, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_StartRunScript(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetBasecallFlowcellConsumptionDiskSpace.
     */
    struct GetBasecallFlowcellConsumptionDiskSpaceResult
    {
        bool returnValue;
        double value;
    };

    virtual bool GetBasecallFlowcellConsumptionDiskSpace(double& value, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetBasecallFlowcellConsumptionDiskSpace(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetBasecallRemoteDiskSpace.
     */
    struct GetBasecallRemoteDiskSpaceResult
    {
        bool returnValue;
        double value;
    };

    virtual bool GetBasecallRemoteDiskSpace(double& value, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetBasecallRemoteDiskSpace(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetBasecallLocalDiskSpace.
     */
    struct GetBasecallLocalDiskSpaceResult
    {
        bool returnValue;
        double value;
    };

    virtual bool GetBasecallLocalDiskSpace(double& value, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetBasecallLocalDiskSpace(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetParam.
     */
    struct GetParamResult
    {
        bool returnValue;
        ::std::string value;
    };

    virtual bool GetParam(::std::string name, ::std::string& value, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetParam(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool SetParam(::std::string name, ::std::string value, bool saveToDisk, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SetParam(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to GetVersions.
     */
    struct GetVersionsResult
    {
        ::std::string bcsVer;
        ::std::string sbcVer;
        ::std::string imagerVer;
    };

    virtual void GetVersions(::std::string& bcsVer, ::std::string& sbcVer, ::std::string& imagerVer, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_GetVersions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

class ImagerControlMgrIPCCallback : public virtual StageRunMgrIPCCallback
{
public:

    using ProxyType = ImagerControlMgrIPCCallbackPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void SendImagerError(ImagerErrorEnum error, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendImagerError(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendImagerRunInfo(ImagerRunInfo info, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendImagerRunInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendImagerTaskEnd(ImagerSetupInfo info, ImagerErrorEnum error, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendImagerTaskEnd(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendData(::std::string key, ::std::string value, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual int SendHeartbeat(int count, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendHeartbeat(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendStatus(BasecallConnectState StateBasecall, ImagerServerState StateServer, ImagerState StateImager, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_SendStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

}

namespace BGI
{

namespace RPC
{

class ImagerControlMgrIPCPrx : public virtual ::Ice::Proxy<ImagerControlMgrIPCPrx, StageRunMgrIPCPrx>
{
public:

    bool ImagerSetup(const ImagerSetupInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_ImagerSetup, info, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ImagerSetupAsync(const ImagerSetupInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_ImagerSetup, info, context);
    }

    ::std::function<void()>
    ImagerSetupAsync(const ImagerSetupInfo& info,
                     ::std::function<void(bool)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_ImagerSetup, info, context);
    }

    /// \cond INTERNAL
    void _iceI_ImagerSetup(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ImagerSetupInfo&, const ::Ice::Context&);
    /// \endcond

    bool Reset(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_Reset, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ResetAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_Reset, context);
    }

    ::std::function<void()>
    ResetAsync(::std::function<void(bool)> response,
               ::std::function<void(::std::exception_ptr)> ex = nullptr,
               ::std::function<void(bool)> sent = nullptr,
               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_Reset, context);
    }

    /// \cond INTERNAL
    void _iceI_Reset(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool SetupRun(const ImagerSetupInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_SetupRun, info, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetupRunAsync(const ImagerSetupInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_SetupRun, info, context);
    }

    ::std::function<void()>
    SetupRunAsync(const ImagerSetupInfo& info,
                  ::std::function<void(bool)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_SetupRun, info, context);
    }

    /// \cond INTERNAL
    void _iceI_SetupRun(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ImagerSetupInfo&, const ::Ice::Context&);
    /// \endcond

    bool ReleaseRun(const ImagerSetupInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_ReleaseRun, info, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ReleaseRunAsync(const ImagerSetupInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_ReleaseRun, info, context);
    }

    ::std::function<void()>
    ReleaseRunAsync(const ImagerSetupInfo& info,
                    ::std::function<void(bool)> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_ReleaseRun, info, context);
    }

    /// \cond INTERNAL
    void _iceI_ReleaseRun(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ImagerSetupInfo&, const ::Ice::Context&);
    /// \endcond

    bool GoHome(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_GoHome, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GoHomeAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_GoHome, context);
    }

    ::std::function<void()>
    GoHomeAsync(::std::function<void(bool)> response,
                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                ::std::function<void(bool)> sent = nullptr,
                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GoHome, context);
    }

    /// \cond INTERNAL
    void _iceI_GoHome(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool GoLoadingPos(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_GoLoadingPos, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GoLoadingPosAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_GoLoadingPos, context);
    }

    ::std::function<void()>
    GoLoadingPosAsync(::std::function<void(bool)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GoLoadingPos, context);
    }

    /// \cond INTERNAL
    void _iceI_GoLoadingPos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool GoWashPos(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_GoWashPos, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GoWashPosAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_GoWashPos, context);
    }

    ::std::function<void()>
    GoWashPosAsync(::std::function<void(bool)> response,
                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                   ::std::function<void(bool)> sent = nullptr,
                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GoWashPos, context);
    }

    /// \cond INTERNAL
    void _iceI_GoWashPos(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool IsAtLoadPosition(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_IsAtLoadPosition, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto IsAtLoadPositionAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_IsAtLoadPosition, context);
    }

    ::std::function<void()>
    IsAtLoadPositionAsync(::std::function<void(bool)> response,
                          ::std::function<void(::std::exception_ptr)> ex = nullptr,
                          ::std::function<void(bool)> sent = nullptr,
                          const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_IsAtLoadPosition, context);
    }

    /// \cond INTERNAL
    void _iceI_IsAtLoadPosition(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool SwitchVacuum(bool valveStatus, bool pumpStatus, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_SwitchVacuum, valveStatus, pumpStatus, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SwitchVacuumAsync(bool valveStatus, bool pumpStatus, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_SwitchVacuum, valveStatus, pumpStatus, context);
    }

    ::std::function<void()>
    SwitchVacuumAsync(bool valveStatus, bool pumpStatus,
                      ::std::function<void(bool)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_SwitchVacuum, valveStatus, pumpStatus, context);
    }

    /// \cond INTERNAL
    void _iceI_SwitchVacuum(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, bool, bool, const ::Ice::Context&);
    /// \endcond

    bool GetVacuumStatus(double thresholdValueMin, double thresholdValueMax, int timeoutSec, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_GetVacuumStatus, thresholdValueMin, thresholdValueMax, timeoutSec, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetVacuumStatusAsync(double thresholdValueMin, double thresholdValueMax, int timeoutSec, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_GetVacuumStatus, thresholdValueMin, thresholdValueMax, timeoutSec, context);
    }

    ::std::function<void()>
    GetVacuumStatusAsync(double thresholdValueMin, double thresholdValueMax, int timeoutSec,
                         ::std::function<void(bool)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetVacuumStatus, thresholdValueMin, thresholdValueMax, timeoutSec, context);
    }

    /// \cond INTERNAL
    void _iceI_GetVacuumStatus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, double, double, int, const ::Ice::Context&);
    /// \endcond

    bool PreInjectSRE(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_PreInjectSRE, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PreInjectSREAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_PreInjectSRE, context);
    }

    ::std::function<void()>
    PreInjectSREAsync(::std::function<void(bool)> response,
                      ::std::function<void(::std::exception_ptr)> ex = nullptr,
                      ::std::function<void(bool)> sent = nullptr,
                      const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_PreInjectSRE, context);
    }

    /// \cond INTERNAL
    void _iceI_PreInjectSRE(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    bool PreProcessing(PreProcessingEnum type, int timeoutSec, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_PreProcessing, type, timeoutSec, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PreProcessingAsync(PreProcessingEnum type, int timeoutSec, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_PreProcessing, type, timeoutSec, context);
    }

    ::std::function<void()>
    PreProcessingAsync(PreProcessingEnum type, int timeoutSec,
                       ::std::function<void(bool)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_PreProcessing, type, timeoutSec, context);
    }

    /// \cond INTERNAL
    void _iceI_PreProcessing(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, PreProcessingEnum, int, const ::Ice::Context&);
    /// \endcond

    bool ImagerConfigSet(const ImagerConfigData& config, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_ImagerConfigSet, config, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ImagerConfigSetAsync(const ImagerConfigData& config, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_ImagerConfigSet, config, context);
    }

    ::std::function<void()>
    ImagerConfigSetAsync(const ImagerConfigData& config,
                         ::std::function<void(bool)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_ImagerConfigSet, config, context);
    }

    /// \cond INTERNAL
    void _iceI_ImagerConfigSet(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ImagerConfigData&, const ::Ice::Context&);
    /// \endcond

    ImagerConfigData ImagerConfigGet(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::BGI::RPC::ImagerConfigData>(true, this, &ImagerControlMgrIPCPrx::_iceI_ImagerConfigGet, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ImagerConfigGetAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::BGI::RPC::ImagerConfigData>>().get_future())
    {
        return _makePromiseOutgoing<::BGI::RPC::ImagerConfigData, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_ImagerConfigGet, context);
    }

    ::std::function<void()>
    ImagerConfigGetAsync(::std::function<void(::BGI::RPC::ImagerConfigData)> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::BGI::RPC::ImagerConfigData>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_ImagerConfigGet, context);
    }

    /// \cond INTERNAL
    void _iceI_ImagerConfigGet(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::ImagerConfigData>>&, const ::Ice::Context&);
    /// \endcond

    void SlideLeavedImager(ImagerSlideLeavedReason reason, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ImagerControlMgrIPCPrx::_iceI_SlideLeavedImager, reason, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SlideLeavedImagerAsync(ImagerSlideLeavedReason reason, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_SlideLeavedImager, reason, context);
    }

    ::std::function<void()>
    SlideLeavedImagerAsync(ImagerSlideLeavedReason reason,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_SlideLeavedImager, reason, context);
    }

    /// \cond INTERNAL
    void _iceI_SlideLeavedImager(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ImagerSlideLeavedReason, const ::Ice::Context&);
    /// \endcond

    RunInformationArray GetAllRunInformations(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<::BGI::RPC::RunInformationArray>(true, this, &ImagerControlMgrIPCPrx::_iceI_GetAllRunInformations, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetAllRunInformationsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::BGI::RPC::RunInformationArray>>().get_future())
    {
        return _makePromiseOutgoing<::BGI::RPC::RunInformationArray, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_GetAllRunInformations, context);
    }

    ::std::function<void()>
    GetAllRunInformationsAsync(::std::function<void(::BGI::RPC::RunInformationArray)> response,
                               ::std::function<void(::std::exception_ptr)> ex = nullptr,
                               ::std::function<void(bool)> sent = nullptr,
                               const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::BGI::RPC::RunInformationArray>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetAllRunInformations, context);
    }

    /// \cond INTERNAL
    void _iceI_GetAllRunInformations(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::RunInformationArray>>&, const ::Ice::Context&);
    /// \endcond

    void GetRunInformation(const ::std::string& slideID, ImagerSetupInfo& runInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        runInfo = _makePromiseOutgoing<::BGI::RPC::ImagerSetupInfo>(true, this, &ImagerControlMgrIPCPrx::_iceI_GetRunInformation, slideID, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetRunInformationAsync(const ::std::string& slideID, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<::BGI::RPC::ImagerSetupInfo>>().get_future())
    {
        return _makePromiseOutgoing<::BGI::RPC::ImagerSetupInfo, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_GetRunInformation, slideID, context);
    }

    ::std::function<void()>
    GetRunInformationAsync(const ::std::string& slideID,
                           ::std::function<void(::BGI::RPC::ImagerSetupInfo)> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<::BGI::RPC::ImagerSetupInfo>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetRunInformation, slideID, context);
    }

    /// \cond INTERNAL
    void _iceI_GetRunInformation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<::BGI::RPC::ImagerSetupInfo>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool GetBasecallInformation(const ::std::string& slideID, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_GetBasecallInformation, slideID, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto GetBasecallInformationAsync(const ::std::string& slideID, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_GetBasecallInformation, slideID, context);
    }

    ::std::function<void()>
    GetBasecallInformationAsync(const ::std::string& slideID,
                                ::std::function<void(bool)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetBasecallInformation, slideID, context);
    }

    /// \cond INTERNAL
    void _iceI_GetBasecallInformation(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool EndCycle(bool reSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_EndCycle, reSeq, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto EndCycleAsync(bool reSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_EndCycle, reSeq, context);
    }

    ::std::function<void()>
    EndCycleAsync(bool reSeq,
                  ::std::function<void(bool)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_EndCycle, reSeq, context);
    }

    /// \cond INTERNAL
    void _iceI_EndCycle(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, bool, const ::Ice::Context&);
    /// \endcond

    bool StartRunScript(const ::std::string& scriptName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_StartRunScript, scriptName, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto StartRunScriptAsync(const ::std::string& scriptName, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_StartRunScript, scriptName, context);
    }

    ::std::function<void()>
    StartRunScriptAsync(const ::std::string& scriptName,
                        ::std::function<void(bool)> response,
                        ::std::function<void(::std::exception_ptr)> ex = nullptr,
                        ::std::function<void(bool)> sent = nullptr,
                        const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_StartRunScript, scriptName, context);
    }

    /// \cond INTERNAL
    void _iceI_StartRunScript(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool GetBasecallFlowcellConsumptionDiskSpace(double& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ImagerControlMgrIPC::GetBasecallFlowcellConsumptionDiskSpaceResult>(true, this, &ImagerControlMgrIPCPrx::_iceI_GetBasecallFlowcellConsumptionDiskSpace, context).get();
        value = _result.value;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetBasecallFlowcellConsumptionDiskSpaceAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ImagerControlMgrIPC::GetBasecallFlowcellConsumptionDiskSpaceResult>>().get_future())
    {
        return _makePromiseOutgoing<ImagerControlMgrIPC::GetBasecallFlowcellConsumptionDiskSpaceResult, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_GetBasecallFlowcellConsumptionDiskSpace, context);
    }

    ::std::function<void()>
    GetBasecallFlowcellConsumptionDiskSpaceAsync(::std::function<void(bool, double)> response,
                                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                                 ::std::function<void(bool)> sent = nullptr,
                                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ImagerControlMgrIPC::GetBasecallFlowcellConsumptionDiskSpaceResult&& _result)
        {
            response(_result.returnValue, _result.value);
        };
        return _makeLamdaOutgoing<ImagerControlMgrIPC::GetBasecallFlowcellConsumptionDiskSpaceResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetBasecallFlowcellConsumptionDiskSpace, context);
    }

    /// \cond INTERNAL
    void _iceI_GetBasecallFlowcellConsumptionDiskSpace(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ImagerControlMgrIPC::GetBasecallFlowcellConsumptionDiskSpaceResult>>&, const ::Ice::Context&);
    /// \endcond

    bool GetBasecallRemoteDiskSpace(double& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ImagerControlMgrIPC::GetBasecallRemoteDiskSpaceResult>(true, this, &ImagerControlMgrIPCPrx::_iceI_GetBasecallRemoteDiskSpace, context).get();
        value = _result.value;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetBasecallRemoteDiskSpaceAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ImagerControlMgrIPC::GetBasecallRemoteDiskSpaceResult>>().get_future())
    {
        return _makePromiseOutgoing<ImagerControlMgrIPC::GetBasecallRemoteDiskSpaceResult, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_GetBasecallRemoteDiskSpace, context);
    }

    ::std::function<void()>
    GetBasecallRemoteDiskSpaceAsync(::std::function<void(bool, double)> response,
                                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                    ::std::function<void(bool)> sent = nullptr,
                                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ImagerControlMgrIPC::GetBasecallRemoteDiskSpaceResult&& _result)
        {
            response(_result.returnValue, _result.value);
        };
        return _makeLamdaOutgoing<ImagerControlMgrIPC::GetBasecallRemoteDiskSpaceResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetBasecallRemoteDiskSpace, context);
    }

    /// \cond INTERNAL
    void _iceI_GetBasecallRemoteDiskSpace(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ImagerControlMgrIPC::GetBasecallRemoteDiskSpaceResult>>&, const ::Ice::Context&);
    /// \endcond

    bool GetBasecallLocalDiskSpace(double& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ImagerControlMgrIPC::GetBasecallLocalDiskSpaceResult>(true, this, &ImagerControlMgrIPCPrx::_iceI_GetBasecallLocalDiskSpace, context).get();
        value = _result.value;
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetBasecallLocalDiskSpaceAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ImagerControlMgrIPC::GetBasecallLocalDiskSpaceResult>>().get_future())
    {
        return _makePromiseOutgoing<ImagerControlMgrIPC::GetBasecallLocalDiskSpaceResult, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_GetBasecallLocalDiskSpace, context);
    }

    ::std::function<void()>
    GetBasecallLocalDiskSpaceAsync(::std::function<void(bool, double)> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ImagerControlMgrIPC::GetBasecallLocalDiskSpaceResult&& _result)
        {
            response(_result.returnValue, _result.value);
        };
        return _makeLamdaOutgoing<ImagerControlMgrIPC::GetBasecallLocalDiskSpaceResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetBasecallLocalDiskSpace, context);
    }

    /// \cond INTERNAL
    void _iceI_GetBasecallLocalDiskSpace(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ImagerControlMgrIPC::GetBasecallLocalDiskSpaceResult>>&, const ::Ice::Context&);
    /// \endcond

    bool GetParam(const ::std::string& name, ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ImagerControlMgrIPC::GetParamResult>(true, this, &ImagerControlMgrIPCPrx::_iceI_GetParam, name, context).get();
        value = ::std::move(_result.value);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto GetParamAsync(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ImagerControlMgrIPC::GetParamResult>>().get_future())
    {
        return _makePromiseOutgoing<ImagerControlMgrIPC::GetParamResult, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_GetParam, name, context);
    }

    ::std::function<void()>
    GetParamAsync(const ::std::string& name,
                  ::std::function<void(bool, ::std::string)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ImagerControlMgrIPC::GetParamResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.value));
        };
        return _makeLamdaOutgoing<ImagerControlMgrIPC::GetParamResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetParam, name, context);
    }

    /// \cond INTERNAL
    void _iceI_GetParam(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ImagerControlMgrIPC::GetParamResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool SetParam(const ::std::string& name, const ::std::string& value, bool saveToDisk, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ImagerControlMgrIPCPrx::_iceI_SetParam, name, value, saveToDisk, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SetParamAsync(const ::std::string& name, const ::std::string& value, bool saveToDisk, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_SetParam, name, value, saveToDisk, context);
    }

    ::std::function<void()>
    SetParamAsync(const ::std::string& name, const ::std::string& value, bool saveToDisk,
                  ::std::function<void(bool)> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_SetParam, name, value, saveToDisk, context);
    }

    /// \cond INTERNAL
    void _iceI_SetParam(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::std::string&, const ::std::string&, bool, const ::Ice::Context&);
    /// \endcond

    void GetVersions(::std::string& bcsVer, ::std::string& sbcVer, ::std::string& imagerVer, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ImagerControlMgrIPC::GetVersionsResult>(true, this, &ImagerControlMgrIPCPrx::_iceI_GetVersions, context).get();
        bcsVer = ::std::move(_result.bcsVer);
        sbcVer = ::std::move(_result.sbcVer);
        imagerVer = ::std::move(_result.imagerVer);
    }

    template<template<typename> class P = ::std::promise>
    auto GetVersionsAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ImagerControlMgrIPC::GetVersionsResult>>().get_future())
    {
        return _makePromiseOutgoing<ImagerControlMgrIPC::GetVersionsResult, P>(false, this, &ImagerControlMgrIPCPrx::_iceI_GetVersions, context);
    }

    ::std::function<void()>
    GetVersionsAsync(::std::function<void(::std::string, ::std::string, ::std::string)> response,
                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                     ::std::function<void(bool)> sent = nullptr,
                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ImagerControlMgrIPC::GetVersionsResult&& _result)
        {
            response(::std::move(_result.bcsVer), ::std::move(_result.sbcVer), ::std::move(_result.imagerVer));
        };
        return _makeLamdaOutgoing<ImagerControlMgrIPC::GetVersionsResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCPrx::_iceI_GetVersions, context);
    }

    /// \cond INTERNAL
    void _iceI_GetVersions(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ImagerControlMgrIPC::GetVersionsResult>>&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    ImagerControlMgrIPCPrx() = default;
    friend ::std::shared_ptr<ImagerControlMgrIPCPrx> IceInternal::createProxy<ImagerControlMgrIPCPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

class ImagerControlMgrIPCCallbackPrx : public virtual ::Ice::Proxy<ImagerControlMgrIPCCallbackPrx, StageRunMgrIPCCallbackPrx>
{
public:

    void SendImagerError(ImagerErrorEnum error, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ImagerControlMgrIPCCallbackPrx::_iceI_SendImagerError, error, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendImagerErrorAsync(ImagerErrorEnum error, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ImagerControlMgrIPCCallbackPrx::_iceI_SendImagerError, error, context);
    }

    ::std::function<void()>
    SendImagerErrorAsync(ImagerErrorEnum error,
                         ::std::function<void()> response,
                         ::std::function<void(::std::exception_ptr)> ex = nullptr,
                         ::std::function<void(bool)> sent = nullptr,
                         const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCCallbackPrx::_iceI_SendImagerError, error, context);
    }

    /// \cond INTERNAL
    void _iceI_SendImagerError(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, ImagerErrorEnum, const ::Ice::Context&);
    /// \endcond

    void SendImagerRunInfo(const ImagerRunInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ImagerControlMgrIPCCallbackPrx::_iceI_SendImagerRunInfo, info, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendImagerRunInfoAsync(const ImagerRunInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ImagerControlMgrIPCCallbackPrx::_iceI_SendImagerRunInfo, info, context);
    }

    ::std::function<void()>
    SendImagerRunInfoAsync(const ImagerRunInfo& info,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCCallbackPrx::_iceI_SendImagerRunInfo, info, context);
    }

    /// \cond INTERNAL
    void _iceI_SendImagerRunInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ImagerRunInfo&, const ::Ice::Context&);
    /// \endcond

    void SendImagerTaskEnd(const ImagerSetupInfo& info, ImagerErrorEnum error, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ImagerControlMgrIPCCallbackPrx::_iceI_SendImagerTaskEnd, info, error, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendImagerTaskEndAsync(const ImagerSetupInfo& info, ImagerErrorEnum error, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ImagerControlMgrIPCCallbackPrx::_iceI_SendImagerTaskEnd, info, error, context);
    }

    ::std::function<void()>
    SendImagerTaskEndAsync(const ImagerSetupInfo& info, ImagerErrorEnum error,
                           ::std::function<void()> response,
                           ::std::function<void(::std::exception_ptr)> ex = nullptr,
                           ::std::function<void(bool)> sent = nullptr,
                           const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCCallbackPrx::_iceI_SendImagerTaskEnd, info, error, context);
    }

    /// \cond INTERNAL
    void _iceI_SendImagerTaskEnd(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ImagerSetupInfo&, ImagerErrorEnum, const ::Ice::Context&);
    /// \endcond

    void SendData(const ::std::string& key, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ImagerControlMgrIPCCallbackPrx::_iceI_SendData, key, value, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendDataAsync(const ::std::string& key, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ImagerControlMgrIPCCallbackPrx::_iceI_SendData, key, value, context);
    }

    ::std::function<void()>
    SendDataAsync(const ::std::string& key, const ::std::string& value,
                  ::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCCallbackPrx::_iceI_SendData, key, value, context);
    }

    /// \cond INTERNAL
    void _iceI_SendData(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    int SendHeartbeat(int count, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<int>(true, this, &ImagerControlMgrIPCCallbackPrx::_iceI_SendHeartbeat, count, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendHeartbeatAsync(int count, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<int>>().get_future())
    {
        return _makePromiseOutgoing<int, P>(false, this, &ImagerControlMgrIPCCallbackPrx::_iceI_SendHeartbeat, count, context);
    }

    ::std::function<void()>
    SendHeartbeatAsync(int count,
                       ::std::function<void(int)> response,
                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                       ::std::function<void(bool)> sent = nullptr,
                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<int>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCCallbackPrx::_iceI_SendHeartbeat, count, context);
    }

    /// \cond INTERNAL
    void _iceI_SendHeartbeat(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<int>>&, int, const ::Ice::Context&);
    /// \endcond

    void SendStatus(BasecallConnectState StateBasecall, ImagerServerState StateServer, ImagerState StateImager, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ImagerControlMgrIPCCallbackPrx::_iceI_SendStatus, StateBasecall, StateServer, StateImager, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto SendStatusAsync(BasecallConnectState StateBasecall, ImagerServerState StateServer, ImagerState StateImager, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ImagerControlMgrIPCCallbackPrx::_iceI_SendStatus, StateBasecall, StateServer, StateImager, context);
    }

    ::std::function<void()>
    SendStatusAsync(BasecallConnectState StateBasecall, ImagerServerState StateServer, ImagerState StateImager,
                    ::std::function<void()> response,
                    ::std::function<void(::std::exception_ptr)> ex = nullptr,
                    ::std::function<void(bool)> sent = nullptr,
                    const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &BGI::RPC::ImagerControlMgrIPCCallbackPrx::_iceI_SendStatus, StateBasecall, StateServer, StateImager, context);
    }

    /// \cond INTERNAL
    void _iceI_SendStatus(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, BasecallConnectState, ImagerServerState, ImagerState, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    ImagerControlMgrIPCCallbackPrx() = default;
    friend ::std::shared_ptr<ImagerControlMgrIPCCallbackPrx> IceInternal::createProxy<ImagerControlMgrIPCCallbackPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::BGI::RPC::BasecallConnectState>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 1;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::ImagerServerState>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::ImagerState>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 13;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::BGI::RPC::ImagerRunInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 41;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::BGI::RPC::ImagerRunInfo, S>
{
    static void read(S* istr, ::BGI::RPC::ImagerRunInfo& v)
    {
        istr->readAll(v.SlideID, v.CurrentRow, v.CurrentCol, v.CurrentCycle, v.CurrentLane, v.StartRow, v.EndRow, v.StartCol, v.EndCol, v.TotalLane, v.ScanDirect);
    }
};

template<>
struct StreamableTraits< ::BGI::RPC::ImagerSlideLeavedReason>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::ImagerErrorEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 26100;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::ImagerDataEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 1;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::EndCycleProcessModeEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::SequencingTypeEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 99;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::PreProcessingEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::BGI::RPC::ImagerConfigData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 53;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::BGI::RPC::ImagerConfigData, S>
{
    static void read(S* istr, ::BGI::RPC::ImagerConfigData& v)
    {
        istr->readAll(v.Lane, v.Reference, v.BasecallMode, v.IsSaveRawImage, v.IsImageSimulated, v.SettingTime, v.CheckThetaMode, v.Direction, v.StartRow, v.EndRow, v.StartCol, v.EndCol, v.IsExposureFileClean, v.ExposureTime, v.ExposureFactors, v.SaveFovString, v.EndCycleProcessMode, v.VacuumSupplyThreshold, v.ExtraSettings);
    }
};

template<>
struct StreamableTraits<::BGI::RPC::ImagerSetupInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 84;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::BGI::RPC::ImagerSetupInfo, S>
{
    static void read(S* istr, ::BGI::RPC::ImagerSetupInfo& v)
    {
        istr->readAll(v.SlideID, v.ScriptName, v.ExperimentName, v.UserName, v.ImagerID, v.ZAFOffset, v.IsCalAFOffset, v.Read1Len, v.Read2Len, v.Barcode1Len, v.Barcode2Len, v.Reference, v.BioBarcode, v.TotalCycle, v.BiochemCycle, v.ImagerCycle, v.TolerancePattern, v.sequencingType, v.FqBarcode1Length, v.FqBarcode1StartPos, v.FqSpeciesMismatch, v.FqBarcode2Length, v.FqBarcode2StartPos, v.FqSpeciesMismatch2, v.FilterMode, v.WriteFastqMode, v.BarcodeReverse);
    }
};

template<>
struct StreamableTraits< ::BGI::RPC::BasecallStatusEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits<::BGI::RPC::RunInformation>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 55;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamReader<::BGI::RPC::RunInformation, S>
{
    static void read(S* istr, ::BGI::RPC::RunInformation& v)
    {
        istr->readAll(v.Status, v.Reseq, v.SlideID, v.CurrentCycle, v.Lane, v.StarRow, v.EndRow, v.StartCol, v.EndCol, v.TotalCycle, v.StartCycle, v.Read1Length, v.Read2Length, v.BarcodeLength, v.FovNumMaxPerScan, v.BarcodePos);
    }
};

}
/// \endcond

/// \cond INTERNAL
namespace BGI
{

/// \cond INTERNAL
namespace RPC
{

using ImagerControlMgrIPCPtr = ::std::shared_ptr<ImagerControlMgrIPC>;
using ImagerControlMgrIPCPrxPtr = ::std::shared_ptr<ImagerControlMgrIPCPrx>;

using ImagerControlMgrIPCCallbackPtr = ::std::shared_ptr<ImagerControlMgrIPCCallback>;
using ImagerControlMgrIPCCallbackPrxPtr = ::std::shared_ptr<ImagerControlMgrIPCCallbackPrx>;

}
/// \endcond

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace BGI
{

namespace RPC
{

class ImagerControlMgrIPC;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ImagerControlMgrIPC>&);
::IceProxy::Ice::Object* upCast(ImagerControlMgrIPC*);
/// \endcond

class ImagerControlMgrIPCCallback;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ImagerControlMgrIPCCallback>&);
::IceProxy::Ice::Object* upCast(ImagerControlMgrIPCCallback*);
/// \endcond

}

}

}

namespace BGI
{

namespace RPC
{

class ImagerControlMgrIPC;
/// \cond INTERNAL
::Ice::Object* upCast(ImagerControlMgrIPC*);
/// \endcond
typedef ::IceInternal::Handle< ImagerControlMgrIPC> ImagerControlMgrIPCPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::BGI::RPC::ImagerControlMgrIPC> ImagerControlMgrIPCPrx;
typedef ImagerControlMgrIPCPrx ImagerControlMgrIPCPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ImagerControlMgrIPCPtr&, const ::Ice::ObjectPtr&);
/// \endcond

class ImagerControlMgrIPCCallback;
/// \cond INTERNAL
::Ice::Object* upCast(ImagerControlMgrIPCCallback*);
/// \endcond
typedef ::IceInternal::Handle< ImagerControlMgrIPCCallback> ImagerControlMgrIPCCallbackPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::BGI::RPC::ImagerControlMgrIPCCallback> ImagerControlMgrIPCCallbackPrx;
typedef ImagerControlMgrIPCCallbackPrx ImagerControlMgrIPCCallbackPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ImagerControlMgrIPCCallbackPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

}

namespace BGI
{

namespace RPC
{

enum BasecallConnectState
{
    bcsConnect,
    bcsDisconnect
};

enum ImagerServerState
{
    disIdle,
    disReady,
    disImagerRun,
    disScanRunning,
    disSetupRun,
    disWriteFq,
    disRunTask
};

enum ImagerState
{
    imsDisconnect,
    imsIdle,
    imsReset,
    imsGoHome,
    imsGoLoadingPos,
    imsGoWashPos,
    imsSwitchVacuum,
    imsPreInjectSRE,
    imsPreProcessing,
    imsSlideLeavedImager,
    imsStartRun,
    imsReady,
    imsScanning,
    imsSelfCheck
};

struct ImagerRunInfo
{
    ::std::string SlideID;
    ::Ice::Int CurrentRow;
    ::Ice::Int CurrentCol;
    ::Ice::Int CurrentCycle;
    ::Ice::Int CurrentLane;
    ::Ice::Int StartRow;
    ::Ice::Int EndRow;
    ::Ice::Int StartCol;
    ::Ice::Int EndCol;
    ::Ice::Int TotalLane;
    ::Ice::Int ScanDirect;

    bool operator==(const ImagerRunInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(SlideID != rhs_.SlideID)
        {
            return false;
        }
        if(CurrentRow != rhs_.CurrentRow)
        {
            return false;
        }
        if(CurrentCol != rhs_.CurrentCol)
        {
            return false;
        }
        if(CurrentCycle != rhs_.CurrentCycle)
        {
            return false;
        }
        if(CurrentLane != rhs_.CurrentLane)
        {
            return false;
        }
        if(StartRow != rhs_.StartRow)
        {
            return false;
        }
        if(EndRow != rhs_.EndRow)
        {
            return false;
        }
        if(StartCol != rhs_.StartCol)
        {
            return false;
        }
        if(EndCol != rhs_.EndCol)
        {
            return false;
        }
        if(TotalLane != rhs_.TotalLane)
        {
            return false;
        }
        if(ScanDirect != rhs_.ScanDirect)
        {
            return false;
        }
        return true;
    }

    bool operator<(const ImagerRunInfo& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(SlideID < rhs_.SlideID)
        {
            return true;
        }
        else if(rhs_.SlideID < SlideID)
        {
            return false;
        }
        if(CurrentRow < rhs_.CurrentRow)
        {
            return true;
        }
        else if(rhs_.CurrentRow < CurrentRow)
        {
            return false;
        }
        if(CurrentCol < rhs_.CurrentCol)
        {
            return true;
        }
        else if(rhs_.CurrentCol < CurrentCol)
        {
            return false;
        }
        if(CurrentCycle < rhs_.CurrentCycle)
        {
            return true;
        }
        else if(rhs_.CurrentCycle < CurrentCycle)
        {
            return false;
        }
        if(CurrentLane < rhs_.CurrentLane)
        {
            return true;
        }
        else if(rhs_.CurrentLane < CurrentLane)
        {
            return false;
        }
        if(StartRow < rhs_.StartRow)
        {
            return true;
        }
        else if(rhs_.StartRow < StartRow)
        {
            return false;
        }
        if(EndRow < rhs_.EndRow)
        {
            return true;
        }
        else if(rhs_.EndRow < EndRow)
        {
            return false;
        }
        if(StartCol < rhs_.StartCol)
        {
            return true;
        }
        else if(rhs_.StartCol < StartCol)
        {
            return false;
        }
        if(EndCol < rhs_.EndCol)
        {
            return true;
        }
        else if(rhs_.EndCol < EndCol)
        {
            return false;
        }
        if(TotalLane < rhs_.TotalLane)
        {
            return true;
        }
        else if(rhs_.TotalLane < TotalLane)
        {
            return false;
        }
        if(ScanDirect < rhs_.ScanDirect)
        {
            return true;
        }
        else if(rhs_.ScanDirect < ScanDirect)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const ImagerRunInfo& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const ImagerRunInfo& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const ImagerRunInfo& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const ImagerRunInfo& rhs_) const
    {
        return !operator<(rhs_);
    }
};

enum ImagerSlideLeavedReason
{
    LeavedReasonNormal,
    LeavedReasonVacuumFailed,
    LeavedReasonOthers
};

enum ImagerErrorEnum
{
    None = 0,
    BasecallConnect = 2000,
    BasecallDisconnect = 2001,
    ReimagingError = 2003,
    BasecallBusy = 2004,
    BasecallLostFovList = 2010,
    BasecallNotSetupRun = 2011,
    BasecallReadyToAcqTimeout = 2012,
    BasecallIceEXCEP = 2013,
    ServerStdEXCEP = 2014,
    ServerFatalEXCEP = 2015,
    ServerStatusEXCEP = 2016,
    ServerSequenceEXCEP = 2017,
    StageLibEXCEP = 2018,
    StageNotReady = 2050,
    CameraNotReady = 2051,
    ParamsError = 2100,
    DllError = 2101,
    Findlocation = 2201,
    ThetaCorrection = 2202,
    DetectBubbles = 2203,
    StageError = 2204,
    CameraError = 2205,
    LaserError = 2206,
    IOError = 2207,
    XLP6KPumpError = 2208,
    BasecallingError = 2209,
    ImagerStop = 2210,
    SeqDataValid = 2211,
    ConfigDataError = 2212,
    ScriptError = 2213,
    ChipPositionError = 2214,
    ScanRowColError = 2215,
    VacuumError = 2216,
    PrePrimeError = 2220,
    AutoFocusError = 2221,
    MemoryAllocationError = 2222,
    MemoryAllocationInvalid = 2223,
    StageParamError = 2224,
    HardWareSoloistError = 2225,
    HardWareAcsError = 2226,
    HardLiquidPumpError = 2227,
    SoftWareCamAppError = 2228,
    SquirtError = 2303,
    SpreadError = 2304,
    CameraErrorEXCEP = 3000,
    InsuffDiskSpaceEXCEP = 3001,
    InsuffMemSpaceEXCEP = 3002,
    RepeatedRunIdEXCEP = 3003,
    RunInfoErrorEXCEP = 3004,
    VariableErrorEXCEP = 3005,
    CycleErrorEXCEP = 3006,
    InvalidChipTypeEXCEP = 3007,
    GPUErrorEXCEP = 3100,
    SimuAcquireErrorEXCEP = 3101,
    StateErrorEXCEP = 3102,
    UnknownError = 9999,
    ControllerOffLineError = 25000,
    CamOffLineError = 25010,
    ImagerStateError = 25020,
    OpticEngineParamError = 26000,
    SeverParamError = 26100,
    StartRunVaccumError = 21610,
    ScanRowsVaccumError = 22110,
    SreFloodingSoloistError = 21010,
    SreFloodingACSError = 21020,
    SreFloodingLiquidPumpError = 21030,
    SreSpreadingSoloistError = 21110,
    SreSpreadingACSError = 21120,
    LafOnSoloistError = 21210,
    RegistrationSoloistError = 21310,
    RegistrationACSError = 21320,
    RegistrationThetaError = 21302,
    RegistrationImgCalError = 21303,
    RegistrationImgTimeoutError = 21352,
    RegistrationSlidePosError = 21304,
    StartCycleACSError = 21420,
    EndprocessCycleSoloistError = 21510,
    EndprocessCycleACSError = 21520,
    ReadyScanVaccumError = 21640,
    ScanRowSoloistError = 22010,
    ScanRowSoloistDestroyError = 22011,
    ScanRowACSError = 22020,
    ScaningVaccumError = 22140,
    GoHomeSoloistError = 23010,
    GoHomeASCError = 23020,
    GotoLoadSoloistError = 23110,
    GotoLoadASCError = 23120,
    GotoLoadLogicError = 23154,
    VaccumOnOFFError = 23540,
    WaterPipeCleanSoloistError = 23210,
    WaterPipeCleanACSError = 23220,
    WaterPipeCleanLiquidPumpError = 23230,
    CleanObjectiveLensSoloistError = 23310,
    CleanObjectiveLensACSError = 23320,
    CleanObjectiveLensLiquidPumpError = 23330,
    SREPipeCleanSoloistError = 23710,
    SREPipeCleanACSError = 23720,
    SREPipeCleanLiquidPumpError = 23730,
    PreHeatingSoloistError = 23410,
    PreHeatingACSError = 23420,
    PreHeatingLogicError = 23404,
    WasteLiquidError = 23660
};

enum ImagerDataEnum
{
    Vacuum,
    FlowcellInHolderTimeout
};

enum EndCycleProcessModeEnum
{
    R1R2None = 0,
    R1Only = 1,
    R2Only = 2,
    R1R2Both = 3
};

enum SequencingTypeEnum
{
    PE100 = 0,
    PE150 = 1,
    stLFR = 2,
    SE100 = 3,
    SE150 = 4,
    UMIDBarcode = 5,
    QuarterBarcode1 = 6,
    PreProcessing = 8,
    iDropATAC = 9,
    iDropRNA = 10,
    iDropRNANew = 11,
    Custom = 99
};

enum PreProcessingEnum
{
    WasteLiquidExtract = 1,
    WaterPipeClean = 2,
    PreHeating = 3,
    ObjectiveLensClean = 4,
    PreSpreadingSRE = 5,
    SelfChecking = 6
};

typedef ::std::vector< ::Ice::Double> ExposureTimeArray;

typedef ::std::vector< ::Ice::Double> ExposureFactorArray;

struct ImagerConfigData
{
    ::Ice::Int Lane;
    ::std::string Reference;
    ::Ice::Int BasecallMode;
    bool IsSaveRawImage;
    bool IsImageSimulated;
    ::Ice::Int SettingTime;
    ::Ice::Int CheckThetaMode;
    ::Ice::Int Direction;
    ::Ice::Int StartRow;
    ::Ice::Int EndRow;
    ::Ice::Int StartCol;
    ::Ice::Int EndCol;
    bool IsExposureFileClean;
    ::BGI::RPC::ExposureTimeArray ExposureTime;
    ::BGI::RPC::ExposureFactorArray ExposureFactors;
    ::std::string SaveFovString;
    ::BGI::RPC::EndCycleProcessModeEnum EndCycleProcessMode;
    ::Ice::Double VacuumSupplyThreshold;
    ::std::string ExtraSettings;
};

typedef ::std::map< ::std::string, ::std::string> SpeciesBarcodesDatas;

struct ImagerSetupInfo
{
    ::std::string SlideID;
    ::std::string ScriptName;
    ::std::string ExperimentName;
    ::std::string UserName;
    ::Ice::Int ImagerID;
    ::Ice::Int ZAFOffset;
    bool IsCalAFOffset;
    ::Ice::Int Read1Len;
    ::Ice::Int Read2Len;
    ::Ice::Int Barcode1Len;
    ::Ice::Int Barcode2Len;
    ::std::string Reference;
    ::BGI::RPC::SpeciesBarcodesDatas BioBarcode;
    ::Ice::Int TotalCycle;
    ::Ice::Int BiochemCycle;
    ::Ice::Int ImagerCycle;
    ::Ice::Int TolerancePattern;
    ::std::string sequencingType;
    ::Ice::Int FqBarcode1Length;
    ::Ice::Int FqBarcode1StartPos;
    ::Ice::Int FqSpeciesMismatch;
    ::Ice::Int FqBarcode2Length;
    ::Ice::Int FqBarcode2StartPos;
    ::Ice::Int FqSpeciesMismatch2;
    ::Ice::Int FilterMode;
    ::Ice::Int WriteFastqMode;
    ::Ice::Int BarcodeReverse;
};

enum BasecallStatusEnum
{
    INACTIVE = 0,
    ACTIVE = 1,
    ACQUIREWAIT = 2,
    ACQUIRING = 3,
    ACQUIRECOMPLETE = 4,
    PROCESSINGCOMPLETE = 5,
    DEAD = 6
};

struct RunInformation
{
    ::BGI::RPC::BasecallStatusEnum Status;
    bool Reseq;
    ::std::string SlideID;
    ::Ice::Int CurrentCycle;
    ::Ice::Int Lane;
    ::Ice::Int StarRow;
    ::Ice::Int EndRow;
    ::Ice::Int StartCol;
    ::Ice::Int EndCol;
    ::Ice::Int TotalCycle;
    ::Ice::Int StartCycle;
    ::Ice::Int Read1Length;
    ::Ice::Int Read2Length;
    ::Ice::Int BarcodeLength;
    ::Ice::Int FovNumMaxPerScan;
    ::Ice::Int BarcodePos;

    bool operator==(const RunInformation& rhs_) const
    {
        if(this == &rhs_)
        {
            return true;
        }
        if(Status != rhs_.Status)
        {
            return false;
        }
        if(Reseq != rhs_.Reseq)
        {
            return false;
        }
        if(SlideID != rhs_.SlideID)
        {
            return false;
        }
        if(CurrentCycle != rhs_.CurrentCycle)
        {
            return false;
        }
        if(Lane != rhs_.Lane)
        {
            return false;
        }
        if(StarRow != rhs_.StarRow)
        {
            return false;
        }
        if(EndRow != rhs_.EndRow)
        {
            return false;
        }
        if(StartCol != rhs_.StartCol)
        {
            return false;
        }
        if(EndCol != rhs_.EndCol)
        {
            return false;
        }
        if(TotalCycle != rhs_.TotalCycle)
        {
            return false;
        }
        if(StartCycle != rhs_.StartCycle)
        {
            return false;
        }
        if(Read1Length != rhs_.Read1Length)
        {
            return false;
        }
        if(Read2Length != rhs_.Read2Length)
        {
            return false;
        }
        if(BarcodeLength != rhs_.BarcodeLength)
        {
            return false;
        }
        if(FovNumMaxPerScan != rhs_.FovNumMaxPerScan)
        {
            return false;
        }
        if(BarcodePos != rhs_.BarcodePos)
        {
            return false;
        }
        return true;
    }

    bool operator<(const RunInformation& rhs_) const
    {
        if(this == &rhs_)
        {
            return false;
        }
        if(Status < rhs_.Status)
        {
            return true;
        }
        else if(rhs_.Status < Status)
        {
            return false;
        }
        if(Reseq < rhs_.Reseq)
        {
            return true;
        }
        else if(rhs_.Reseq < Reseq)
        {
            return false;
        }
        if(SlideID < rhs_.SlideID)
        {
            return true;
        }
        else if(rhs_.SlideID < SlideID)
        {
            return false;
        }
        if(CurrentCycle < rhs_.CurrentCycle)
        {
            return true;
        }
        else if(rhs_.CurrentCycle < CurrentCycle)
        {
            return false;
        }
        if(Lane < rhs_.Lane)
        {
            return true;
        }
        else if(rhs_.Lane < Lane)
        {
            return false;
        }
        if(StarRow < rhs_.StarRow)
        {
            return true;
        }
        else if(rhs_.StarRow < StarRow)
        {
            return false;
        }
        if(EndRow < rhs_.EndRow)
        {
            return true;
        }
        else if(rhs_.EndRow < EndRow)
        {
            return false;
        }
        if(StartCol < rhs_.StartCol)
        {
            return true;
        }
        else if(rhs_.StartCol < StartCol)
        {
            return false;
        }
        if(EndCol < rhs_.EndCol)
        {
            return true;
        }
        else if(rhs_.EndCol < EndCol)
        {
            return false;
        }
        if(TotalCycle < rhs_.TotalCycle)
        {
            return true;
        }
        else if(rhs_.TotalCycle < TotalCycle)
        {
            return false;
        }
        if(StartCycle < rhs_.StartCycle)
        {
            return true;
        }
        else if(rhs_.StartCycle < StartCycle)
        {
            return false;
        }
        if(Read1Length < rhs_.Read1Length)
        {
            return true;
        }
        else if(rhs_.Read1Length < Read1Length)
        {
            return false;
        }
        if(Read2Length < rhs_.Read2Length)
        {
            return true;
        }
        else if(rhs_.Read2Length < Read2Length)
        {
            return false;
        }
        if(BarcodeLength < rhs_.BarcodeLength)
        {
            return true;
        }
        else if(rhs_.BarcodeLength < BarcodeLength)
        {
            return false;
        }
        if(FovNumMaxPerScan < rhs_.FovNumMaxPerScan)
        {
            return true;
        }
        else if(rhs_.FovNumMaxPerScan < FovNumMaxPerScan)
        {
            return false;
        }
        if(BarcodePos < rhs_.BarcodePos)
        {
            return true;
        }
        else if(rhs_.BarcodePos < BarcodePos)
        {
            return false;
        }
        return false;
    }

    bool operator!=(const RunInformation& rhs_) const
    {
        return !operator==(rhs_);
    }
    bool operator<=(const RunInformation& rhs_) const
    {
        return operator<(rhs_) || operator==(rhs_);
    }
    bool operator>(const RunInformation& rhs_) const
    {
        return !operator<(rhs_) && !operator==(rhs_);
    }
    bool operator>=(const RunInformation& rhs_) const
    {
        return !operator<(rhs_);
    }
};

typedef ::std::vector<RunInformation> RunInformationArray;

}

}

namespace BGI
{

namespace RPC
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerSetup.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_ImagerSetup.
 */
class Callback_ImagerControlMgrIPC_ImagerSetup_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_ImagerSetup_Base> Callback_ImagerControlMgrIPC_ImagerSetupPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_Reset.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_Reset.
 */
class Callback_ImagerControlMgrIPC_Reset_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_Reset_Base> Callback_ImagerControlMgrIPC_ResetPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SetupRun.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_SetupRun.
 */
class Callback_ImagerControlMgrIPC_SetupRun_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_SetupRun_Base> Callback_ImagerControlMgrIPC_SetupRunPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ReleaseRun.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_ReleaseRun.
 */
class Callback_ImagerControlMgrIPC_ReleaseRun_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_ReleaseRun_Base> Callback_ImagerControlMgrIPC_ReleaseRunPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoHome.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GoHome.
 */
class Callback_ImagerControlMgrIPC_GoHome_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_GoHome_Base> Callback_ImagerControlMgrIPC_GoHomePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoLoadingPos.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GoLoadingPos.
 */
class Callback_ImagerControlMgrIPC_GoLoadingPos_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_GoLoadingPos_Base> Callback_ImagerControlMgrIPC_GoLoadingPosPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoWashPos.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GoWashPos.
 */
class Callback_ImagerControlMgrIPC_GoWashPos_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_GoWashPos_Base> Callback_ImagerControlMgrIPC_GoWashPosPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_IsAtLoadPosition.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_IsAtLoadPosition.
 */
class Callback_ImagerControlMgrIPC_IsAtLoadPosition_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_IsAtLoadPosition_Base> Callback_ImagerControlMgrIPC_IsAtLoadPositionPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SwitchVacuum.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_SwitchVacuum.
 */
class Callback_ImagerControlMgrIPC_SwitchVacuum_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_SwitchVacuum_Base> Callback_ImagerControlMgrIPC_SwitchVacuumPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetVacuumStatus.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetVacuumStatus.
 */
class Callback_ImagerControlMgrIPC_GetVacuumStatus_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_GetVacuumStatus_Base> Callback_ImagerControlMgrIPC_GetVacuumStatusPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_PreInjectSRE.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_PreInjectSRE.
 */
class Callback_ImagerControlMgrIPC_PreInjectSRE_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_PreInjectSRE_Base> Callback_ImagerControlMgrIPC_PreInjectSREPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_PreProcessing.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_PreProcessing.
 */
class Callback_ImagerControlMgrIPC_PreProcessing_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_PreProcessing_Base> Callback_ImagerControlMgrIPC_PreProcessingPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerConfigSet.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_ImagerConfigSet.
 */
class Callback_ImagerControlMgrIPC_ImagerConfigSet_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_ImagerConfigSet_Base> Callback_ImagerControlMgrIPC_ImagerConfigSetPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerConfigGet.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_ImagerConfigGet.
 */
class Callback_ImagerControlMgrIPC_ImagerConfigGet_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_ImagerConfigGet_Base> Callback_ImagerControlMgrIPC_ImagerConfigGetPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SlideLeavedImager.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_SlideLeavedImager.
 */
class Callback_ImagerControlMgrIPC_SlideLeavedImager_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_SlideLeavedImager_Base> Callback_ImagerControlMgrIPC_SlideLeavedImagerPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetAllRunInformations.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetAllRunInformations.
 */
class Callback_ImagerControlMgrIPC_GetAllRunInformations_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_GetAllRunInformations_Base> Callback_ImagerControlMgrIPC_GetAllRunInformationsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetRunInformation.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetRunInformation.
 */
class Callback_ImagerControlMgrIPC_GetRunInformation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_GetRunInformation_Base> Callback_ImagerControlMgrIPC_GetRunInformationPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallInformation.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetBasecallInformation.
 */
class Callback_ImagerControlMgrIPC_GetBasecallInformation_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_GetBasecallInformation_Base> Callback_ImagerControlMgrIPC_GetBasecallInformationPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_EndCycle.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_EndCycle.
 */
class Callback_ImagerControlMgrIPC_EndCycle_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_EndCycle_Base> Callback_ImagerControlMgrIPC_EndCyclePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_StartRunScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_StartRunScript.
 */
class Callback_ImagerControlMgrIPC_StartRunScript_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_StartRunScript_Base> Callback_ImagerControlMgrIPC_StartRunScriptPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallFlowcellConsumptionDiskSpace.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace.
 */
class Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace_Base> Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpacePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallRemoteDiskSpace.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace.
 */
class Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace_Base> Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpacePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallLocalDiskSpace.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace.
 */
class Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace_Base> Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpacePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetParam.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetParam.
 */
class Callback_ImagerControlMgrIPC_GetParam_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_GetParam_Base> Callback_ImagerControlMgrIPC_GetParamPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SetParam.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_SetParam.
 */
class Callback_ImagerControlMgrIPC_SetParam_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_SetParam_Base> Callback_ImagerControlMgrIPC_SetParamPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetVersions.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetVersions.
 */
class Callback_ImagerControlMgrIPC_GetVersions_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPC_GetVersions_Base> Callback_ImagerControlMgrIPC_GetVersionsPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerError.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendImagerError.
 */
class Callback_ImagerControlMgrIPCCallback_SendImagerError_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPCCallback_SendImagerError_Base> Callback_ImagerControlMgrIPCCallback_SendImagerErrorPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerRunInfo.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendImagerRunInfo.
 */
class Callback_ImagerControlMgrIPCCallback_SendImagerRunInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPCCallback_SendImagerRunInfo_Base> Callback_ImagerControlMgrIPCCallback_SendImagerRunInfoPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerTaskEnd.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendImagerTaskEnd.
 */
class Callback_ImagerControlMgrIPCCallback_SendImagerTaskEnd_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPCCallback_SendImagerTaskEnd_Base> Callback_ImagerControlMgrIPCCallback_SendImagerTaskEndPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendData.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendData.
 */
class Callback_ImagerControlMgrIPCCallback_SendData_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPCCallback_SendData_Base> Callback_ImagerControlMgrIPCCallback_SendDataPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendHeartbeat.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendHeartbeat.
 */
class Callback_ImagerControlMgrIPCCallback_SendHeartbeat_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPCCallback_SendHeartbeat_Base> Callback_ImagerControlMgrIPCCallback_SendHeartbeatPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendStatus.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendStatus.
 */
class Callback_ImagerControlMgrIPCCallback_SendStatus_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ImagerControlMgrIPCCallback_SendStatus_Base> Callback_ImagerControlMgrIPCCallback_SendStatusPtr;

}

}

namespace IceProxy
{

namespace BGI
{

namespace RPC
{

class ImagerControlMgrIPC : public virtual ::Ice::Proxy<ImagerControlMgrIPC, ::IceProxy::BGI::RPC::StageRunMgrIPC>
{
public:

    bool ImagerSetup(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ImagerSetup(_iceI_begin_ImagerSetup(info, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ImagerSetup(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ImagerSetup(info, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ImagerSetup(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ImagerSetup(info, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ImagerSetup(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ImagerSetup(info, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ImagerSetup(const ::BGI::RPC::ImagerSetupInfo& info, const ::BGI::RPC::Callback_ImagerControlMgrIPC_ImagerSetupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ImagerSetup(info, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ImagerSetup(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_ImagerSetupPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ImagerSetup(info, context, cb, cookie);
    }

    bool end_ImagerSetup(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ImagerSetup(const ::BGI::RPC::ImagerSetupInfo&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool Reset(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_Reset(_iceI_begin_Reset(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_Reset(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_Reset(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Reset(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Reset(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Reset(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Reset(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Reset(const ::BGI::RPC::Callback_ImagerControlMgrIPC_ResetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Reset(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Reset(const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_ResetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Reset(context, cb, cookie);
    }

    bool end_Reset(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_Reset(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool SetupRun(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetupRun(_iceI_begin_SetupRun(info, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetupRun(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetupRun(info, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetupRun(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetupRun(info, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetupRun(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetupRun(info, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetupRun(const ::BGI::RPC::ImagerSetupInfo& info, const ::BGI::RPC::Callback_ImagerControlMgrIPC_SetupRunPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetupRun(info, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetupRun(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_SetupRunPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetupRun(info, context, cb, cookie);
    }

    bool end_SetupRun(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetupRun(const ::BGI::RPC::ImagerSetupInfo&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool ReleaseRun(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ReleaseRun(_iceI_begin_ReleaseRun(info, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ReleaseRun(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ReleaseRun(info, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ReleaseRun(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ReleaseRun(info, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ReleaseRun(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ReleaseRun(info, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ReleaseRun(const ::BGI::RPC::ImagerSetupInfo& info, const ::BGI::RPC::Callback_ImagerControlMgrIPC_ReleaseRunPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ReleaseRun(info, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ReleaseRun(const ::BGI::RPC::ImagerSetupInfo& info, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_ReleaseRunPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ReleaseRun(info, context, cb, cookie);
    }

    bool end_ReleaseRun(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ReleaseRun(const ::BGI::RPC::ImagerSetupInfo&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GoHome(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GoHome(_iceI_begin_GoHome(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GoHome(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GoHome(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GoHome(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GoHome(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GoHome(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GoHome(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GoHome(const ::BGI::RPC::Callback_ImagerControlMgrIPC_GoHomePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GoHome(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GoHome(const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GoHomePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GoHome(context, cb, cookie);
    }

    bool end_GoHome(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GoHome(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GoLoadingPos(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GoLoadingPos(_iceI_begin_GoLoadingPos(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GoLoadingPos(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GoLoadingPos(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GoLoadingPos(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GoLoadingPos(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GoLoadingPos(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GoLoadingPos(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GoLoadingPos(const ::BGI::RPC::Callback_ImagerControlMgrIPC_GoLoadingPosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GoLoadingPos(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GoLoadingPos(const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GoLoadingPosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GoLoadingPos(context, cb, cookie);
    }

    bool end_GoLoadingPos(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GoLoadingPos(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GoWashPos(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GoWashPos(_iceI_begin_GoWashPos(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GoWashPos(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GoWashPos(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GoWashPos(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GoWashPos(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GoWashPos(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GoWashPos(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GoWashPos(const ::BGI::RPC::Callback_ImagerControlMgrIPC_GoWashPosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GoWashPos(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GoWashPos(const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GoWashPosPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GoWashPos(context, cb, cookie);
    }

    bool end_GoWashPos(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GoWashPos(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool IsAtLoadPosition(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_IsAtLoadPosition(_iceI_begin_IsAtLoadPosition(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_IsAtLoadPosition(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_IsAtLoadPosition(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_IsAtLoadPosition(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsAtLoadPosition(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IsAtLoadPosition(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsAtLoadPosition(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IsAtLoadPosition(const ::BGI::RPC::Callback_ImagerControlMgrIPC_IsAtLoadPositionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsAtLoadPosition(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_IsAtLoadPosition(const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_IsAtLoadPositionPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_IsAtLoadPosition(context, cb, cookie);
    }

    bool end_IsAtLoadPosition(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_IsAtLoadPosition(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool SwitchVacuum(bool valveStatus, bool pumpStatus, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SwitchVacuum(_iceI_begin_SwitchVacuum(valveStatus, pumpStatus, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SwitchVacuum(bool valveStatus, bool pumpStatus, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SwitchVacuum(valveStatus, pumpStatus, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SwitchVacuum(bool valveStatus, bool pumpStatus, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SwitchVacuum(valveStatus, pumpStatus, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SwitchVacuum(bool valveStatus, bool pumpStatus, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SwitchVacuum(valveStatus, pumpStatus, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SwitchVacuum(bool valveStatus, bool pumpStatus, const ::BGI::RPC::Callback_ImagerControlMgrIPC_SwitchVacuumPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SwitchVacuum(valveStatus, pumpStatus, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SwitchVacuum(bool valveStatus, bool pumpStatus, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_SwitchVacuumPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SwitchVacuum(valveStatus, pumpStatus, context, cb, cookie);
    }

    bool end_SwitchVacuum(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SwitchVacuum(bool, bool, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetVacuumStatus(::Ice::Double thresholdValueMin, ::Ice::Double thresholdValueMax, ::Ice::Int timeoutSec, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetVacuumStatus(_iceI_begin_GetVacuumStatus(thresholdValueMin, thresholdValueMax, timeoutSec, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetVacuumStatus(::Ice::Double thresholdValueMin, ::Ice::Double thresholdValueMax, ::Ice::Int timeoutSec, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetVacuumStatus(thresholdValueMin, thresholdValueMax, timeoutSec, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetVacuumStatus(::Ice::Double thresholdValueMin, ::Ice::Double thresholdValueMax, ::Ice::Int timeoutSec, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVacuumStatus(thresholdValueMin, thresholdValueMax, timeoutSec, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetVacuumStatus(::Ice::Double thresholdValueMin, ::Ice::Double thresholdValueMax, ::Ice::Int timeoutSec, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVacuumStatus(thresholdValueMin, thresholdValueMax, timeoutSec, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetVacuumStatus(::Ice::Double thresholdValueMin, ::Ice::Double thresholdValueMax, ::Ice::Int timeoutSec, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetVacuumStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVacuumStatus(thresholdValueMin, thresholdValueMax, timeoutSec, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetVacuumStatus(::Ice::Double thresholdValueMin, ::Ice::Double thresholdValueMax, ::Ice::Int timeoutSec, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetVacuumStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVacuumStatus(thresholdValueMin, thresholdValueMax, timeoutSec, context, cb, cookie);
    }

    bool end_GetVacuumStatus(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetVacuumStatus(::Ice::Double, ::Ice::Double, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool PreInjectSRE(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_PreInjectSRE(_iceI_begin_PreInjectSRE(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_PreInjectSRE(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_PreInjectSRE(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PreInjectSRE(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PreInjectSRE(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PreInjectSRE(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PreInjectSRE(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PreInjectSRE(const ::BGI::RPC::Callback_ImagerControlMgrIPC_PreInjectSREPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PreInjectSRE(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PreInjectSRE(const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_PreInjectSREPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PreInjectSRE(context, cb, cookie);
    }

    bool end_PreInjectSRE(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_PreInjectSRE(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool PreProcessing(::BGI::RPC::PreProcessingEnum type, ::Ice::Int timeoutSec, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_PreProcessing(_iceI_begin_PreProcessing(type, timeoutSec, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_PreProcessing(::BGI::RPC::PreProcessingEnum type, ::Ice::Int timeoutSec, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_PreProcessing(type, timeoutSec, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_PreProcessing(::BGI::RPC::PreProcessingEnum type, ::Ice::Int timeoutSec, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PreProcessing(type, timeoutSec, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PreProcessing(::BGI::RPC::PreProcessingEnum type, ::Ice::Int timeoutSec, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PreProcessing(type, timeoutSec, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PreProcessing(::BGI::RPC::PreProcessingEnum type, ::Ice::Int timeoutSec, const ::BGI::RPC::Callback_ImagerControlMgrIPC_PreProcessingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PreProcessing(type, timeoutSec, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_PreProcessing(::BGI::RPC::PreProcessingEnum type, ::Ice::Int timeoutSec, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_PreProcessingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_PreProcessing(type, timeoutSec, context, cb, cookie);
    }

    bool end_PreProcessing(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_PreProcessing(::BGI::RPC::PreProcessingEnum, ::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool ImagerConfigSet(const ::BGI::RPC::ImagerConfigData& config, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ImagerConfigSet(_iceI_begin_ImagerConfigSet(config, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ImagerConfigSet(const ::BGI::RPC::ImagerConfigData& config, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ImagerConfigSet(config, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ImagerConfigSet(const ::BGI::RPC::ImagerConfigData& config, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ImagerConfigSet(config, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ImagerConfigSet(const ::BGI::RPC::ImagerConfigData& config, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ImagerConfigSet(config, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ImagerConfigSet(const ::BGI::RPC::ImagerConfigData& config, const ::BGI::RPC::Callback_ImagerControlMgrIPC_ImagerConfigSetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ImagerConfigSet(config, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ImagerConfigSet(const ::BGI::RPC::ImagerConfigData& config, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_ImagerConfigSetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ImagerConfigSet(config, context, cb, cookie);
    }

    bool end_ImagerConfigSet(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ImagerConfigSet(const ::BGI::RPC::ImagerConfigData&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::BGI::RPC::ImagerConfigData ImagerConfigGet(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_ImagerConfigGet(_iceI_begin_ImagerConfigGet(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_ImagerConfigGet(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_ImagerConfigGet(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_ImagerConfigGet(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ImagerConfigGet(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ImagerConfigGet(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ImagerConfigGet(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ImagerConfigGet(const ::BGI::RPC::Callback_ImagerControlMgrIPC_ImagerConfigGetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ImagerConfigGet(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_ImagerConfigGet(const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_ImagerConfigGetPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_ImagerConfigGet(context, cb, cookie);
    }

    ::BGI::RPC::ImagerConfigData end_ImagerConfigGet(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_ImagerConfigGet(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SlideLeavedImager(::BGI::RPC::ImagerSlideLeavedReason reason, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SlideLeavedImager(_iceI_begin_SlideLeavedImager(reason, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SlideLeavedImager(::BGI::RPC::ImagerSlideLeavedReason reason, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SlideLeavedImager(reason, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SlideLeavedImager(::BGI::RPC::ImagerSlideLeavedReason reason, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SlideLeavedImager(reason, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SlideLeavedImager(::BGI::RPC::ImagerSlideLeavedReason reason, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SlideLeavedImager(reason, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SlideLeavedImager(::BGI::RPC::ImagerSlideLeavedReason reason, const ::BGI::RPC::Callback_ImagerControlMgrIPC_SlideLeavedImagerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SlideLeavedImager(reason, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SlideLeavedImager(::BGI::RPC::ImagerSlideLeavedReason reason, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_SlideLeavedImagerPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SlideLeavedImager(reason, context, cb, cookie);
    }

    void end_SlideLeavedImager(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SlideLeavedImager(::BGI::RPC::ImagerSlideLeavedReason, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::BGI::RPC::RunInformationArray GetAllRunInformations(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetAllRunInformations(_iceI_begin_GetAllRunInformations(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetAllRunInformations(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetAllRunInformations(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetAllRunInformations(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAllRunInformations(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAllRunInformations(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAllRunInformations(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAllRunInformations(const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetAllRunInformationsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAllRunInformations(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetAllRunInformations(const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetAllRunInformationsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetAllRunInformations(context, cb, cookie);
    }

    ::BGI::RPC::RunInformationArray end_GetAllRunInformations(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetAllRunInformations(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetRunInformation(const ::std::string& slideID, ::BGI::RPC::ImagerSetupInfo& runInfo, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetRunInformation(runInfo, _iceI_begin_GetRunInformation(slideID, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetRunInformation(const ::std::string& slideID, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetRunInformation(slideID, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetRunInformation(const ::std::string& slideID, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetRunInformation(slideID, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetRunInformation(const ::std::string& slideID, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetRunInformation(slideID, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetRunInformation(const ::std::string& slideID, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetRunInformationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetRunInformation(slideID, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetRunInformation(const ::std::string& slideID, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetRunInformationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetRunInformation(slideID, context, cb, cookie);
    }

    void end_GetRunInformation(::BGI::RPC::ImagerSetupInfo& runInfo, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetRunInformation(::BGI::RPC::ImagerSetupInfo& iceP_runInfo, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetRunInformation(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetBasecallInformation(const ::std::string& slideID, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetBasecallInformation(_iceI_begin_GetBasecallInformation(slideID, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetBasecallInformation(const ::std::string& slideID, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetBasecallInformation(slideID, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallInformation(const ::std::string& slideID, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallInformation(slideID, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallInformation(const ::std::string& slideID, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallInformation(slideID, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallInformation(const ::std::string& slideID, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetBasecallInformationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallInformation(slideID, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallInformation(const ::std::string& slideID, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetBasecallInformationPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallInformation(slideID, context, cb, cookie);
    }

    bool end_GetBasecallInformation(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetBasecallInformation(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool EndCycle(bool reSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_EndCycle(_iceI_begin_EndCycle(reSeq, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_EndCycle(bool reSeq, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_EndCycle(reSeq, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_EndCycle(bool reSeq, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_EndCycle(reSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_EndCycle(bool reSeq, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_EndCycle(reSeq, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_EndCycle(bool reSeq, const ::BGI::RPC::Callback_ImagerControlMgrIPC_EndCyclePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_EndCycle(reSeq, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_EndCycle(bool reSeq, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_EndCyclePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_EndCycle(reSeq, context, cb, cookie);
    }

    bool end_EndCycle(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_EndCycle(bool, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool StartRunScript(const ::std::string& scriptName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_StartRunScript(_iceI_begin_StartRunScript(scriptName, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_StartRunScript(const ::std::string& scriptName, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_StartRunScript(scriptName, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_StartRunScript(const ::std::string& scriptName, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartRunScript(scriptName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartRunScript(const ::std::string& scriptName, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartRunScript(scriptName, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartRunScript(const ::std::string& scriptName, const ::BGI::RPC::Callback_ImagerControlMgrIPC_StartRunScriptPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartRunScript(scriptName, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_StartRunScript(const ::std::string& scriptName, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_StartRunScriptPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_StartRunScript(scriptName, context, cb, cookie);
    }

    bool end_StartRunScript(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_StartRunScript(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetBasecallFlowcellConsumptionDiskSpace(::Ice::Double& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetBasecallFlowcellConsumptionDiskSpace(value, _iceI_begin_GetBasecallFlowcellConsumptionDiskSpace(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetBasecallFlowcellConsumptionDiskSpace(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetBasecallFlowcellConsumptionDiskSpace(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallFlowcellConsumptionDiskSpace(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallFlowcellConsumptionDiskSpace(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallFlowcellConsumptionDiskSpace(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallFlowcellConsumptionDiskSpace(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallFlowcellConsumptionDiskSpace(const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpacePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallFlowcellConsumptionDiskSpace(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallFlowcellConsumptionDiskSpace(const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpacePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallFlowcellConsumptionDiskSpace(context, cb, cookie);
    }

    bool end_GetBasecallFlowcellConsumptionDiskSpace(::Ice::Double& value, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetBasecallFlowcellConsumptionDiskSpace(::Ice::Double& iceP_value, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetBasecallFlowcellConsumptionDiskSpace(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetBasecallRemoteDiskSpace(::Ice::Double& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetBasecallRemoteDiskSpace(value, _iceI_begin_GetBasecallRemoteDiskSpace(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetBasecallRemoteDiskSpace(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetBasecallRemoteDiskSpace(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallRemoteDiskSpace(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallRemoteDiskSpace(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallRemoteDiskSpace(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallRemoteDiskSpace(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallRemoteDiskSpace(const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpacePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallRemoteDiskSpace(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallRemoteDiskSpace(const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpacePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallRemoteDiskSpace(context, cb, cookie);
    }

    bool end_GetBasecallRemoteDiskSpace(::Ice::Double& value, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetBasecallRemoteDiskSpace(::Ice::Double& iceP_value, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetBasecallRemoteDiskSpace(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetBasecallLocalDiskSpace(::Ice::Double& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetBasecallLocalDiskSpace(value, _iceI_begin_GetBasecallLocalDiskSpace(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetBasecallLocalDiskSpace(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetBasecallLocalDiskSpace(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallLocalDiskSpace(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallLocalDiskSpace(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallLocalDiskSpace(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallLocalDiskSpace(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallLocalDiskSpace(const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpacePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallLocalDiskSpace(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetBasecallLocalDiskSpace(const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpacePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetBasecallLocalDiskSpace(context, cb, cookie);
    }

    bool end_GetBasecallLocalDiskSpace(::Ice::Double& value, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetBasecallLocalDiskSpace(::Ice::Double& iceP_value, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetBasecallLocalDiskSpace(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool GetParam(const ::std::string& name, ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_GetParam(value, _iceI_begin_GetParam(name, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetParam(const ::std::string& name, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetParam(name, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetParam(const ::std::string& name, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetParam(name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetParam(const ::std::string& name, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetParam(name, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetParam(const ::std::string& name, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetParamPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetParam(name, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetParam(const ::std::string& name, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetParamPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetParam(name, context, cb, cookie);
    }

    bool end_GetParam(::std::string& value, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetParam(::std::string& iceP_value, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetParam(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool SetParam(const ::std::string& name, const ::std::string& value, bool saveToDisk, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SetParam(_iceI_begin_SetParam(name, value, saveToDisk, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SetParam(const ::std::string& name, const ::std::string& value, bool saveToDisk, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SetParam(name, value, saveToDisk, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SetParam(const ::std::string& name, const ::std::string& value, bool saveToDisk, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetParam(name, value, saveToDisk, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetParam(const ::std::string& name, const ::std::string& value, bool saveToDisk, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetParam(name, value, saveToDisk, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetParam(const ::std::string& name, const ::std::string& value, bool saveToDisk, const ::BGI::RPC::Callback_ImagerControlMgrIPC_SetParamPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetParam(name, value, saveToDisk, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SetParam(const ::std::string& name, const ::std::string& value, bool saveToDisk, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_SetParamPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SetParam(name, value, saveToDisk, context, cb, cookie);
    }

    bool end_SetParam(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SetParam(const ::std::string&, const ::std::string&, bool, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void GetVersions(::std::string& bcsVer, ::std::string& sbcVer, ::std::string& imagerVer, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_GetVersions(bcsVer, sbcVer, imagerVer, _iceI_begin_GetVersions(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_GetVersions(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_GetVersions(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_GetVersions(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVersions(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetVersions(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVersions(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetVersions(const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetVersionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVersions(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_GetVersions(const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPC_GetVersionsPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_GetVersions(context, cb, cookie);
    }

    void end_GetVersions(::std::string& bcsVer, ::std::string& sbcVer, ::std::string& imagerVer, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_GetVersions(::std::string& iceP_bcsVer, ::std::string& iceP_sbcVer, ::std::string& iceP_imagerVer, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_GetVersions(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

class ImagerControlMgrIPCCallback : public virtual ::Ice::Proxy<ImagerControlMgrIPCCallback, ::IceProxy::BGI::RPC::StageRunMgrIPCCallback>
{
public:

    void SendImagerError(::BGI::RPC::ImagerErrorEnum error, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendImagerError(_iceI_begin_SendImagerError(error, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendImagerError(::BGI::RPC::ImagerErrorEnum error, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendImagerError(error, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendImagerError(::BGI::RPC::ImagerErrorEnum error, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendImagerError(error, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendImagerError(::BGI::RPC::ImagerErrorEnum error, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendImagerError(error, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendImagerError(::BGI::RPC::ImagerErrorEnum error, const ::BGI::RPC::Callback_ImagerControlMgrIPCCallback_SendImagerErrorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendImagerError(error, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendImagerError(::BGI::RPC::ImagerErrorEnum error, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPCCallback_SendImagerErrorPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendImagerError(error, context, cb, cookie);
    }

    void end_SendImagerError(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendImagerError(::BGI::RPC::ImagerErrorEnum, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendImagerRunInfo(const ::BGI::RPC::ImagerRunInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendImagerRunInfo(_iceI_begin_SendImagerRunInfo(info, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendImagerRunInfo(const ::BGI::RPC::ImagerRunInfo& info, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendImagerRunInfo(info, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendImagerRunInfo(const ::BGI::RPC::ImagerRunInfo& info, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendImagerRunInfo(info, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendImagerRunInfo(const ::BGI::RPC::ImagerRunInfo& info, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendImagerRunInfo(info, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendImagerRunInfo(const ::BGI::RPC::ImagerRunInfo& info, const ::BGI::RPC::Callback_ImagerControlMgrIPCCallback_SendImagerRunInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendImagerRunInfo(info, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendImagerRunInfo(const ::BGI::RPC::ImagerRunInfo& info, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPCCallback_SendImagerRunInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendImagerRunInfo(info, context, cb, cookie);
    }

    void end_SendImagerRunInfo(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendImagerRunInfo(const ::BGI::RPC::ImagerRunInfo&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendImagerTaskEnd(const ::BGI::RPC::ImagerSetupInfo& info, ::BGI::RPC::ImagerErrorEnum error, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendImagerTaskEnd(_iceI_begin_SendImagerTaskEnd(info, error, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendImagerTaskEnd(const ::BGI::RPC::ImagerSetupInfo& info, ::BGI::RPC::ImagerErrorEnum error, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendImagerTaskEnd(info, error, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendImagerTaskEnd(const ::BGI::RPC::ImagerSetupInfo& info, ::BGI::RPC::ImagerErrorEnum error, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendImagerTaskEnd(info, error, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendImagerTaskEnd(const ::BGI::RPC::ImagerSetupInfo& info, ::BGI::RPC::ImagerErrorEnum error, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendImagerTaskEnd(info, error, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendImagerTaskEnd(const ::BGI::RPC::ImagerSetupInfo& info, ::BGI::RPC::ImagerErrorEnum error, const ::BGI::RPC::Callback_ImagerControlMgrIPCCallback_SendImagerTaskEndPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendImagerTaskEnd(info, error, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendImagerTaskEnd(const ::BGI::RPC::ImagerSetupInfo& info, ::BGI::RPC::ImagerErrorEnum error, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPCCallback_SendImagerTaskEndPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendImagerTaskEnd(info, error, context, cb, cookie);
    }

    void end_SendImagerTaskEnd(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendImagerTaskEnd(const ::BGI::RPC::ImagerSetupInfo&, ::BGI::RPC::ImagerErrorEnum, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendData(const ::std::string& key, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendData(_iceI_begin_SendData(key, value, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendData(const ::std::string& key, const ::std::string& value, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendData(key, value, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendData(const ::std::string& key, const ::std::string& value, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendData(key, value, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendData(const ::std::string& key, const ::std::string& value, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendData(key, value, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendData(const ::std::string& key, const ::std::string& value, const ::BGI::RPC::Callback_ImagerControlMgrIPCCallback_SendDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendData(key, value, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendData(const ::std::string& key, const ::std::string& value, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPCCallback_SendDataPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendData(key, value, context, cb, cookie);
    }

    void end_SendData(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendData(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    ::Ice::Int SendHeartbeat(::Ice::Int count, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_SendHeartbeat(_iceI_begin_SendHeartbeat(count, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendHeartbeat(::Ice::Int count, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendHeartbeat(count, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendHeartbeat(::Ice::Int count, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendHeartbeat(count, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendHeartbeat(::Ice::Int count, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendHeartbeat(count, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendHeartbeat(::Ice::Int count, const ::BGI::RPC::Callback_ImagerControlMgrIPCCallback_SendHeartbeatPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendHeartbeat(count, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendHeartbeat(::Ice::Int count, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPCCallback_SendHeartbeatPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendHeartbeat(count, context, cb, cookie);
    }

    ::Ice::Int end_SendHeartbeat(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendHeartbeat(::Ice::Int, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void SendStatus(::BGI::RPC::BasecallConnectState StateBasecall, ::BGI::RPC::ImagerServerState StateServer, ::BGI::RPC::ImagerState StateImager, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_SendStatus(_iceI_begin_SendStatus(StateBasecall, StateServer, StateImager, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_SendStatus(::BGI::RPC::BasecallConnectState StateBasecall, ::BGI::RPC::ImagerServerState StateServer, ::BGI::RPC::ImagerState StateImager, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_SendStatus(StateBasecall, StateServer, StateImager, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_SendStatus(::BGI::RPC::BasecallConnectState StateBasecall, ::BGI::RPC::ImagerServerState StateServer, ::BGI::RPC::ImagerState StateImager, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendStatus(StateBasecall, StateServer, StateImager, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendStatus(::BGI::RPC::BasecallConnectState StateBasecall, ::BGI::RPC::ImagerServerState StateServer, ::BGI::RPC::ImagerState StateImager, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendStatus(StateBasecall, StateServer, StateImager, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendStatus(::BGI::RPC::BasecallConnectState StateBasecall, ::BGI::RPC::ImagerServerState StateServer, ::BGI::RPC::ImagerState StateImager, const ::BGI::RPC::Callback_ImagerControlMgrIPCCallback_SendStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendStatus(StateBasecall, StateServer, StateImager, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_SendStatus(::BGI::RPC::BasecallConnectState StateBasecall, ::BGI::RPC::ImagerServerState StateServer, ::BGI::RPC::ImagerState StateImager, const ::Ice::Context& context, const ::BGI::RPC::Callback_ImagerControlMgrIPCCallback_SendStatusPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_SendStatus(StateBasecall, StateServer, StateImager, context, cb, cookie);
    }

    void end_SendStatus(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_SendStatus(::BGI::RPC::BasecallConnectState, ::BGI::RPC::ImagerServerState, ::BGI::RPC::ImagerState, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

}

namespace BGI
{

namespace RPC
{

class ImagerControlMgrIPC : virtual public StageRunMgrIPC
{
public:

    typedef ImagerControlMgrIPCPrx ProxyType;
    typedef ImagerControlMgrIPCPtr PointerType;

    virtual ~ImagerControlMgrIPC();

#ifdef ICE_CPP11_COMPILER
    ImagerControlMgrIPC() = default;
    ImagerControlMgrIPC(const ImagerControlMgrIPC&) = default;
    ImagerControlMgrIPC& operator=(const ImagerControlMgrIPC&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool ImagerSetup(const ImagerSetupInfo& info, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ImagerSetup(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool Reset(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_Reset(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool SetupRun(const ImagerSetupInfo& info, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetupRun(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool ReleaseRun(const ImagerSetupInfo& info, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ReleaseRun(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GoHome(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GoHome(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GoLoadingPos(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GoLoadingPos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GoWashPos(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GoWashPos(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool IsAtLoadPosition(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_IsAtLoadPosition(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool SwitchVacuum(bool valveStatus, bool pumpStatus, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SwitchVacuum(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetVacuumStatus(::Ice::Double thresholdValueMin, ::Ice::Double thresholdValueMax, ::Ice::Int timeoutSec, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetVacuumStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool PreInjectSRE(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_PreInjectSRE(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool PreProcessing(PreProcessingEnum type, ::Ice::Int timeoutSec, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_PreProcessing(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool ImagerConfigSet(const ImagerConfigData& config, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ImagerConfigSet(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ImagerConfigData ImagerConfigGet(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_ImagerConfigGet(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SlideLeavedImager(ImagerSlideLeavedReason reason, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SlideLeavedImager(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual RunInformationArray GetAllRunInformations(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetAllRunInformations(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetRunInformation(const ::std::string& slideID, ImagerSetupInfo& runInfo, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetRunInformation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetBasecallInformation(const ::std::string& slideID, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetBasecallInformation(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool EndCycle(bool reSeq, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_EndCycle(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool StartRunScript(const ::std::string& scriptName, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_StartRunScript(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetBasecallFlowcellConsumptionDiskSpace(::Ice::Double& value, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetBasecallFlowcellConsumptionDiskSpace(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetBasecallRemoteDiskSpace(::Ice::Double& value, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetBasecallRemoteDiskSpace(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetBasecallLocalDiskSpace(::Ice::Double& value, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetBasecallLocalDiskSpace(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool GetParam(const ::std::string& name, ::std::string& value, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetParam(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool SetParam(const ::std::string& name, const ::std::string& value, bool saveToDisk, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SetParam(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void GetVersions(::std::string& bcsVer, ::std::string& sbcVer, ::std::string& imagerVer, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_GetVersions(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const ImagerControlMgrIPC& lhs, const ImagerControlMgrIPC& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ImagerControlMgrIPC& lhs, const ImagerControlMgrIPC& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

class ImagerControlMgrIPCCallback : virtual public StageRunMgrIPCCallback
{
public:

    typedef ImagerControlMgrIPCCallbackPrx ProxyType;
    typedef ImagerControlMgrIPCCallbackPtr PointerType;

    virtual ~ImagerControlMgrIPCCallback();

#ifdef ICE_CPP11_COMPILER
    ImagerControlMgrIPCCallback() = default;
    ImagerControlMgrIPCCallback(const ImagerControlMgrIPCCallback&) = default;
    ImagerControlMgrIPCCallback& operator=(const ImagerControlMgrIPCCallback&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual void SendImagerError(ImagerErrorEnum error, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendImagerError(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendImagerRunInfo(const ImagerRunInfo& info, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendImagerRunInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendImagerTaskEnd(const ImagerSetupInfo& info, ImagerErrorEnum error, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendImagerTaskEnd(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendData(const ::std::string& key, const ::std::string& value, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendData(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual ::Ice::Int SendHeartbeat(::Ice::Int count, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendHeartbeat(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void SendStatus(BasecallConnectState StateBasecall, ImagerServerState StateServer, ImagerState StateImager, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_SendStatus(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const ImagerControlMgrIPCCallback& lhs, const ImagerControlMgrIPCCallback& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ImagerControlMgrIPCCallback& lhs, const ImagerControlMgrIPCCallback& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

}

/// \cond STREAM
namespace Ice
{

template<>
struct StreamableTraits< ::BGI::RPC::BasecallConnectState>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 1;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::ImagerServerState>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::ImagerState>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 13;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::ImagerRunInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 41;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::BGI::RPC::ImagerRunInfo, S>
{
    static void write(S* ostr, const ::BGI::RPC::ImagerRunInfo& v)
    {
        ostr->write(v.SlideID);
        ostr->write(v.CurrentRow);
        ostr->write(v.CurrentCol);
        ostr->write(v.CurrentCycle);
        ostr->write(v.CurrentLane);
        ostr->write(v.StartRow);
        ostr->write(v.EndRow);
        ostr->write(v.StartCol);
        ostr->write(v.EndCol);
        ostr->write(v.TotalLane);
        ostr->write(v.ScanDirect);
    }
};

template<typename S>
struct StreamReader< ::BGI::RPC::ImagerRunInfo, S>
{
    static void read(S* istr, ::BGI::RPC::ImagerRunInfo& v)
    {
        istr->read(v.SlideID);
        istr->read(v.CurrentRow);
        istr->read(v.CurrentCol);
        istr->read(v.CurrentCycle);
        istr->read(v.CurrentLane);
        istr->read(v.StartRow);
        istr->read(v.EndRow);
        istr->read(v.StartCol);
        istr->read(v.EndCol);
        istr->read(v.TotalLane);
        istr->read(v.ScanDirect);
    }
};

template<>
struct StreamableTraits< ::BGI::RPC::ImagerSlideLeavedReason>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 2;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::ImagerErrorEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 26100;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::ImagerDataEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 1;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::EndCycleProcessModeEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 3;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::SequencingTypeEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 99;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::PreProcessingEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 1;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::ImagerConfigData>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 53;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::BGI::RPC::ImagerConfigData, S>
{
    static void write(S* ostr, const ::BGI::RPC::ImagerConfigData& v)
    {
        ostr->write(v.Lane);
        ostr->write(v.Reference);
        ostr->write(v.BasecallMode);
        ostr->write(v.IsSaveRawImage);
        ostr->write(v.IsImageSimulated);
        ostr->write(v.SettingTime);
        ostr->write(v.CheckThetaMode);
        ostr->write(v.Direction);
        ostr->write(v.StartRow);
        ostr->write(v.EndRow);
        ostr->write(v.StartCol);
        ostr->write(v.EndCol);
        ostr->write(v.IsExposureFileClean);
        ostr->write(v.ExposureTime);
        ostr->write(v.ExposureFactors);
        ostr->write(v.SaveFovString);
        ostr->write(v.EndCycleProcessMode);
        ostr->write(v.VacuumSupplyThreshold);
        ostr->write(v.ExtraSettings);
    }
};

template<typename S>
struct StreamReader< ::BGI::RPC::ImagerConfigData, S>
{
    static void read(S* istr, ::BGI::RPC::ImagerConfigData& v)
    {
        istr->read(v.Lane);
        istr->read(v.Reference);
        istr->read(v.BasecallMode);
        istr->read(v.IsSaveRawImage);
        istr->read(v.IsImageSimulated);
        istr->read(v.SettingTime);
        istr->read(v.CheckThetaMode);
        istr->read(v.Direction);
        istr->read(v.StartRow);
        istr->read(v.EndRow);
        istr->read(v.StartCol);
        istr->read(v.EndCol);
        istr->read(v.IsExposureFileClean);
        istr->read(v.ExposureTime);
        istr->read(v.ExposureFactors);
        istr->read(v.SaveFovString);
        istr->read(v.EndCycleProcessMode);
        istr->read(v.VacuumSupplyThreshold);
        istr->read(v.ExtraSettings);
    }
};

template<>
struct StreamableTraits< ::BGI::RPC::ImagerSetupInfo>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 84;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::BGI::RPC::ImagerSetupInfo, S>
{
    static void write(S* ostr, const ::BGI::RPC::ImagerSetupInfo& v)
    {
        ostr->write(v.SlideID);
        ostr->write(v.ScriptName);
        ostr->write(v.ExperimentName);
        ostr->write(v.UserName);
        ostr->write(v.ImagerID);
        ostr->write(v.ZAFOffset);
        ostr->write(v.IsCalAFOffset);
        ostr->write(v.Read1Len);
        ostr->write(v.Read2Len);
        ostr->write(v.Barcode1Len);
        ostr->write(v.Barcode2Len);
        ostr->write(v.Reference);
        ostr->write(v.BioBarcode);
        ostr->write(v.TotalCycle);
        ostr->write(v.BiochemCycle);
        ostr->write(v.ImagerCycle);
        ostr->write(v.TolerancePattern);
        ostr->write(v.sequencingType);
        ostr->write(v.FqBarcode1Length);
        ostr->write(v.FqBarcode1StartPos);
        ostr->write(v.FqSpeciesMismatch);
        ostr->write(v.FqBarcode2Length);
        ostr->write(v.FqBarcode2StartPos);
        ostr->write(v.FqSpeciesMismatch2);
        ostr->write(v.FilterMode);
        ostr->write(v.WriteFastqMode);
        ostr->write(v.BarcodeReverse);
    }
};

template<typename S>
struct StreamReader< ::BGI::RPC::ImagerSetupInfo, S>
{
    static void read(S* istr, ::BGI::RPC::ImagerSetupInfo& v)
    {
        istr->read(v.SlideID);
        istr->read(v.ScriptName);
        istr->read(v.ExperimentName);
        istr->read(v.UserName);
        istr->read(v.ImagerID);
        istr->read(v.ZAFOffset);
        istr->read(v.IsCalAFOffset);
        istr->read(v.Read1Len);
        istr->read(v.Read2Len);
        istr->read(v.Barcode1Len);
        istr->read(v.Barcode2Len);
        istr->read(v.Reference);
        istr->read(v.BioBarcode);
        istr->read(v.TotalCycle);
        istr->read(v.BiochemCycle);
        istr->read(v.ImagerCycle);
        istr->read(v.TolerancePattern);
        istr->read(v.sequencingType);
        istr->read(v.FqBarcode1Length);
        istr->read(v.FqBarcode1StartPos);
        istr->read(v.FqSpeciesMismatch);
        istr->read(v.FqBarcode2Length);
        istr->read(v.FqBarcode2StartPos);
        istr->read(v.FqSpeciesMismatch2);
        istr->read(v.FilterMode);
        istr->read(v.WriteFastqMode);
        istr->read(v.BarcodeReverse);
    }
};

template<>
struct StreamableTraits< ::BGI::RPC::BasecallStatusEnum>
{
    static const StreamHelperCategory helper = StreamHelperCategoryEnum;
    static const int minValue = 0;
    static const int maxValue = 6;
    static const int minWireSize = 1;
    static const bool fixedLength = false;
};

template<>
struct StreamableTraits< ::BGI::RPC::RunInformation>
{
    static const StreamHelperCategory helper = StreamHelperCategoryStruct;
    static const int minWireSize = 55;
    static const bool fixedLength = false;
};

template<typename S>
struct StreamWriter< ::BGI::RPC::RunInformation, S>
{
    static void write(S* ostr, const ::BGI::RPC::RunInformation& v)
    {
        ostr->write(v.Status);
        ostr->write(v.Reseq);
        ostr->write(v.SlideID);
        ostr->write(v.CurrentCycle);
        ostr->write(v.Lane);
        ostr->write(v.StarRow);
        ostr->write(v.EndRow);
        ostr->write(v.StartCol);
        ostr->write(v.EndCol);
        ostr->write(v.TotalCycle);
        ostr->write(v.StartCycle);
        ostr->write(v.Read1Length);
        ostr->write(v.Read2Length);
        ostr->write(v.BarcodeLength);
        ostr->write(v.FovNumMaxPerScan);
        ostr->write(v.BarcodePos);
    }
};

template<typename S>
struct StreamReader< ::BGI::RPC::RunInformation, S>
{
    static void read(S* istr, ::BGI::RPC::RunInformation& v)
    {
        istr->read(v.Status);
        istr->read(v.Reseq);
        istr->read(v.SlideID);
        istr->read(v.CurrentCycle);
        istr->read(v.Lane);
        istr->read(v.StarRow);
        istr->read(v.EndRow);
        istr->read(v.StartCol);
        istr->read(v.EndCol);
        istr->read(v.TotalCycle);
        istr->read(v.StartCycle);
        istr->read(v.Read1Length);
        istr->read(v.Read2Length);
        istr->read(v.BarcodeLength);
        istr->read(v.FovNumMaxPerScan);
        istr->read(v.BarcodePos);
    }
};

}
/// \endcond

namespace BGI
{

namespace RPC
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerSetup.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_ImagerSetup.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_ImagerSetup : public Callback_ImagerControlMgrIPC_ImagerSetup_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_ImagerSetup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_ImagerSetup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerSetup.
 */
template<class T> Callback_ImagerControlMgrIPC_ImagerSetupPtr
newCallback_ImagerControlMgrIPC_ImagerSetup(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_ImagerSetup<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerSetup.
 */
template<class T> Callback_ImagerControlMgrIPC_ImagerSetupPtr
newCallback_ImagerControlMgrIPC_ImagerSetup(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_ImagerSetup<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerSetup.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_ImagerSetup.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_ImagerSetup : public Callback_ImagerControlMgrIPC_ImagerSetup_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_ImagerSetup(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_ImagerSetup(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerSetup.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_ImagerSetupPtr
newCallback_ImagerControlMgrIPC_ImagerSetup(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_ImagerSetup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerSetup.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_ImagerSetupPtr
newCallback_ImagerControlMgrIPC_ImagerSetup(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_ImagerSetup<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_Reset.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_Reset.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_Reset : public Callback_ImagerControlMgrIPC_Reset_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_Reset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_Reset(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_Reset.
 */
template<class T> Callback_ImagerControlMgrIPC_ResetPtr
newCallback_ImagerControlMgrIPC_Reset(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_Reset<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_Reset.
 */
template<class T> Callback_ImagerControlMgrIPC_ResetPtr
newCallback_ImagerControlMgrIPC_Reset(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_Reset<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_Reset.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_Reset.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_Reset : public Callback_ImagerControlMgrIPC_Reset_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_Reset(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_Reset(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_Reset.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_ResetPtr
newCallback_ImagerControlMgrIPC_Reset(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_Reset<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_Reset.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_ResetPtr
newCallback_ImagerControlMgrIPC_Reset(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_Reset<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SetupRun.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_SetupRun.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_SetupRun : public Callback_ImagerControlMgrIPC_SetupRun_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_SetupRun(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_SetupRun(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SetupRun.
 */
template<class T> Callback_ImagerControlMgrIPC_SetupRunPtr
newCallback_ImagerControlMgrIPC_SetupRun(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_SetupRun<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SetupRun.
 */
template<class T> Callback_ImagerControlMgrIPC_SetupRunPtr
newCallback_ImagerControlMgrIPC_SetupRun(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_SetupRun<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SetupRun.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_SetupRun.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_SetupRun : public Callback_ImagerControlMgrIPC_SetupRun_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_SetupRun(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_SetupRun(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SetupRun.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_SetupRunPtr
newCallback_ImagerControlMgrIPC_SetupRun(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_SetupRun<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SetupRun.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_SetupRunPtr
newCallback_ImagerControlMgrIPC_SetupRun(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_SetupRun<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ReleaseRun.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_ReleaseRun.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_ReleaseRun : public Callback_ImagerControlMgrIPC_ReleaseRun_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_ReleaseRun(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_ReleaseRun(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ReleaseRun.
 */
template<class T> Callback_ImagerControlMgrIPC_ReleaseRunPtr
newCallback_ImagerControlMgrIPC_ReleaseRun(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_ReleaseRun<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ReleaseRun.
 */
template<class T> Callback_ImagerControlMgrIPC_ReleaseRunPtr
newCallback_ImagerControlMgrIPC_ReleaseRun(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_ReleaseRun<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ReleaseRun.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_ReleaseRun.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_ReleaseRun : public Callback_ImagerControlMgrIPC_ReleaseRun_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_ReleaseRun(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_ReleaseRun(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ReleaseRun.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_ReleaseRunPtr
newCallback_ImagerControlMgrIPC_ReleaseRun(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_ReleaseRun<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ReleaseRun.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_ReleaseRunPtr
newCallback_ImagerControlMgrIPC_ReleaseRun(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_ReleaseRun<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoHome.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GoHome.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_GoHome : public Callback_ImagerControlMgrIPC_GoHome_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_GoHome(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_GoHome(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoHome.
 */
template<class T> Callback_ImagerControlMgrIPC_GoHomePtr
newCallback_ImagerControlMgrIPC_GoHome(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GoHome<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoHome.
 */
template<class T> Callback_ImagerControlMgrIPC_GoHomePtr
newCallback_ImagerControlMgrIPC_GoHome(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GoHome<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoHome.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GoHome.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_GoHome : public Callback_ImagerControlMgrIPC_GoHome_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_GoHome(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_GoHome(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoHome.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GoHomePtr
newCallback_ImagerControlMgrIPC_GoHome(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GoHome<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoHome.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GoHomePtr
newCallback_ImagerControlMgrIPC_GoHome(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GoHome<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoLoadingPos.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GoLoadingPos.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_GoLoadingPos : public Callback_ImagerControlMgrIPC_GoLoadingPos_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_GoLoadingPos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_GoLoadingPos(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoLoadingPos.
 */
template<class T> Callback_ImagerControlMgrIPC_GoLoadingPosPtr
newCallback_ImagerControlMgrIPC_GoLoadingPos(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GoLoadingPos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoLoadingPos.
 */
template<class T> Callback_ImagerControlMgrIPC_GoLoadingPosPtr
newCallback_ImagerControlMgrIPC_GoLoadingPos(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GoLoadingPos<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoLoadingPos.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GoLoadingPos.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_GoLoadingPos : public Callback_ImagerControlMgrIPC_GoLoadingPos_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_GoLoadingPos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_GoLoadingPos(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoLoadingPos.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GoLoadingPosPtr
newCallback_ImagerControlMgrIPC_GoLoadingPos(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GoLoadingPos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoLoadingPos.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GoLoadingPosPtr
newCallback_ImagerControlMgrIPC_GoLoadingPos(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GoLoadingPos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoWashPos.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GoWashPos.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_GoWashPos : public Callback_ImagerControlMgrIPC_GoWashPos_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_GoWashPos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_GoWashPos(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoWashPos.
 */
template<class T> Callback_ImagerControlMgrIPC_GoWashPosPtr
newCallback_ImagerControlMgrIPC_GoWashPos(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GoWashPos<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoWashPos.
 */
template<class T> Callback_ImagerControlMgrIPC_GoWashPosPtr
newCallback_ImagerControlMgrIPC_GoWashPos(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GoWashPos<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoWashPos.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GoWashPos.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_GoWashPos : public Callback_ImagerControlMgrIPC_GoWashPos_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_GoWashPos(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_GoWashPos(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoWashPos.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GoWashPosPtr
newCallback_ImagerControlMgrIPC_GoWashPos(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GoWashPos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GoWashPos.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GoWashPosPtr
newCallback_ImagerControlMgrIPC_GoWashPos(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GoWashPos<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_IsAtLoadPosition.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_IsAtLoadPosition.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_IsAtLoadPosition : public Callback_ImagerControlMgrIPC_IsAtLoadPosition_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_IsAtLoadPosition(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_IsAtLoadPosition(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_IsAtLoadPosition.
 */
template<class T> Callback_ImagerControlMgrIPC_IsAtLoadPositionPtr
newCallback_ImagerControlMgrIPC_IsAtLoadPosition(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_IsAtLoadPosition<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_IsAtLoadPosition.
 */
template<class T> Callback_ImagerControlMgrIPC_IsAtLoadPositionPtr
newCallback_ImagerControlMgrIPC_IsAtLoadPosition(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_IsAtLoadPosition<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_IsAtLoadPosition.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_IsAtLoadPosition.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_IsAtLoadPosition : public Callback_ImagerControlMgrIPC_IsAtLoadPosition_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_IsAtLoadPosition(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_IsAtLoadPosition(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_IsAtLoadPosition.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_IsAtLoadPositionPtr
newCallback_ImagerControlMgrIPC_IsAtLoadPosition(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_IsAtLoadPosition<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_IsAtLoadPosition.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_IsAtLoadPositionPtr
newCallback_ImagerControlMgrIPC_IsAtLoadPosition(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_IsAtLoadPosition<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SwitchVacuum.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_SwitchVacuum.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_SwitchVacuum : public Callback_ImagerControlMgrIPC_SwitchVacuum_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_SwitchVacuum(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_SwitchVacuum(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SwitchVacuum.
 */
template<class T> Callback_ImagerControlMgrIPC_SwitchVacuumPtr
newCallback_ImagerControlMgrIPC_SwitchVacuum(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_SwitchVacuum<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SwitchVacuum.
 */
template<class T> Callback_ImagerControlMgrIPC_SwitchVacuumPtr
newCallback_ImagerControlMgrIPC_SwitchVacuum(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_SwitchVacuum<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SwitchVacuum.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_SwitchVacuum.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_SwitchVacuum : public Callback_ImagerControlMgrIPC_SwitchVacuum_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_SwitchVacuum(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_SwitchVacuum(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SwitchVacuum.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_SwitchVacuumPtr
newCallback_ImagerControlMgrIPC_SwitchVacuum(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_SwitchVacuum<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SwitchVacuum.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_SwitchVacuumPtr
newCallback_ImagerControlMgrIPC_SwitchVacuum(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_SwitchVacuum<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetVacuumStatus.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetVacuumStatus.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_GetVacuumStatus : public Callback_ImagerControlMgrIPC_GetVacuumStatus_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_GetVacuumStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_GetVacuumStatus(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetVacuumStatus.
 */
template<class T> Callback_ImagerControlMgrIPC_GetVacuumStatusPtr
newCallback_ImagerControlMgrIPC_GetVacuumStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetVacuumStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetVacuumStatus.
 */
template<class T> Callback_ImagerControlMgrIPC_GetVacuumStatusPtr
newCallback_ImagerControlMgrIPC_GetVacuumStatus(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetVacuumStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetVacuumStatus.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetVacuumStatus.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_GetVacuumStatus : public Callback_ImagerControlMgrIPC_GetVacuumStatus_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_GetVacuumStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_GetVacuumStatus(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetVacuumStatus.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetVacuumStatusPtr
newCallback_ImagerControlMgrIPC_GetVacuumStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetVacuumStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetVacuumStatus.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetVacuumStatusPtr
newCallback_ImagerControlMgrIPC_GetVacuumStatus(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetVacuumStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_PreInjectSRE.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_PreInjectSRE.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_PreInjectSRE : public Callback_ImagerControlMgrIPC_PreInjectSRE_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_PreInjectSRE(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_PreInjectSRE(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_PreInjectSRE.
 */
template<class T> Callback_ImagerControlMgrIPC_PreInjectSREPtr
newCallback_ImagerControlMgrIPC_PreInjectSRE(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_PreInjectSRE<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_PreInjectSRE.
 */
template<class T> Callback_ImagerControlMgrIPC_PreInjectSREPtr
newCallback_ImagerControlMgrIPC_PreInjectSRE(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_PreInjectSRE<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_PreInjectSRE.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_PreInjectSRE.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_PreInjectSRE : public Callback_ImagerControlMgrIPC_PreInjectSRE_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_PreInjectSRE(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_PreInjectSRE(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_PreInjectSRE.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_PreInjectSREPtr
newCallback_ImagerControlMgrIPC_PreInjectSRE(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_PreInjectSRE<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_PreInjectSRE.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_PreInjectSREPtr
newCallback_ImagerControlMgrIPC_PreInjectSRE(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_PreInjectSRE<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_PreProcessing.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_PreProcessing.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_PreProcessing : public Callback_ImagerControlMgrIPC_PreProcessing_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_PreProcessing(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_PreProcessing(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_PreProcessing.
 */
template<class T> Callback_ImagerControlMgrIPC_PreProcessingPtr
newCallback_ImagerControlMgrIPC_PreProcessing(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_PreProcessing<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_PreProcessing.
 */
template<class T> Callback_ImagerControlMgrIPC_PreProcessingPtr
newCallback_ImagerControlMgrIPC_PreProcessing(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_PreProcessing<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_PreProcessing.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_PreProcessing.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_PreProcessing : public Callback_ImagerControlMgrIPC_PreProcessing_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_PreProcessing(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_PreProcessing(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_PreProcessing.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_PreProcessingPtr
newCallback_ImagerControlMgrIPC_PreProcessing(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_PreProcessing<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_PreProcessing.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_PreProcessingPtr
newCallback_ImagerControlMgrIPC_PreProcessing(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_PreProcessing<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerConfigSet.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_ImagerConfigSet.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_ImagerConfigSet : public Callback_ImagerControlMgrIPC_ImagerConfigSet_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_ImagerConfigSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_ImagerConfigSet(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerConfigSet.
 */
template<class T> Callback_ImagerControlMgrIPC_ImagerConfigSetPtr
newCallback_ImagerControlMgrIPC_ImagerConfigSet(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_ImagerConfigSet<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerConfigSet.
 */
template<class T> Callback_ImagerControlMgrIPC_ImagerConfigSetPtr
newCallback_ImagerControlMgrIPC_ImagerConfigSet(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_ImagerConfigSet<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerConfigSet.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_ImagerConfigSet.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_ImagerConfigSet : public Callback_ImagerControlMgrIPC_ImagerConfigSet_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_ImagerConfigSet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_ImagerConfigSet(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerConfigSet.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_ImagerConfigSetPtr
newCallback_ImagerControlMgrIPC_ImagerConfigSet(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_ImagerConfigSet<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerConfigSet.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_ImagerConfigSetPtr
newCallback_ImagerControlMgrIPC_ImagerConfigSet(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_ImagerConfigSet<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerConfigGet.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_ImagerConfigGet.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_ImagerConfigGet : public Callback_ImagerControlMgrIPC_ImagerConfigGet_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ImagerConfigData&);

    CallbackNC_ImagerControlMgrIPC_ImagerConfigGet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        ImagerConfigData ret;
        try
        {
            ret = proxy->end_ImagerConfigGet(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerConfigGet.
 */
template<class T> Callback_ImagerControlMgrIPC_ImagerConfigGetPtr
newCallback_ImagerControlMgrIPC_ImagerConfigGet(const IceUtil::Handle<T>& instance, void (T::*cb)(const ImagerConfigData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_ImagerConfigGet<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerConfigGet.
 */
template<class T> Callback_ImagerControlMgrIPC_ImagerConfigGetPtr
newCallback_ImagerControlMgrIPC_ImagerConfigGet(T* instance, void (T::*cb)(const ImagerConfigData&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_ImagerConfigGet<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerConfigGet.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_ImagerConfigGet.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_ImagerConfigGet : public Callback_ImagerControlMgrIPC_ImagerConfigGet_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ImagerConfigData&, const CT&);

    Callback_ImagerControlMgrIPC_ImagerConfigGet(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        ImagerConfigData ret;
        try
        {
            ret = proxy->end_ImagerConfigGet(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerConfigGet.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_ImagerConfigGetPtr
newCallback_ImagerControlMgrIPC_ImagerConfigGet(const IceUtil::Handle<T>& instance, void (T::*cb)(const ImagerConfigData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_ImagerConfigGet<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_ImagerConfigGet.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_ImagerConfigGetPtr
newCallback_ImagerControlMgrIPC_ImagerConfigGet(T* instance, void (T::*cb)(const ImagerConfigData&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_ImagerConfigGet<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SlideLeavedImager.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_SlideLeavedImager.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_SlideLeavedImager : public Callback_ImagerControlMgrIPC_SlideLeavedImager_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ImagerControlMgrIPC_SlideLeavedImager(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SlideLeavedImager.
 */
template<class T> Callback_ImagerControlMgrIPC_SlideLeavedImagerPtr
newCallback_ImagerControlMgrIPC_SlideLeavedImager(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_SlideLeavedImager<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SlideLeavedImager.
 */
template<class T> Callback_ImagerControlMgrIPC_SlideLeavedImagerPtr
newCallback_ImagerControlMgrIPC_SlideLeavedImager(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_SlideLeavedImager<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SlideLeavedImager.
 */
template<class T> Callback_ImagerControlMgrIPC_SlideLeavedImagerPtr
newCallback_ImagerControlMgrIPC_SlideLeavedImager(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_SlideLeavedImager<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SlideLeavedImager.
 */
template<class T> Callback_ImagerControlMgrIPC_SlideLeavedImagerPtr
newCallback_ImagerControlMgrIPC_SlideLeavedImager(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_SlideLeavedImager<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SlideLeavedImager.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_SlideLeavedImager.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_SlideLeavedImager : public Callback_ImagerControlMgrIPC_SlideLeavedImager_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ImagerControlMgrIPC_SlideLeavedImager(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SlideLeavedImager.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_SlideLeavedImagerPtr
newCallback_ImagerControlMgrIPC_SlideLeavedImager(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_SlideLeavedImager<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SlideLeavedImager.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_SlideLeavedImagerPtr
newCallback_ImagerControlMgrIPC_SlideLeavedImager(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_SlideLeavedImager<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SlideLeavedImager.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_SlideLeavedImagerPtr
newCallback_ImagerControlMgrIPC_SlideLeavedImager(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_SlideLeavedImager<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SlideLeavedImager.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_SlideLeavedImagerPtr
newCallback_ImagerControlMgrIPC_SlideLeavedImager(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_SlideLeavedImager<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetAllRunInformations.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetAllRunInformations.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_GetAllRunInformations : public Callback_ImagerControlMgrIPC_GetAllRunInformations_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const RunInformationArray&);

    CallbackNC_ImagerControlMgrIPC_GetAllRunInformations(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        RunInformationArray ret;
        try
        {
            ret = proxy->end_GetAllRunInformations(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetAllRunInformations.
 */
template<class T> Callback_ImagerControlMgrIPC_GetAllRunInformationsPtr
newCallback_ImagerControlMgrIPC_GetAllRunInformations(const IceUtil::Handle<T>& instance, void (T::*cb)(const RunInformationArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetAllRunInformations<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetAllRunInformations.
 */
template<class T> Callback_ImagerControlMgrIPC_GetAllRunInformationsPtr
newCallback_ImagerControlMgrIPC_GetAllRunInformations(T* instance, void (T::*cb)(const RunInformationArray&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetAllRunInformations<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetAllRunInformations.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetAllRunInformations.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_GetAllRunInformations : public Callback_ImagerControlMgrIPC_GetAllRunInformations_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const RunInformationArray&, const CT&);

    Callback_ImagerControlMgrIPC_GetAllRunInformations(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        RunInformationArray ret;
        try
        {
            ret = proxy->end_GetAllRunInformations(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetAllRunInformations.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetAllRunInformationsPtr
newCallback_ImagerControlMgrIPC_GetAllRunInformations(const IceUtil::Handle<T>& instance, void (T::*cb)(const RunInformationArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetAllRunInformations<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetAllRunInformations.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetAllRunInformationsPtr
newCallback_ImagerControlMgrIPC_GetAllRunInformations(T* instance, void (T::*cb)(const RunInformationArray&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetAllRunInformations<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetRunInformation.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetRunInformation.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_GetRunInformation : public Callback_ImagerControlMgrIPC_GetRunInformation_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ImagerSetupInfo&);

    CallbackNC_ImagerControlMgrIPC_GetRunInformation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        ImagerSetupInfo iceP_runInfo;
        try
        {
            proxy->end_GetRunInformation(iceP_runInfo, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_runInfo);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetRunInformation.
 */
template<class T> Callback_ImagerControlMgrIPC_GetRunInformationPtr
newCallback_ImagerControlMgrIPC_GetRunInformation(const IceUtil::Handle<T>& instance, void (T::*cb)(const ImagerSetupInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetRunInformation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetRunInformation.
 */
template<class T> Callback_ImagerControlMgrIPC_GetRunInformationPtr
newCallback_ImagerControlMgrIPC_GetRunInformation(T* instance, void (T::*cb)(const ImagerSetupInfo&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetRunInformation<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetRunInformation.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetRunInformation.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_GetRunInformation : public Callback_ImagerControlMgrIPC_GetRunInformation_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ImagerSetupInfo&, const CT&);

    Callback_ImagerControlMgrIPC_GetRunInformation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        ImagerSetupInfo iceP_runInfo;
        try
        {
            proxy->end_GetRunInformation(iceP_runInfo, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_runInfo, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetRunInformation.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetRunInformationPtr
newCallback_ImagerControlMgrIPC_GetRunInformation(const IceUtil::Handle<T>& instance, void (T::*cb)(const ImagerSetupInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetRunInformation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetRunInformation.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetRunInformationPtr
newCallback_ImagerControlMgrIPC_GetRunInformation(T* instance, void (T::*cb)(const ImagerSetupInfo&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetRunInformation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallInformation.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetBasecallInformation.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_GetBasecallInformation : public Callback_ImagerControlMgrIPC_GetBasecallInformation_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_GetBasecallInformation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_GetBasecallInformation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallInformation.
 */
template<class T> Callback_ImagerControlMgrIPC_GetBasecallInformationPtr
newCallback_ImagerControlMgrIPC_GetBasecallInformation(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetBasecallInformation<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallInformation.
 */
template<class T> Callback_ImagerControlMgrIPC_GetBasecallInformationPtr
newCallback_ImagerControlMgrIPC_GetBasecallInformation(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetBasecallInformation<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallInformation.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetBasecallInformation.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_GetBasecallInformation : public Callback_ImagerControlMgrIPC_GetBasecallInformation_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_GetBasecallInformation(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_GetBasecallInformation(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallInformation.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetBasecallInformationPtr
newCallback_ImagerControlMgrIPC_GetBasecallInformation(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetBasecallInformation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallInformation.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetBasecallInformationPtr
newCallback_ImagerControlMgrIPC_GetBasecallInformation(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetBasecallInformation<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_EndCycle.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_EndCycle.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_EndCycle : public Callback_ImagerControlMgrIPC_EndCycle_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_EndCycle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_EndCycle(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_EndCycle.
 */
template<class T> Callback_ImagerControlMgrIPC_EndCyclePtr
newCallback_ImagerControlMgrIPC_EndCycle(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_EndCycle<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_EndCycle.
 */
template<class T> Callback_ImagerControlMgrIPC_EndCyclePtr
newCallback_ImagerControlMgrIPC_EndCycle(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_EndCycle<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_EndCycle.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_EndCycle.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_EndCycle : public Callback_ImagerControlMgrIPC_EndCycle_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_EndCycle(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_EndCycle(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_EndCycle.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_EndCyclePtr
newCallback_ImagerControlMgrIPC_EndCycle(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_EndCycle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_EndCycle.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_EndCyclePtr
newCallback_ImagerControlMgrIPC_EndCycle(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_EndCycle<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_StartRunScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_StartRunScript.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_StartRunScript : public Callback_ImagerControlMgrIPC_StartRunScript_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_StartRunScript(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_StartRunScript(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_StartRunScript.
 */
template<class T> Callback_ImagerControlMgrIPC_StartRunScriptPtr
newCallback_ImagerControlMgrIPC_StartRunScript(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_StartRunScript<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_StartRunScript.
 */
template<class T> Callback_ImagerControlMgrIPC_StartRunScriptPtr
newCallback_ImagerControlMgrIPC_StartRunScript(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_StartRunScript<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_StartRunScript.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_StartRunScript.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_StartRunScript : public Callback_ImagerControlMgrIPC_StartRunScript_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_StartRunScript(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_StartRunScript(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_StartRunScript.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_StartRunScriptPtr
newCallback_ImagerControlMgrIPC_StartRunScript(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_StartRunScript<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_StartRunScript.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_StartRunScriptPtr
newCallback_ImagerControlMgrIPC_StartRunScript(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_StartRunScript<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallFlowcellConsumptionDiskSpace.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace : public Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, ::Ice::Double);

    CallbackNC_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        ::Ice::Double iceP_value;
        bool ret;
        try
        {
            ret = proxy->end_GetBasecallFlowcellConsumptionDiskSpace(iceP_value, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_value);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallFlowcellConsumptionDiskSpace.
 */
template<class T> Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpacePtr
newCallback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, ::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallFlowcellConsumptionDiskSpace.
 */
template<class T> Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpacePtr
newCallback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace(T* instance, void (T::*cb)(bool, ::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallFlowcellConsumptionDiskSpace.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace : public Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, ::Ice::Double, const CT&);

    Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        ::Ice::Double iceP_value;
        bool ret;
        try
        {
            ret = proxy->end_GetBasecallFlowcellConsumptionDiskSpace(iceP_value, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_value, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallFlowcellConsumptionDiskSpace.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpacePtr
newCallback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, ::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallFlowcellConsumptionDiskSpace.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpacePtr
newCallback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace(T* instance, void (T::*cb)(bool, ::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetBasecallFlowcellConsumptionDiskSpace<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallRemoteDiskSpace.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace : public Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, ::Ice::Double);

    CallbackNC_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        ::Ice::Double iceP_value;
        bool ret;
        try
        {
            ret = proxy->end_GetBasecallRemoteDiskSpace(iceP_value, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_value);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallRemoteDiskSpace.
 */
template<class T> Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpacePtr
newCallback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, ::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallRemoteDiskSpace.
 */
template<class T> Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpacePtr
newCallback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace(T* instance, void (T::*cb)(bool, ::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallRemoteDiskSpace.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace : public Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, ::Ice::Double, const CT&);

    Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        ::Ice::Double iceP_value;
        bool ret;
        try
        {
            ret = proxy->end_GetBasecallRemoteDiskSpace(iceP_value, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_value, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallRemoteDiskSpace.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpacePtr
newCallback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, ::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallRemoteDiskSpace.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpacePtr
newCallback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace(T* instance, void (T::*cb)(bool, ::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetBasecallRemoteDiskSpace<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallLocalDiskSpace.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_GetBasecallLocalDiskSpace : public Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, ::Ice::Double);

    CallbackNC_ImagerControlMgrIPC_GetBasecallLocalDiskSpace(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        ::Ice::Double iceP_value;
        bool ret;
        try
        {
            ret = proxy->end_GetBasecallLocalDiskSpace(iceP_value, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_value);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallLocalDiskSpace.
 */
template<class T> Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpacePtr
newCallback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, ::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetBasecallLocalDiskSpace<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallLocalDiskSpace.
 */
template<class T> Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpacePtr
newCallback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace(T* instance, void (T::*cb)(bool, ::Ice::Double), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetBasecallLocalDiskSpace<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallLocalDiskSpace.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace : public Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, ::Ice::Double, const CT&);

    Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        ::Ice::Double iceP_value;
        bool ret;
        try
        {
            ret = proxy->end_GetBasecallLocalDiskSpace(iceP_value, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_value, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallLocalDiskSpace.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpacePtr
newCallback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, ::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetBasecallLocalDiskSpace.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpacePtr
newCallback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace(T* instance, void (T::*cb)(bool, ::Ice::Double, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetBasecallLocalDiskSpace<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetParam.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetParam.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_GetParam : public Callback_ImagerControlMgrIPC_GetParam_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const ::std::string&);

    CallbackNC_ImagerControlMgrIPC_GetParam(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_value;
        bool ret;
        try
        {
            ret = proxy->end_GetParam(iceP_value, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_value);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetParam.
 */
template<class T> Callback_ImagerControlMgrIPC_GetParamPtr
newCallback_ImagerControlMgrIPC_GetParam(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetParam<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetParam.
 */
template<class T> Callback_ImagerControlMgrIPC_GetParamPtr
newCallback_ImagerControlMgrIPC_GetParam(T* instance, void (T::*cb)(bool, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetParam<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetParam.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetParam.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_GetParam : public Callback_ImagerControlMgrIPC_GetParam_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const ::std::string&, const CT&);

    Callback_ImagerControlMgrIPC_GetParam(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_value;
        bool ret;
        try
        {
            ret = proxy->end_GetParam(iceP_value, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_value, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetParam.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetParamPtr
newCallback_ImagerControlMgrIPC_GetParam(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetParam<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetParam.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetParamPtr
newCallback_ImagerControlMgrIPC_GetParam(T* instance, void (T::*cb)(bool, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetParam<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SetParam.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_SetParam.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_SetParam : public Callback_ImagerControlMgrIPC_SetParam_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ImagerControlMgrIPC_SetParam(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_SetParam(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SetParam.
 */
template<class T> Callback_ImagerControlMgrIPC_SetParamPtr
newCallback_ImagerControlMgrIPC_SetParam(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_SetParam<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SetParam.
 */
template<class T> Callback_ImagerControlMgrIPC_SetParamPtr
newCallback_ImagerControlMgrIPC_SetParam(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_SetParam<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SetParam.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_SetParam.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_SetParam : public Callback_ImagerControlMgrIPC_SetParam_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ImagerControlMgrIPC_SetParam(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_SetParam(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SetParam.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_SetParamPtr
newCallback_ImagerControlMgrIPC_SetParam(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_SetParam<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_SetParam.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_SetParamPtr
newCallback_ImagerControlMgrIPC_SetParam(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_SetParam<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetVersions.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetVersions.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPC_GetVersions : public Callback_ImagerControlMgrIPC_GetVersions_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(const ::std::string&, const ::std::string&, const ::std::string&);

    CallbackNC_ImagerControlMgrIPC_GetVersions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_bcsVer;
        ::std::string iceP_sbcVer;
        ::std::string iceP_imagerVer;
        try
        {
            proxy->end_GetVersions(iceP_bcsVer, iceP_sbcVer, iceP_imagerVer, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(iceP_bcsVer, iceP_sbcVer, iceP_imagerVer);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetVersions.
 */
template<class T> Callback_ImagerControlMgrIPC_GetVersionsPtr
newCallback_ImagerControlMgrIPC_GetVersions(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetVersions<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetVersions.
 */
template<class T> Callback_ImagerControlMgrIPC_GetVersionsPtr
newCallback_ImagerControlMgrIPC_GetVersions(T* instance, void (T::*cb)(const ::std::string&, const ::std::string&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPC_GetVersions<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetVersions.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPC_GetVersions.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPC_GetVersions : public Callback_ImagerControlMgrIPC_GetVersions_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const ::std::string&, const ::std::string&, const ::std::string&, const CT&);

    Callback_ImagerControlMgrIPC_GetVersions(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCPrx proxy = ImagerControlMgrIPCPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_bcsVer;
        ::std::string iceP_sbcVer;
        ::std::string iceP_imagerVer;
        try
        {
            proxy->end_GetVersions(iceP_bcsVer, iceP_sbcVer, iceP_imagerVer, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(iceP_bcsVer, iceP_sbcVer, iceP_imagerVer, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetVersions.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetVersionsPtr
newCallback_ImagerControlMgrIPC_GetVersions(const IceUtil::Handle<T>& instance, void (T::*cb)(const ::std::string&, const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetVersions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPC::begin_GetVersions.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPC_GetVersionsPtr
newCallback_ImagerControlMgrIPC_GetVersions(T* instance, void (T::*cb)(const ::std::string&, const ::std::string&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPC_GetVersions<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerError.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendImagerError.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPCCallback_SendImagerError : public Callback_ImagerControlMgrIPCCallback_SendImagerError_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ImagerControlMgrIPCCallback_SendImagerError(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerError.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendImagerErrorPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerError(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendImagerError<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerError.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendImagerErrorPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerError(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendImagerError<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerError.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendImagerErrorPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerError(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendImagerError<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerError.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendImagerErrorPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerError(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendImagerError<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerError.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendImagerError.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPCCallback_SendImagerError : public Callback_ImagerControlMgrIPCCallback_SendImagerError_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ImagerControlMgrIPCCallback_SendImagerError(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerError.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendImagerErrorPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerError(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendImagerError<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerError.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendImagerErrorPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerError(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendImagerError<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerError.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendImagerErrorPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerError(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendImagerError<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerError.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendImagerErrorPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerError(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendImagerError<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerRunInfo.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendImagerRunInfo.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPCCallback_SendImagerRunInfo : public Callback_ImagerControlMgrIPCCallback_SendImagerRunInfo_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ImagerControlMgrIPCCallback_SendImagerRunInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerRunInfo.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendImagerRunInfoPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerRunInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendImagerRunInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerRunInfo.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendImagerRunInfoPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerRunInfo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendImagerRunInfo<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerRunInfo.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendImagerRunInfoPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerRunInfo(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendImagerRunInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerRunInfo.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendImagerRunInfoPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerRunInfo(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendImagerRunInfo<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerRunInfo.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendImagerRunInfo.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPCCallback_SendImagerRunInfo : public Callback_ImagerControlMgrIPCCallback_SendImagerRunInfo_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ImagerControlMgrIPCCallback_SendImagerRunInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerRunInfo.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendImagerRunInfoPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerRunInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendImagerRunInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerRunInfo.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendImagerRunInfoPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerRunInfo(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendImagerRunInfo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerRunInfo.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendImagerRunInfoPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerRunInfo(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendImagerRunInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerRunInfo.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendImagerRunInfoPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerRunInfo(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendImagerRunInfo<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerTaskEnd.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendImagerTaskEnd.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPCCallback_SendImagerTaskEnd : public Callback_ImagerControlMgrIPCCallback_SendImagerTaskEnd_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ImagerControlMgrIPCCallback_SendImagerTaskEnd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerTaskEnd.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendImagerTaskEndPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerTaskEnd(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendImagerTaskEnd<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerTaskEnd.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendImagerTaskEndPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerTaskEnd(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendImagerTaskEnd<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerTaskEnd.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendImagerTaskEndPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerTaskEnd(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendImagerTaskEnd<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerTaskEnd.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendImagerTaskEndPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerTaskEnd(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendImagerTaskEnd<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerTaskEnd.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendImagerTaskEnd.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPCCallback_SendImagerTaskEnd : public Callback_ImagerControlMgrIPCCallback_SendImagerTaskEnd_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ImagerControlMgrIPCCallback_SendImagerTaskEnd(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerTaskEnd.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendImagerTaskEndPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerTaskEnd(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendImagerTaskEnd<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerTaskEnd.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendImagerTaskEndPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerTaskEnd(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendImagerTaskEnd<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerTaskEnd.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendImagerTaskEndPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerTaskEnd(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendImagerTaskEnd<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendImagerTaskEnd.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendImagerTaskEndPtr
newCallback_ImagerControlMgrIPCCallback_SendImagerTaskEnd(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendImagerTaskEnd<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendData.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendData.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPCCallback_SendData : public Callback_ImagerControlMgrIPCCallback_SendData_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ImagerControlMgrIPCCallback_SendData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendData.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendDataPtr
newCallback_ImagerControlMgrIPCCallback_SendData(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendData.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendDataPtr
newCallback_ImagerControlMgrIPCCallback_SendData(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendData<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendData.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendDataPtr
newCallback_ImagerControlMgrIPCCallback_SendData(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendData<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendData.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendDataPtr
newCallback_ImagerControlMgrIPCCallback_SendData(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendData<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendData.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendData.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPCCallback_SendData : public Callback_ImagerControlMgrIPCCallback_SendData_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ImagerControlMgrIPCCallback_SendData(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendData.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendDataPtr
newCallback_ImagerControlMgrIPCCallback_SendData(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendData.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendDataPtr
newCallback_ImagerControlMgrIPCCallback_SendData(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendData<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendData.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendDataPtr
newCallback_ImagerControlMgrIPCCallback_SendData(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendData<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendData.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendDataPtr
newCallback_ImagerControlMgrIPCCallback_SendData(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendData<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendHeartbeat.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendHeartbeat.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPCCallback_SendHeartbeat : public Callback_ImagerControlMgrIPCCallback_SendHeartbeat_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(::Ice::Int);

    CallbackNC_ImagerControlMgrIPCCallback_SendHeartbeat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCCallbackPrx proxy = ImagerControlMgrIPCCallbackPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_SendHeartbeat(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendHeartbeat.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendHeartbeatPtr
newCallback_ImagerControlMgrIPCCallback_SendHeartbeat(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendHeartbeat<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendHeartbeat.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendHeartbeatPtr
newCallback_ImagerControlMgrIPCCallback_SendHeartbeat(T* instance, void (T::*cb)(::Ice::Int), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendHeartbeat<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendHeartbeat.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendHeartbeat.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPCCallback_SendHeartbeat : public Callback_ImagerControlMgrIPCCallback_SendHeartbeat_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(::Ice::Int, const CT&);

    Callback_ImagerControlMgrIPCCallback_SendHeartbeat(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ImagerControlMgrIPCCallbackPrx proxy = ImagerControlMgrIPCCallbackPrx::uncheckedCast(result->getProxy());
        ::Ice::Int ret;
        try
        {
            ret = proxy->end_SendHeartbeat(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendHeartbeat.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendHeartbeatPtr
newCallback_ImagerControlMgrIPCCallback_SendHeartbeat(const IceUtil::Handle<T>& instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendHeartbeat<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendHeartbeat.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendHeartbeatPtr
newCallback_ImagerControlMgrIPCCallback_SendHeartbeat(T* instance, void (T::*cb)(::Ice::Int, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendHeartbeat<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendStatus.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendStatus.
 */
template<class T>
class CallbackNC_ImagerControlMgrIPCCallback_SendStatus : public Callback_ImagerControlMgrIPCCallback_SendStatus_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ImagerControlMgrIPCCallback_SendStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendStatus.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendStatusPtr
newCallback_ImagerControlMgrIPCCallback_SendStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendStatus.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendStatusPtr
newCallback_ImagerControlMgrIPCCallback_SendStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendStatus<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendStatus.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendStatusPtr
newCallback_ImagerControlMgrIPCCallback_SendStatus(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendStatus<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendStatus.
 */
template<class T> Callback_ImagerControlMgrIPCCallback_SendStatusPtr
newCallback_ImagerControlMgrIPCCallback_SendStatus(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ImagerControlMgrIPCCallback_SendStatus<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendStatus.
 * Create a wrapper instance by calling ::BGI::RPC::newCallback_ImagerControlMgrIPCCallback_SendStatus.
 */
template<class T, typename CT>
class Callback_ImagerControlMgrIPCCallback_SendStatus : public Callback_ImagerControlMgrIPCCallback_SendStatus_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ImagerControlMgrIPCCallback_SendStatus(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendStatus.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendStatusPtr
newCallback_ImagerControlMgrIPCCallback_SendStatus(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendStatus.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendStatusPtr
newCallback_ImagerControlMgrIPCCallback_SendStatus(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendStatus<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendStatus.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendStatusPtr
newCallback_ImagerControlMgrIPCCallback_SendStatus(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendStatus<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::BGI::RPC::ImagerControlMgrIPCCallback::begin_SendStatus.
 */
template<class T, typename CT> Callback_ImagerControlMgrIPCCallback_SendStatusPtr
newCallback_ImagerControlMgrIPCCallback_SendStatus(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ImagerControlMgrIPCCallback_SendStatus<T, CT>(instance, 0, excb, sentcb);
}

}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
